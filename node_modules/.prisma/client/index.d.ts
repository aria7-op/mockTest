
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserSession
 * 
 */
export type UserSession = $Result.DefaultSelection<Prisma.$UserSessionPayload>
/**
 * Model ExamCategory
 * 
 */
export type ExamCategory = $Result.DefaultSelection<Prisma.$ExamCategoryPayload>
/**
 * Model Question
 * 
 */
export type Question = $Result.DefaultSelection<Prisma.$QuestionPayload>
/**
 * Model QuestionOption
 * 
 */
export type QuestionOption = $Result.DefaultSelection<Prisma.$QuestionOptionPayload>
/**
 * Model QuestionImage
 * 
 */
export type QuestionImage = $Result.DefaultSelection<Prisma.$QuestionImagePayload>
/**
 * Model QuestionTag
 * 
 */
export type QuestionTag = $Result.DefaultSelection<Prisma.$QuestionTagPayload>
/**
 * Model Exam
 * 
 */
export type Exam = $Result.DefaultSelection<Prisma.$ExamPayload>
/**
 * Model ExamQuestion
 * 
 */
export type ExamQuestion = $Result.DefaultSelection<Prisma.$ExamQuestionPayload>
/**
 * Model ExamBooking
 * 
 */
export type ExamBooking = $Result.DefaultSelection<Prisma.$ExamBookingPayload>
/**
 * Model ExamAttempt
 * 
 */
export type ExamAttempt = $Result.DefaultSelection<Prisma.$ExamAttemptPayload>
/**
 * Model QuestionResponse
 * 
 */
export type QuestionResponse = $Result.DefaultSelection<Prisma.$QuestionResponsePayload>
/**
 * Model QuestionScore
 * 
 */
export type QuestionScore = $Result.DefaultSelection<Prisma.$QuestionScorePayload>
/**
 * Model ExamScore
 * 
 */
export type ExamScore = $Result.DefaultSelection<Prisma.$ExamScorePayload>
/**
 * Model UserPerformance
 * 
 */
export type UserPerformance = $Result.DefaultSelection<Prisma.$UserPerformancePayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Certificate
 * 
 */
export type Certificate = $Result.DefaultSelection<Prisma.$CertificatePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model StudyGroup
 * 
 */
export type StudyGroup = $Result.DefaultSelection<Prisma.$StudyGroupPayload>
/**
 * Model StudyGroupMember
 * 
 */
export type StudyGroupMember = $Result.DefaultSelection<Prisma.$StudyGroupMemberPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model ExamCategoryUser
 * 
 */
export type ExamCategoryUser = $Result.DefaultSelection<Prisma.$ExamCategoryUserPayload>
/**
 * Model ExamStatisticsView
 * @map("exam_statistics_view")
 */
export type ExamStatisticsView = $Result.DefaultSelection<Prisma.$ExamStatisticsViewPayload>
/**
 * Model UserPerformanceView
 * @map("user_performance_view")
 */
export type UserPerformanceView = $Result.DefaultSelection<Prisma.$UserPerformanceViewPayload>
/**
 * Model QuestionAnalyticsView
 * @map("question_analytics_view")
 */
export type QuestionAnalyticsView = $Result.DefaultSelection<Prisma.$QuestionAnalyticsViewPayload>
/**
 * Model RevenueAnalyticsView
 * @map("revenue_analytics_view")
 */
export type RevenueAnalyticsView = $Result.DefaultSelection<Prisma.$RevenueAnalyticsViewPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  OTHER: 'OTHER',
  PREFER_NOT_TO_SAY: 'PREFER_NOT_TO_SAY'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const UserRole: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  ADMIN: 'ADMIN',
  MODERATOR: 'MODERATOR',
  STUDENT: 'STUDENT'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const QuestionType: {
  MULTIPLE_CHOICE: 'MULTIPLE_CHOICE',
  SINGLE_CHOICE: 'SINGLE_CHOICE',
  TRUE_FALSE: 'TRUE_FALSE',
  FILL_IN_THE_BLANK: 'FILL_IN_THE_BLANK',
  SHORT_ANSWER: 'SHORT_ANSWER',
  ESSAY: 'ESSAY',
  MATCHING: 'MATCHING',
  ORDERING: 'ORDERING'
};

export type QuestionType = (typeof QuestionType)[keyof typeof QuestionType]


export const QuestionDifficulty: {
  EASY: 'EASY',
  MEDIUM: 'MEDIUM',
  HARD: 'HARD',
  EXPERT: 'EXPERT'
};

export type QuestionDifficulty = (typeof QuestionDifficulty)[keyof typeof QuestionDifficulty]


export const BookingStatus: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  CANCELLED: 'CANCELLED',
  EXPIRED: 'EXPIRED'
};

export type BookingStatus = (typeof BookingStatus)[keyof typeof BookingStatus]


export const AttemptStatus: {
  NOT_STARTED: 'NOT_STARTED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  TIMED_OUT: 'TIMED_OUT',
  ABANDONED: 'ABANDONED',
  DISQUALIFIED: 'DISQUALIFIED'
};

export type AttemptStatus = (typeof AttemptStatus)[keyof typeof AttemptStatus]


export const PaymentStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED',
  REFUNDED: 'REFUNDED',
  PARTIALLY_REFUNDED: 'PARTIALLY_REFUNDED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const PaymentMethod: {
  CREDIT_CARD: 'CREDIT_CARD',
  DEBIT_CARD: 'DEBIT_CARD',
  BANK_TRANSFER: 'BANK_TRANSFER',
  PAYPAL: 'PAYPAL',
  STRIPE: 'STRIPE',
  CASH: 'CASH'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const NotificationType: {
  EXAM_BOOKING: 'EXAM_BOOKING',
  EXAM_REMINDER: 'EXAM_REMINDER',
  EXAM_RESULT: 'EXAM_RESULT',
  PAYMENT_SUCCESS: 'PAYMENT_SUCCESS',
  PAYMENT_FAILED: 'PAYMENT_FAILED',
  CERTIFICATE_ISSUED: 'CERTIFICATE_ISSUED',
  SYSTEM_ANNOUNCEMENT: 'SYSTEM_ANNOUNCEMENT',
  GENERAL: 'GENERAL'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const GroupRole: {
  OWNER: 'OWNER',
  ADMIN: 'ADMIN',
  MODERATOR: 'MODERATOR',
  MEMBER: 'MEMBER'
};

export type GroupRole = (typeof GroupRole)[keyof typeof GroupRole]


export const AccessLevel: {
  READ: 'READ',
  WRITE: 'WRITE',
  ADMIN: 'ADMIN'
};

export type AccessLevel = (typeof AccessLevel)[keyof typeof AccessLevel]

}

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type QuestionType = $Enums.QuestionType

export const QuestionType: typeof $Enums.QuestionType

export type QuestionDifficulty = $Enums.QuestionDifficulty

export const QuestionDifficulty: typeof $Enums.QuestionDifficulty

export type BookingStatus = $Enums.BookingStatus

export const BookingStatus: typeof $Enums.BookingStatus

export type AttemptStatus = $Enums.AttemptStatus

export const AttemptStatus: typeof $Enums.AttemptStatus

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type GroupRole = $Enums.GroupRole

export const GroupRole: typeof $Enums.GroupRole

export type AccessLevel = $Enums.AccessLevel

export const AccessLevel: typeof $Enums.AccessLevel

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSession`: Exposes CRUD operations for the **UserSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSessions
    * const userSessions = await prisma.userSession.findMany()
    * ```
    */
  get userSession(): Prisma.UserSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.examCategory`: Exposes CRUD operations for the **ExamCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExamCategories
    * const examCategories = await prisma.examCategory.findMany()
    * ```
    */
  get examCategory(): Prisma.ExamCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.question`: Exposes CRUD operations for the **Question** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questions
    * const questions = await prisma.question.findMany()
    * ```
    */
  get question(): Prisma.QuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.questionOption`: Exposes CRUD operations for the **QuestionOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionOptions
    * const questionOptions = await prisma.questionOption.findMany()
    * ```
    */
  get questionOption(): Prisma.QuestionOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.questionImage`: Exposes CRUD operations for the **QuestionImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionImages
    * const questionImages = await prisma.questionImage.findMany()
    * ```
    */
  get questionImage(): Prisma.QuestionImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.questionTag`: Exposes CRUD operations for the **QuestionTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionTags
    * const questionTags = await prisma.questionTag.findMany()
    * ```
    */
  get questionTag(): Prisma.QuestionTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exam`: Exposes CRUD operations for the **Exam** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exams
    * const exams = await prisma.exam.findMany()
    * ```
    */
  get exam(): Prisma.ExamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.examQuestion`: Exposes CRUD operations for the **ExamQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExamQuestions
    * const examQuestions = await prisma.examQuestion.findMany()
    * ```
    */
  get examQuestion(): Prisma.ExamQuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.examBooking`: Exposes CRUD operations for the **ExamBooking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExamBookings
    * const examBookings = await prisma.examBooking.findMany()
    * ```
    */
  get examBooking(): Prisma.ExamBookingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.examAttempt`: Exposes CRUD operations for the **ExamAttempt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExamAttempts
    * const examAttempts = await prisma.examAttempt.findMany()
    * ```
    */
  get examAttempt(): Prisma.ExamAttemptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.questionResponse`: Exposes CRUD operations for the **QuestionResponse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionResponses
    * const questionResponses = await prisma.questionResponse.findMany()
    * ```
    */
  get questionResponse(): Prisma.QuestionResponseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.questionScore`: Exposes CRUD operations for the **QuestionScore** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionScores
    * const questionScores = await prisma.questionScore.findMany()
    * ```
    */
  get questionScore(): Prisma.QuestionScoreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.examScore`: Exposes CRUD operations for the **ExamScore** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExamScores
    * const examScores = await prisma.examScore.findMany()
    * ```
    */
  get examScore(): Prisma.ExamScoreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPerformance`: Exposes CRUD operations for the **UserPerformance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPerformances
    * const userPerformances = await prisma.userPerformance.findMany()
    * ```
    */
  get userPerformance(): Prisma.UserPerformanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.certificate`: Exposes CRUD operations for the **Certificate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Certificates
    * const certificates = await prisma.certificate.findMany()
    * ```
    */
  get certificate(): Prisma.CertificateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studyGroup`: Exposes CRUD operations for the **StudyGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudyGroups
    * const studyGroups = await prisma.studyGroup.findMany()
    * ```
    */
  get studyGroup(): Prisma.StudyGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studyGroupMember`: Exposes CRUD operations for the **StudyGroupMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudyGroupMembers
    * const studyGroupMembers = await prisma.studyGroupMember.findMany()
    * ```
    */
  get studyGroupMember(): Prisma.StudyGroupMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.examCategoryUser`: Exposes CRUD operations for the **ExamCategoryUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExamCategoryUsers
    * const examCategoryUsers = await prisma.examCategoryUser.findMany()
    * ```
    */
  get examCategoryUser(): Prisma.ExamCategoryUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.examStatisticsView`: Exposes CRUD operations for the **ExamStatisticsView** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExamStatisticsViews
    * const examStatisticsViews = await prisma.examStatisticsView.findMany()
    * ```
    */
  get examStatisticsView(): Prisma.ExamStatisticsViewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPerformanceView`: Exposes CRUD operations for the **UserPerformanceView** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPerformanceViews
    * const userPerformanceViews = await prisma.userPerformanceView.findMany()
    * ```
    */
  get userPerformanceView(): Prisma.UserPerformanceViewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.questionAnalyticsView`: Exposes CRUD operations for the **QuestionAnalyticsView** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionAnalyticsViews
    * const questionAnalyticsViews = await prisma.questionAnalyticsView.findMany()
    * ```
    */
  get questionAnalyticsView(): Prisma.QuestionAnalyticsViewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.revenueAnalyticsView`: Exposes CRUD operations for the **RevenueAnalyticsView** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RevenueAnalyticsViews
    * const revenueAnalyticsViews = await prisma.revenueAnalyticsView.findMany()
    * ```
    */
  get revenueAnalyticsView(): Prisma.RevenueAnalyticsViewDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.13.0
   * Query Engine version: 361e86d0ea4987e9f53a565309b3eed797a6bcbd
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    UserSession: 'UserSession',
    ExamCategory: 'ExamCategory',
    Question: 'Question',
    QuestionOption: 'QuestionOption',
    QuestionImage: 'QuestionImage',
    QuestionTag: 'QuestionTag',
    Exam: 'Exam',
    ExamQuestion: 'ExamQuestion',
    ExamBooking: 'ExamBooking',
    ExamAttempt: 'ExamAttempt',
    QuestionResponse: 'QuestionResponse',
    QuestionScore: 'QuestionScore',
    ExamScore: 'ExamScore',
    UserPerformance: 'UserPerformance',
    Payment: 'Payment',
    Certificate: 'Certificate',
    Notification: 'Notification',
    StudyGroup: 'StudyGroup',
    StudyGroupMember: 'StudyGroupMember',
    AuditLog: 'AuditLog',
    ExamCategoryUser: 'ExamCategoryUser',
    ExamStatisticsView: 'ExamStatisticsView',
    UserPerformanceView: 'UserPerformanceView',
    QuestionAnalyticsView: 'QuestionAnalyticsView',
    RevenueAnalyticsView: 'RevenueAnalyticsView'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "userSession" | "examCategory" | "question" | "questionOption" | "questionImage" | "questionTag" | "exam" | "examQuestion" | "examBooking" | "examAttempt" | "questionResponse" | "questionScore" | "examScore" | "userPerformance" | "payment" | "certificate" | "notification" | "studyGroup" | "studyGroupMember" | "auditLog" | "examCategoryUser" | "examStatisticsView" | "userPerformanceView" | "questionAnalyticsView" | "revenueAnalyticsView"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserSession: {
        payload: Prisma.$UserSessionPayload<ExtArgs>
        fields: Prisma.UserSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findFirst: {
            args: Prisma.UserSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findMany: {
            args: Prisma.UserSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          create: {
            args: Prisma.UserSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          createMany: {
            args: Prisma.UserSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          delete: {
            args: Prisma.UserSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          update: {
            args: Prisma.UserSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          deleteMany: {
            args: Prisma.UserSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          upsert: {
            args: Prisma.UserSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          aggregate: {
            args: Prisma.UserSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSession>
          }
          groupBy: {
            args: Prisma.UserSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSessionCountArgs<ExtArgs>
            result: $Utils.Optional<UserSessionCountAggregateOutputType> | number
          }
        }
      }
      ExamCategory: {
        payload: Prisma.$ExamCategoryPayload<ExtArgs>
        fields: Prisma.ExamCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamCategoryPayload>
          }
          findFirst: {
            args: Prisma.ExamCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamCategoryPayload>
          }
          findMany: {
            args: Prisma.ExamCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamCategoryPayload>[]
          }
          create: {
            args: Prisma.ExamCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamCategoryPayload>
          }
          createMany: {
            args: Prisma.ExamCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExamCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamCategoryPayload>[]
          }
          delete: {
            args: Prisma.ExamCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamCategoryPayload>
          }
          update: {
            args: Prisma.ExamCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ExamCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExamCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamCategoryPayload>[]
          }
          upsert: {
            args: Prisma.ExamCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamCategoryPayload>
          }
          aggregate: {
            args: Prisma.ExamCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExamCategory>
          }
          groupBy: {
            args: Prisma.ExamCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ExamCategoryCountAggregateOutputType> | number
          }
        }
      }
      Question: {
        payload: Prisma.$QuestionPayload<ExtArgs>
        fields: Prisma.QuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          findFirst: {
            args: Prisma.QuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          findMany: {
            args: Prisma.QuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>[]
          }
          create: {
            args: Prisma.QuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          createMany: {
            args: Prisma.QuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>[]
          }
          delete: {
            args: Prisma.QuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          update: {
            args: Prisma.QuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          deleteMany: {
            args: Prisma.QuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>[]
          }
          upsert: {
            args: Prisma.QuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionPayload>
          }
          aggregate: {
            args: Prisma.QuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestion>
          }
          groupBy: {
            args: Prisma.QuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionCountAggregateOutputType> | number
          }
        }
      }
      QuestionOption: {
        payload: Prisma.$QuestionOptionPayload<ExtArgs>
        fields: Prisma.QuestionOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionOptionPayload>
          }
          findFirst: {
            args: Prisma.QuestionOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionOptionPayload>
          }
          findMany: {
            args: Prisma.QuestionOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionOptionPayload>[]
          }
          create: {
            args: Prisma.QuestionOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionOptionPayload>
          }
          createMany: {
            args: Prisma.QuestionOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestionOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionOptionPayload>[]
          }
          delete: {
            args: Prisma.QuestionOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionOptionPayload>
          }
          update: {
            args: Prisma.QuestionOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionOptionPayload>
          }
          deleteMany: {
            args: Prisma.QuestionOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuestionOptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionOptionPayload>[]
          }
          upsert: {
            args: Prisma.QuestionOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionOptionPayload>
          }
          aggregate: {
            args: Prisma.QuestionOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestionOption>
          }
          groupBy: {
            args: Prisma.QuestionOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionOptionCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionOptionCountAggregateOutputType> | number
          }
        }
      }
      QuestionImage: {
        payload: Prisma.$QuestionImagePayload<ExtArgs>
        fields: Prisma.QuestionImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionImagePayload>
          }
          findFirst: {
            args: Prisma.QuestionImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionImagePayload>
          }
          findMany: {
            args: Prisma.QuestionImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionImagePayload>[]
          }
          create: {
            args: Prisma.QuestionImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionImagePayload>
          }
          createMany: {
            args: Prisma.QuestionImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestionImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionImagePayload>[]
          }
          delete: {
            args: Prisma.QuestionImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionImagePayload>
          }
          update: {
            args: Prisma.QuestionImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionImagePayload>
          }
          deleteMany: {
            args: Prisma.QuestionImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuestionImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionImagePayload>[]
          }
          upsert: {
            args: Prisma.QuestionImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionImagePayload>
          }
          aggregate: {
            args: Prisma.QuestionImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestionImage>
          }
          groupBy: {
            args: Prisma.QuestionImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionImageCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionImageCountAggregateOutputType> | number
          }
        }
      }
      QuestionTag: {
        payload: Prisma.$QuestionTagPayload<ExtArgs>
        fields: Prisma.QuestionTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionTagPayload>
          }
          findFirst: {
            args: Prisma.QuestionTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionTagPayload>
          }
          findMany: {
            args: Prisma.QuestionTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionTagPayload>[]
          }
          create: {
            args: Prisma.QuestionTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionTagPayload>
          }
          createMany: {
            args: Prisma.QuestionTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestionTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionTagPayload>[]
          }
          delete: {
            args: Prisma.QuestionTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionTagPayload>
          }
          update: {
            args: Prisma.QuestionTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionTagPayload>
          }
          deleteMany: {
            args: Prisma.QuestionTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuestionTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionTagPayload>[]
          }
          upsert: {
            args: Prisma.QuestionTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionTagPayload>
          }
          aggregate: {
            args: Prisma.QuestionTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestionTag>
          }
          groupBy: {
            args: Prisma.QuestionTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionTagCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionTagCountAggregateOutputType> | number
          }
        }
      }
      Exam: {
        payload: Prisma.$ExamPayload<ExtArgs>
        fields: Prisma.ExamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          findFirst: {
            args: Prisma.ExamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          findMany: {
            args: Prisma.ExamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>[]
          }
          create: {
            args: Prisma.ExamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          createMany: {
            args: Prisma.ExamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>[]
          }
          delete: {
            args: Prisma.ExamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          update: {
            args: Prisma.ExamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          deleteMany: {
            args: Prisma.ExamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>[]
          }
          upsert: {
            args: Prisma.ExamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          aggregate: {
            args: Prisma.ExamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExam>
          }
          groupBy: {
            args: Prisma.ExamGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamCountArgs<ExtArgs>
            result: $Utils.Optional<ExamCountAggregateOutputType> | number
          }
        }
      }
      ExamQuestion: {
        payload: Prisma.$ExamQuestionPayload<ExtArgs>
        fields: Prisma.ExamQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamQuestionPayload>
          }
          findFirst: {
            args: Prisma.ExamQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamQuestionPayload>
          }
          findMany: {
            args: Prisma.ExamQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamQuestionPayload>[]
          }
          create: {
            args: Prisma.ExamQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamQuestionPayload>
          }
          createMany: {
            args: Prisma.ExamQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExamQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamQuestionPayload>[]
          }
          delete: {
            args: Prisma.ExamQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamQuestionPayload>
          }
          update: {
            args: Prisma.ExamQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamQuestionPayload>
          }
          deleteMany: {
            args: Prisma.ExamQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExamQuestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamQuestionPayload>[]
          }
          upsert: {
            args: Prisma.ExamQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamQuestionPayload>
          }
          aggregate: {
            args: Prisma.ExamQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExamQuestion>
          }
          groupBy: {
            args: Prisma.ExamQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<ExamQuestionCountAggregateOutputType> | number
          }
        }
      }
      ExamBooking: {
        payload: Prisma.$ExamBookingPayload<ExtArgs>
        fields: Prisma.ExamBookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamBookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamBookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamBookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamBookingPayload>
          }
          findFirst: {
            args: Prisma.ExamBookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamBookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamBookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamBookingPayload>
          }
          findMany: {
            args: Prisma.ExamBookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamBookingPayload>[]
          }
          create: {
            args: Prisma.ExamBookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamBookingPayload>
          }
          createMany: {
            args: Prisma.ExamBookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExamBookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamBookingPayload>[]
          }
          delete: {
            args: Prisma.ExamBookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamBookingPayload>
          }
          update: {
            args: Prisma.ExamBookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamBookingPayload>
          }
          deleteMany: {
            args: Prisma.ExamBookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamBookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExamBookingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamBookingPayload>[]
          }
          upsert: {
            args: Prisma.ExamBookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamBookingPayload>
          }
          aggregate: {
            args: Prisma.ExamBookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExamBooking>
          }
          groupBy: {
            args: Prisma.ExamBookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamBookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamBookingCountArgs<ExtArgs>
            result: $Utils.Optional<ExamBookingCountAggregateOutputType> | number
          }
        }
      }
      ExamAttempt: {
        payload: Prisma.$ExamAttemptPayload<ExtArgs>
        fields: Prisma.ExamAttemptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamAttemptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamAttemptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload>
          }
          findFirst: {
            args: Prisma.ExamAttemptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamAttemptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload>
          }
          findMany: {
            args: Prisma.ExamAttemptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload>[]
          }
          create: {
            args: Prisma.ExamAttemptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload>
          }
          createMany: {
            args: Prisma.ExamAttemptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExamAttemptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload>[]
          }
          delete: {
            args: Prisma.ExamAttemptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload>
          }
          update: {
            args: Prisma.ExamAttemptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload>
          }
          deleteMany: {
            args: Prisma.ExamAttemptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamAttemptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExamAttemptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload>[]
          }
          upsert: {
            args: Prisma.ExamAttemptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamAttemptPayload>
          }
          aggregate: {
            args: Prisma.ExamAttemptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExamAttempt>
          }
          groupBy: {
            args: Prisma.ExamAttemptGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamAttemptGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamAttemptCountArgs<ExtArgs>
            result: $Utils.Optional<ExamAttemptCountAggregateOutputType> | number
          }
        }
      }
      QuestionResponse: {
        payload: Prisma.$QuestionResponsePayload<ExtArgs>
        fields: Prisma.QuestionResponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionResponseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionResponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionResponseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionResponsePayload>
          }
          findFirst: {
            args: Prisma.QuestionResponseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionResponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionResponseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionResponsePayload>
          }
          findMany: {
            args: Prisma.QuestionResponseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionResponsePayload>[]
          }
          create: {
            args: Prisma.QuestionResponseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionResponsePayload>
          }
          createMany: {
            args: Prisma.QuestionResponseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestionResponseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionResponsePayload>[]
          }
          delete: {
            args: Prisma.QuestionResponseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionResponsePayload>
          }
          update: {
            args: Prisma.QuestionResponseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionResponsePayload>
          }
          deleteMany: {
            args: Prisma.QuestionResponseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionResponseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuestionResponseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionResponsePayload>[]
          }
          upsert: {
            args: Prisma.QuestionResponseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionResponsePayload>
          }
          aggregate: {
            args: Prisma.QuestionResponseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestionResponse>
          }
          groupBy: {
            args: Prisma.QuestionResponseGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionResponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionResponseCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionResponseCountAggregateOutputType> | number
          }
        }
      }
      QuestionScore: {
        payload: Prisma.$QuestionScorePayload<ExtArgs>
        fields: Prisma.QuestionScoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionScoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionScorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionScoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionScorePayload>
          }
          findFirst: {
            args: Prisma.QuestionScoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionScorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionScoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionScorePayload>
          }
          findMany: {
            args: Prisma.QuestionScoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionScorePayload>[]
          }
          create: {
            args: Prisma.QuestionScoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionScorePayload>
          }
          createMany: {
            args: Prisma.QuestionScoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestionScoreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionScorePayload>[]
          }
          delete: {
            args: Prisma.QuestionScoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionScorePayload>
          }
          update: {
            args: Prisma.QuestionScoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionScorePayload>
          }
          deleteMany: {
            args: Prisma.QuestionScoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionScoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuestionScoreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionScorePayload>[]
          }
          upsert: {
            args: Prisma.QuestionScoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionScorePayload>
          }
          aggregate: {
            args: Prisma.QuestionScoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestionScore>
          }
          groupBy: {
            args: Prisma.QuestionScoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionScoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionScoreCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionScoreCountAggregateOutputType> | number
          }
        }
      }
      ExamScore: {
        payload: Prisma.$ExamScorePayload<ExtArgs>
        fields: Prisma.ExamScoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamScoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamScorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamScoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamScorePayload>
          }
          findFirst: {
            args: Prisma.ExamScoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamScorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamScoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamScorePayload>
          }
          findMany: {
            args: Prisma.ExamScoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamScorePayload>[]
          }
          create: {
            args: Prisma.ExamScoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamScorePayload>
          }
          createMany: {
            args: Prisma.ExamScoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExamScoreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamScorePayload>[]
          }
          delete: {
            args: Prisma.ExamScoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamScorePayload>
          }
          update: {
            args: Prisma.ExamScoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamScorePayload>
          }
          deleteMany: {
            args: Prisma.ExamScoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamScoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExamScoreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamScorePayload>[]
          }
          upsert: {
            args: Prisma.ExamScoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamScorePayload>
          }
          aggregate: {
            args: Prisma.ExamScoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExamScore>
          }
          groupBy: {
            args: Prisma.ExamScoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamScoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamScoreCountArgs<ExtArgs>
            result: $Utils.Optional<ExamScoreCountAggregateOutputType> | number
          }
        }
      }
      UserPerformance: {
        payload: Prisma.$UserPerformancePayload<ExtArgs>
        fields: Prisma.UserPerformanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPerformanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPerformancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPerformanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPerformancePayload>
          }
          findFirst: {
            args: Prisma.UserPerformanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPerformancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPerformanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPerformancePayload>
          }
          findMany: {
            args: Prisma.UserPerformanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPerformancePayload>[]
          }
          create: {
            args: Prisma.UserPerformanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPerformancePayload>
          }
          createMany: {
            args: Prisma.UserPerformanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPerformanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPerformancePayload>[]
          }
          delete: {
            args: Prisma.UserPerformanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPerformancePayload>
          }
          update: {
            args: Prisma.UserPerformanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPerformancePayload>
          }
          deleteMany: {
            args: Prisma.UserPerformanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPerformanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserPerformanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPerformancePayload>[]
          }
          upsert: {
            args: Prisma.UserPerformanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPerformancePayload>
          }
          aggregate: {
            args: Prisma.UserPerformanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPerformance>
          }
          groupBy: {
            args: Prisma.UserPerformanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPerformanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPerformanceCountArgs<ExtArgs>
            result: $Utils.Optional<UserPerformanceCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Certificate: {
        payload: Prisma.$CertificatePayload<ExtArgs>
        fields: Prisma.CertificateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CertificateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CertificateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          findFirst: {
            args: Prisma.CertificateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CertificateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          findMany: {
            args: Prisma.CertificateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>[]
          }
          create: {
            args: Prisma.CertificateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          createMany: {
            args: Prisma.CertificateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CertificateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>[]
          }
          delete: {
            args: Prisma.CertificateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          update: {
            args: Prisma.CertificateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          deleteMany: {
            args: Prisma.CertificateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CertificateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CertificateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>[]
          }
          upsert: {
            args: Prisma.CertificateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          aggregate: {
            args: Prisma.CertificateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCertificate>
          }
          groupBy: {
            args: Prisma.CertificateGroupByArgs<ExtArgs>
            result: $Utils.Optional<CertificateGroupByOutputType>[]
          }
          count: {
            args: Prisma.CertificateCountArgs<ExtArgs>
            result: $Utils.Optional<CertificateCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      StudyGroup: {
        payload: Prisma.$StudyGroupPayload<ExtArgs>
        fields: Prisma.StudyGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudyGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudyGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyGroupPayload>
          }
          findFirst: {
            args: Prisma.StudyGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudyGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyGroupPayload>
          }
          findMany: {
            args: Prisma.StudyGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyGroupPayload>[]
          }
          create: {
            args: Prisma.StudyGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyGroupPayload>
          }
          createMany: {
            args: Prisma.StudyGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudyGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyGroupPayload>[]
          }
          delete: {
            args: Prisma.StudyGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyGroupPayload>
          }
          update: {
            args: Prisma.StudyGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyGroupPayload>
          }
          deleteMany: {
            args: Prisma.StudyGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudyGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudyGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyGroupPayload>[]
          }
          upsert: {
            args: Prisma.StudyGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyGroupPayload>
          }
          aggregate: {
            args: Prisma.StudyGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudyGroup>
          }
          groupBy: {
            args: Prisma.StudyGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudyGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudyGroupCountArgs<ExtArgs>
            result: $Utils.Optional<StudyGroupCountAggregateOutputType> | number
          }
        }
      }
      StudyGroupMember: {
        payload: Prisma.$StudyGroupMemberPayload<ExtArgs>
        fields: Prisma.StudyGroupMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudyGroupMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyGroupMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudyGroupMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyGroupMemberPayload>
          }
          findFirst: {
            args: Prisma.StudyGroupMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyGroupMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudyGroupMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyGroupMemberPayload>
          }
          findMany: {
            args: Prisma.StudyGroupMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyGroupMemberPayload>[]
          }
          create: {
            args: Prisma.StudyGroupMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyGroupMemberPayload>
          }
          createMany: {
            args: Prisma.StudyGroupMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudyGroupMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyGroupMemberPayload>[]
          }
          delete: {
            args: Prisma.StudyGroupMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyGroupMemberPayload>
          }
          update: {
            args: Prisma.StudyGroupMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyGroupMemberPayload>
          }
          deleteMany: {
            args: Prisma.StudyGroupMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudyGroupMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudyGroupMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyGroupMemberPayload>[]
          }
          upsert: {
            args: Prisma.StudyGroupMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudyGroupMemberPayload>
          }
          aggregate: {
            args: Prisma.StudyGroupMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudyGroupMember>
          }
          groupBy: {
            args: Prisma.StudyGroupMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudyGroupMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudyGroupMemberCountArgs<ExtArgs>
            result: $Utils.Optional<StudyGroupMemberCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      ExamCategoryUser: {
        payload: Prisma.$ExamCategoryUserPayload<ExtArgs>
        fields: Prisma.ExamCategoryUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamCategoryUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamCategoryUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamCategoryUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamCategoryUserPayload>
          }
          findFirst: {
            args: Prisma.ExamCategoryUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamCategoryUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamCategoryUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamCategoryUserPayload>
          }
          findMany: {
            args: Prisma.ExamCategoryUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamCategoryUserPayload>[]
          }
          create: {
            args: Prisma.ExamCategoryUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamCategoryUserPayload>
          }
          createMany: {
            args: Prisma.ExamCategoryUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExamCategoryUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamCategoryUserPayload>[]
          }
          delete: {
            args: Prisma.ExamCategoryUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamCategoryUserPayload>
          }
          update: {
            args: Prisma.ExamCategoryUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamCategoryUserPayload>
          }
          deleteMany: {
            args: Prisma.ExamCategoryUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamCategoryUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExamCategoryUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamCategoryUserPayload>[]
          }
          upsert: {
            args: Prisma.ExamCategoryUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamCategoryUserPayload>
          }
          aggregate: {
            args: Prisma.ExamCategoryUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExamCategoryUser>
          }
          groupBy: {
            args: Prisma.ExamCategoryUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamCategoryUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamCategoryUserCountArgs<ExtArgs>
            result: $Utils.Optional<ExamCategoryUserCountAggregateOutputType> | number
          }
        }
      }
      ExamStatisticsView: {
        payload: Prisma.$ExamStatisticsViewPayload<ExtArgs>
        fields: Prisma.ExamStatisticsViewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamStatisticsViewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamStatisticsViewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamStatisticsViewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamStatisticsViewPayload>
          }
          findFirst: {
            args: Prisma.ExamStatisticsViewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamStatisticsViewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamStatisticsViewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamStatisticsViewPayload>
          }
          findMany: {
            args: Prisma.ExamStatisticsViewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamStatisticsViewPayload>[]
          }
          create: {
            args: Prisma.ExamStatisticsViewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamStatisticsViewPayload>
          }
          createMany: {
            args: Prisma.ExamStatisticsViewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExamStatisticsViewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamStatisticsViewPayload>[]
          }
          delete: {
            args: Prisma.ExamStatisticsViewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamStatisticsViewPayload>
          }
          update: {
            args: Prisma.ExamStatisticsViewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamStatisticsViewPayload>
          }
          deleteMany: {
            args: Prisma.ExamStatisticsViewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamStatisticsViewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExamStatisticsViewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamStatisticsViewPayload>[]
          }
          upsert: {
            args: Prisma.ExamStatisticsViewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamStatisticsViewPayload>
          }
          aggregate: {
            args: Prisma.ExamStatisticsViewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExamStatisticsView>
          }
          groupBy: {
            args: Prisma.ExamStatisticsViewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamStatisticsViewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamStatisticsViewCountArgs<ExtArgs>
            result: $Utils.Optional<ExamStatisticsViewCountAggregateOutputType> | number
          }
        }
      }
      UserPerformanceView: {
        payload: Prisma.$UserPerformanceViewPayload<ExtArgs>
        fields: Prisma.UserPerformanceViewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPerformanceViewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPerformanceViewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPerformanceViewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPerformanceViewPayload>
          }
          findFirst: {
            args: Prisma.UserPerformanceViewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPerformanceViewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPerformanceViewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPerformanceViewPayload>
          }
          findMany: {
            args: Prisma.UserPerformanceViewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPerformanceViewPayload>[]
          }
          create: {
            args: Prisma.UserPerformanceViewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPerformanceViewPayload>
          }
          createMany: {
            args: Prisma.UserPerformanceViewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPerformanceViewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPerformanceViewPayload>[]
          }
          delete: {
            args: Prisma.UserPerformanceViewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPerformanceViewPayload>
          }
          update: {
            args: Prisma.UserPerformanceViewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPerformanceViewPayload>
          }
          deleteMany: {
            args: Prisma.UserPerformanceViewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPerformanceViewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserPerformanceViewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPerformanceViewPayload>[]
          }
          upsert: {
            args: Prisma.UserPerformanceViewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPerformanceViewPayload>
          }
          aggregate: {
            args: Prisma.UserPerformanceViewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPerformanceView>
          }
          groupBy: {
            args: Prisma.UserPerformanceViewGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPerformanceViewGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPerformanceViewCountArgs<ExtArgs>
            result: $Utils.Optional<UserPerformanceViewCountAggregateOutputType> | number
          }
        }
      }
      QuestionAnalyticsView: {
        payload: Prisma.$QuestionAnalyticsViewPayload<ExtArgs>
        fields: Prisma.QuestionAnalyticsViewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionAnalyticsViewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnalyticsViewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionAnalyticsViewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnalyticsViewPayload>
          }
          findFirst: {
            args: Prisma.QuestionAnalyticsViewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnalyticsViewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionAnalyticsViewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnalyticsViewPayload>
          }
          findMany: {
            args: Prisma.QuestionAnalyticsViewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnalyticsViewPayload>[]
          }
          create: {
            args: Prisma.QuestionAnalyticsViewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnalyticsViewPayload>
          }
          createMany: {
            args: Prisma.QuestionAnalyticsViewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestionAnalyticsViewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnalyticsViewPayload>[]
          }
          delete: {
            args: Prisma.QuestionAnalyticsViewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnalyticsViewPayload>
          }
          update: {
            args: Prisma.QuestionAnalyticsViewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnalyticsViewPayload>
          }
          deleteMany: {
            args: Prisma.QuestionAnalyticsViewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionAnalyticsViewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuestionAnalyticsViewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnalyticsViewPayload>[]
          }
          upsert: {
            args: Prisma.QuestionAnalyticsViewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionAnalyticsViewPayload>
          }
          aggregate: {
            args: Prisma.QuestionAnalyticsViewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestionAnalyticsView>
          }
          groupBy: {
            args: Prisma.QuestionAnalyticsViewGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionAnalyticsViewGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionAnalyticsViewCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionAnalyticsViewCountAggregateOutputType> | number
          }
        }
      }
      RevenueAnalyticsView: {
        payload: Prisma.$RevenueAnalyticsViewPayload<ExtArgs>
        fields: Prisma.RevenueAnalyticsViewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RevenueAnalyticsViewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueAnalyticsViewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RevenueAnalyticsViewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueAnalyticsViewPayload>
          }
          findFirst: {
            args: Prisma.RevenueAnalyticsViewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueAnalyticsViewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RevenueAnalyticsViewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueAnalyticsViewPayload>
          }
          findMany: {
            args: Prisma.RevenueAnalyticsViewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueAnalyticsViewPayload>[]
          }
          create: {
            args: Prisma.RevenueAnalyticsViewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueAnalyticsViewPayload>
          }
          createMany: {
            args: Prisma.RevenueAnalyticsViewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RevenueAnalyticsViewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueAnalyticsViewPayload>[]
          }
          delete: {
            args: Prisma.RevenueAnalyticsViewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueAnalyticsViewPayload>
          }
          update: {
            args: Prisma.RevenueAnalyticsViewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueAnalyticsViewPayload>
          }
          deleteMany: {
            args: Prisma.RevenueAnalyticsViewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RevenueAnalyticsViewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RevenueAnalyticsViewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueAnalyticsViewPayload>[]
          }
          upsert: {
            args: Prisma.RevenueAnalyticsViewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RevenueAnalyticsViewPayload>
          }
          aggregate: {
            args: Prisma.RevenueAnalyticsViewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRevenueAnalyticsView>
          }
          groupBy: {
            args: Prisma.RevenueAnalyticsViewGroupByArgs<ExtArgs>
            result: $Utils.Optional<RevenueAnalyticsViewGroupByOutputType>[]
          }
          count: {
            args: Prisma.RevenueAnalyticsViewCountArgs<ExtArgs>
            result: $Utils.Optional<RevenueAnalyticsViewCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    userSession?: UserSessionOmit
    examCategory?: ExamCategoryOmit
    question?: QuestionOmit
    questionOption?: QuestionOptionOmit
    questionImage?: QuestionImageOmit
    questionTag?: QuestionTagOmit
    exam?: ExamOmit
    examQuestion?: ExamQuestionOmit
    examBooking?: ExamBookingOmit
    examAttempt?: ExamAttemptOmit
    questionResponse?: QuestionResponseOmit
    questionScore?: QuestionScoreOmit
    examScore?: ExamScoreOmit
    userPerformance?: UserPerformanceOmit
    payment?: PaymentOmit
    certificate?: CertificateOmit
    notification?: NotificationOmit
    studyGroup?: StudyGroupOmit
    studyGroupMember?: StudyGroupMemberOmit
    auditLog?: AuditLogOmit
    examCategoryUser?: ExamCategoryUserOmit
    examStatisticsView?: ExamStatisticsViewOmit
    userPerformanceView?: UserPerformanceViewOmit
    questionAnalyticsView?: QuestionAnalyticsViewOmit
    revenueAnalyticsView?: RevenueAnalyticsViewOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    examBookings: number
    payments: number
    examAttempts: number
    questionResponses: number
    questionScores: number
    examScores: number
    userPerformances: number
    notifications: number
    auditLogs: number
    userSessions: number
    examCategories: number
    studyGroups: number
    certificates: number
    grantedExamCategories: number
    createdStudyGroups: number
    createdQuestions: number
    approvedQuestions: number
    createdExams: number
    approvedExams: number
    revokedCertificates: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examBookings?: boolean | UserCountOutputTypeCountExamBookingsArgs
    payments?: boolean | UserCountOutputTypeCountPaymentsArgs
    examAttempts?: boolean | UserCountOutputTypeCountExamAttemptsArgs
    questionResponses?: boolean | UserCountOutputTypeCountQuestionResponsesArgs
    questionScores?: boolean | UserCountOutputTypeCountQuestionScoresArgs
    examScores?: boolean | UserCountOutputTypeCountExamScoresArgs
    userPerformances?: boolean | UserCountOutputTypeCountUserPerformancesArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    userSessions?: boolean | UserCountOutputTypeCountUserSessionsArgs
    examCategories?: boolean | UserCountOutputTypeCountExamCategoriesArgs
    studyGroups?: boolean | UserCountOutputTypeCountStudyGroupsArgs
    certificates?: boolean | UserCountOutputTypeCountCertificatesArgs
    grantedExamCategories?: boolean | UserCountOutputTypeCountGrantedExamCategoriesArgs
    createdStudyGroups?: boolean | UserCountOutputTypeCountCreatedStudyGroupsArgs
    createdQuestions?: boolean | UserCountOutputTypeCountCreatedQuestionsArgs
    approvedQuestions?: boolean | UserCountOutputTypeCountApprovedQuestionsArgs
    createdExams?: boolean | UserCountOutputTypeCountCreatedExamsArgs
    approvedExams?: boolean | UserCountOutputTypeCountApprovedExamsArgs
    revokedCertificates?: boolean | UserCountOutputTypeCountRevokedCertificatesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExamBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamBookingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExamAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamAttemptWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQuestionResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionResponseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQuestionScoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionScoreWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExamScoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamScoreWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserPerformancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPerformanceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExamCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamCategoryUserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountStudyGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudyGroupMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCertificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGrantedExamCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamCategoryUserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedStudyGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudyGroupWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovedQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovedExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRevokedCertificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
  }


  /**
   * Count Type ExamCategoryCountOutputType
   */

  export type ExamCategoryCountOutputType = {
    exams: number
    questions: number
    users: number
    userPerformances: number
  }

  export type ExamCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exams?: boolean | ExamCategoryCountOutputTypeCountExamsArgs
    questions?: boolean | ExamCategoryCountOutputTypeCountQuestionsArgs
    users?: boolean | ExamCategoryCountOutputTypeCountUsersArgs
    userPerformances?: boolean | ExamCategoryCountOutputTypeCountUserPerformancesArgs
  }

  // Custom InputTypes
  /**
   * ExamCategoryCountOutputType without action
   */
  export type ExamCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamCategoryCountOutputType
     */
    select?: ExamCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExamCategoryCountOutputType without action
   */
  export type ExamCategoryCountOutputTypeCountExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
  }

  /**
   * ExamCategoryCountOutputType without action
   */
  export type ExamCategoryCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionWhereInput
  }

  /**
   * ExamCategoryCountOutputType without action
   */
  export type ExamCategoryCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamCategoryUserWhereInput
  }

  /**
   * ExamCategoryCountOutputType without action
   */
  export type ExamCategoryCountOutputTypeCountUserPerformancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPerformanceWhereInput
  }


  /**
   * Count Type QuestionCountOutputType
   */

  export type QuestionCountOutputType = {
    options: number
    images: number
    tags: number
    examQuestions: number
    responses: number
    scores: number
  }

  export type QuestionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    options?: boolean | QuestionCountOutputTypeCountOptionsArgs
    images?: boolean | QuestionCountOutputTypeCountImagesArgs
    tags?: boolean | QuestionCountOutputTypeCountTagsArgs
    examQuestions?: boolean | QuestionCountOutputTypeCountExamQuestionsArgs
    responses?: boolean | QuestionCountOutputTypeCountResponsesArgs
    scores?: boolean | QuestionCountOutputTypeCountScoresArgs
  }

  // Custom InputTypes
  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionCountOutputType
     */
    select?: QuestionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeCountOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionOptionWhereInput
  }

  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionImageWhereInput
  }

  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionTagWhereInput
  }

  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeCountExamQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamQuestionWhereInput
  }

  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeCountResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionResponseWhereInput
  }

  /**
   * QuestionCountOutputType without action
   */
  export type QuestionCountOutputTypeCountScoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionScoreWhereInput
  }


  /**
   * Count Type ExamCountOutputType
   */

  export type ExamCountOutputType = {
    questions: number
    bookings: number
    attempts: number
    examScores: number
    certificates: number
  }

  export type ExamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | ExamCountOutputTypeCountQuestionsArgs
    bookings?: boolean | ExamCountOutputTypeCountBookingsArgs
    attempts?: boolean | ExamCountOutputTypeCountAttemptsArgs
    examScores?: boolean | ExamCountOutputTypeCountExamScoresArgs
    certificates?: boolean | ExamCountOutputTypeCountCertificatesArgs
  }

  // Custom InputTypes
  /**
   * ExamCountOutputType without action
   */
  export type ExamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamCountOutputType
     */
    select?: ExamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExamCountOutputType without action
   */
  export type ExamCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamQuestionWhereInput
  }

  /**
   * ExamCountOutputType without action
   */
  export type ExamCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamBookingWhereInput
  }

  /**
   * ExamCountOutputType without action
   */
  export type ExamCountOutputTypeCountAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamAttemptWhereInput
  }

  /**
   * ExamCountOutputType without action
   */
  export type ExamCountOutputTypeCountExamScoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamScoreWhereInput
  }

  /**
   * ExamCountOutputType without action
   */
  export type ExamCountOutputTypeCountCertificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
  }


  /**
   * Count Type ExamBookingCountOutputType
   */

  export type ExamBookingCountOutputType = {
    attempts: number
  }

  export type ExamBookingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempts?: boolean | ExamBookingCountOutputTypeCountAttemptsArgs
  }

  // Custom InputTypes
  /**
   * ExamBookingCountOutputType without action
   */
  export type ExamBookingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamBookingCountOutputType
     */
    select?: ExamBookingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExamBookingCountOutputType without action
   */
  export type ExamBookingCountOutputTypeCountAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamAttemptWhereInput
  }


  /**
   * Count Type ExamAttemptCountOutputType
   */

  export type ExamAttemptCountOutputType = {
    responses: number
    questionScores: number
  }

  export type ExamAttemptCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responses?: boolean | ExamAttemptCountOutputTypeCountResponsesArgs
    questionScores?: boolean | ExamAttemptCountOutputTypeCountQuestionScoresArgs
  }

  // Custom InputTypes
  /**
   * ExamAttemptCountOutputType without action
   */
  export type ExamAttemptCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttemptCountOutputType
     */
    select?: ExamAttemptCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExamAttemptCountOutputType without action
   */
  export type ExamAttemptCountOutputTypeCountResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionResponseWhereInput
  }

  /**
   * ExamAttemptCountOutputType without action
   */
  export type ExamAttemptCountOutputTypeCountQuestionScoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionScoreWhereInput
  }


  /**
   * Count Type StudyGroupCountOutputType
   */

  export type StudyGroupCountOutputType = {
    members: number
  }

  export type StudyGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | StudyGroupCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * StudyGroupCountOutputType without action
   */
  export type StudyGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyGroupCountOutputType
     */
    select?: StudyGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudyGroupCountOutputType without action
   */
  export type StudyGroupCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudyGroupMemberWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    loginAttempts: number | null
  }

  export type UserSumAggregateOutputType = {
    loginAttempts: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    dateOfBirth: Date | null
    gender: $Enums.Gender | null
    profileImage: string | null
    profilePicture: string | null
    address: string | null
    isActive: boolean | null
    isEmailVerified: boolean | null
    isPhoneVerified: boolean | null
    emailVerificationToken: string | null
    passwordResetToken: string | null
    passwordResetExpires: Date | null
    lastLoginAt: Date | null
    loginAttempts: number | null
    lockedUntil: Date | null
    role: $Enums.UserRole | null
    status: string | null
    departmentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    dateOfBirth: Date | null
    gender: $Enums.Gender | null
    profileImage: string | null
    profilePicture: string | null
    address: string | null
    isActive: boolean | null
    isEmailVerified: boolean | null
    isPhoneVerified: boolean | null
    emailVerificationToken: string | null
    passwordResetToken: string | null
    passwordResetExpires: Date | null
    lastLoginAt: Date | null
    loginAttempts: number | null
    lockedUntil: Date | null
    role: $Enums.UserRole | null
    status: string | null
    departmentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    firstName: number
    lastName: number
    phone: number
    dateOfBirth: number
    gender: number
    profileImage: number
    profilePicture: number
    address: number
    isActive: number
    isEmailVerified: number
    isPhoneVerified: number
    emailVerificationToken: number
    passwordResetToken: number
    passwordResetExpires: number
    lastLoginAt: number
    loginAttempts: number
    lockedUntil: number
    role: number
    status: number
    departmentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    loginAttempts?: true
  }

  export type UserSumAggregateInputType = {
    loginAttempts?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    phone?: true
    dateOfBirth?: true
    gender?: true
    profileImage?: true
    profilePicture?: true
    address?: true
    isActive?: true
    isEmailVerified?: true
    isPhoneVerified?: true
    emailVerificationToken?: true
    passwordResetToken?: true
    passwordResetExpires?: true
    lastLoginAt?: true
    loginAttempts?: true
    lockedUntil?: true
    role?: true
    status?: true
    departmentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    phone?: true
    dateOfBirth?: true
    gender?: true
    profileImage?: true
    profilePicture?: true
    address?: true
    isActive?: true
    isEmailVerified?: true
    isPhoneVerified?: true
    emailVerificationToken?: true
    passwordResetToken?: true
    passwordResetExpires?: true
    lastLoginAt?: true
    loginAttempts?: true
    lockedUntil?: true
    role?: true
    status?: true
    departmentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    phone?: true
    dateOfBirth?: true
    gender?: true
    profileImage?: true
    profilePicture?: true
    address?: true
    isActive?: true
    isEmailVerified?: true
    isPhoneVerified?: true
    emailVerificationToken?: true
    passwordResetToken?: true
    passwordResetExpires?: true
    lastLoginAt?: true
    loginAttempts?: true
    lockedUntil?: true
    role?: true
    status?: true
    departmentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone: string | null
    dateOfBirth: Date | null
    gender: $Enums.Gender | null
    profileImage: string | null
    profilePicture: string | null
    address: string | null
    isActive: boolean
    isEmailVerified: boolean
    isPhoneVerified: boolean
    emailVerificationToken: string | null
    passwordResetToken: string | null
    passwordResetExpires: Date | null
    lastLoginAt: Date | null
    loginAttempts: number
    lockedUntil: Date | null
    role: $Enums.UserRole
    status: string | null
    departmentId: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    profileImage?: boolean
    profilePicture?: boolean
    address?: boolean
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: boolean
    passwordResetToken?: boolean
    passwordResetExpires?: boolean
    lastLoginAt?: boolean
    loginAttempts?: boolean
    lockedUntil?: boolean
    role?: boolean
    status?: boolean
    departmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    examBookings?: boolean | User$examBookingsArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    examAttempts?: boolean | User$examAttemptsArgs<ExtArgs>
    questionResponses?: boolean | User$questionResponsesArgs<ExtArgs>
    questionScores?: boolean | User$questionScoresArgs<ExtArgs>
    examScores?: boolean | User$examScoresArgs<ExtArgs>
    userPerformances?: boolean | User$userPerformancesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    userSessions?: boolean | User$userSessionsArgs<ExtArgs>
    examCategories?: boolean | User$examCategoriesArgs<ExtArgs>
    studyGroups?: boolean | User$studyGroupsArgs<ExtArgs>
    certificates?: boolean | User$certificatesArgs<ExtArgs>
    grantedExamCategories?: boolean | User$grantedExamCategoriesArgs<ExtArgs>
    createdStudyGroups?: boolean | User$createdStudyGroupsArgs<ExtArgs>
    createdQuestions?: boolean | User$createdQuestionsArgs<ExtArgs>
    approvedQuestions?: boolean | User$approvedQuestionsArgs<ExtArgs>
    createdExams?: boolean | User$createdExamsArgs<ExtArgs>
    approvedExams?: boolean | User$approvedExamsArgs<ExtArgs>
    revokedCertificates?: boolean | User$revokedCertificatesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    profileImage?: boolean
    profilePicture?: boolean
    address?: boolean
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: boolean
    passwordResetToken?: boolean
    passwordResetExpires?: boolean
    lastLoginAt?: boolean
    loginAttempts?: boolean
    lockedUntil?: boolean
    role?: boolean
    status?: boolean
    departmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    profileImage?: boolean
    profilePicture?: boolean
    address?: boolean
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: boolean
    passwordResetToken?: boolean
    passwordResetExpires?: boolean
    lastLoginAt?: boolean
    loginAttempts?: boolean
    lockedUntil?: boolean
    role?: boolean
    status?: boolean
    departmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    profileImage?: boolean
    profilePicture?: boolean
    address?: boolean
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: boolean
    passwordResetToken?: boolean
    passwordResetExpires?: boolean
    lastLoginAt?: boolean
    loginAttempts?: boolean
    lockedUntil?: boolean
    role?: boolean
    status?: boolean
    departmentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "firstName" | "lastName" | "phone" | "dateOfBirth" | "gender" | "profileImage" | "profilePicture" | "address" | "isActive" | "isEmailVerified" | "isPhoneVerified" | "emailVerificationToken" | "passwordResetToken" | "passwordResetExpires" | "lastLoginAt" | "loginAttempts" | "lockedUntil" | "role" | "status" | "departmentId" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examBookings?: boolean | User$examBookingsArgs<ExtArgs>
    payments?: boolean | User$paymentsArgs<ExtArgs>
    examAttempts?: boolean | User$examAttemptsArgs<ExtArgs>
    questionResponses?: boolean | User$questionResponsesArgs<ExtArgs>
    questionScores?: boolean | User$questionScoresArgs<ExtArgs>
    examScores?: boolean | User$examScoresArgs<ExtArgs>
    userPerformances?: boolean | User$userPerformancesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    userSessions?: boolean | User$userSessionsArgs<ExtArgs>
    examCategories?: boolean | User$examCategoriesArgs<ExtArgs>
    studyGroups?: boolean | User$studyGroupsArgs<ExtArgs>
    certificates?: boolean | User$certificatesArgs<ExtArgs>
    grantedExamCategories?: boolean | User$grantedExamCategoriesArgs<ExtArgs>
    createdStudyGroups?: boolean | User$createdStudyGroupsArgs<ExtArgs>
    createdQuestions?: boolean | User$createdQuestionsArgs<ExtArgs>
    approvedQuestions?: boolean | User$approvedQuestionsArgs<ExtArgs>
    createdExams?: boolean | User$createdExamsArgs<ExtArgs>
    approvedExams?: boolean | User$approvedExamsArgs<ExtArgs>
    revokedCertificates?: boolean | User$revokedCertificatesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      examBookings: Prisma.$ExamBookingPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      examAttempts: Prisma.$ExamAttemptPayload<ExtArgs>[]
      questionResponses: Prisma.$QuestionResponsePayload<ExtArgs>[]
      questionScores: Prisma.$QuestionScorePayload<ExtArgs>[]
      examScores: Prisma.$ExamScorePayload<ExtArgs>[]
      userPerformances: Prisma.$UserPerformancePayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      userSessions: Prisma.$UserSessionPayload<ExtArgs>[]
      examCategories: Prisma.$ExamCategoryUserPayload<ExtArgs>[]
      studyGroups: Prisma.$StudyGroupMemberPayload<ExtArgs>[]
      certificates: Prisma.$CertificatePayload<ExtArgs>[]
      grantedExamCategories: Prisma.$ExamCategoryUserPayload<ExtArgs>[]
      createdStudyGroups: Prisma.$StudyGroupPayload<ExtArgs>[]
      createdQuestions: Prisma.$QuestionPayload<ExtArgs>[]
      approvedQuestions: Prisma.$QuestionPayload<ExtArgs>[]
      createdExams: Prisma.$ExamPayload<ExtArgs>[]
      approvedExams: Prisma.$ExamPayload<ExtArgs>[]
      revokedCertificates: Prisma.$CertificatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      firstName: string
      lastName: string
      phone: string | null
      dateOfBirth: Date | null
      gender: $Enums.Gender | null
      profileImage: string | null
      profilePicture: string | null
      address: string | null
      isActive: boolean
      isEmailVerified: boolean
      isPhoneVerified: boolean
      emailVerificationToken: string | null
      passwordResetToken: string | null
      passwordResetExpires: Date | null
      lastLoginAt: Date | null
      loginAttempts: number
      lockedUntil: Date | null
      role: $Enums.UserRole
      status: string | null
      departmentId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    examBookings<T extends User$examBookingsArgs<ExtArgs> = {}>(args?: Subset<T, User$examBookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamBookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends User$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    examAttempts<T extends User$examAttemptsArgs<ExtArgs> = {}>(args?: Subset<T, User$examAttemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    questionResponses<T extends User$questionResponsesArgs<ExtArgs> = {}>(args?: Subset<T, User$questionResponsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    questionScores<T extends User$questionScoresArgs<ExtArgs> = {}>(args?: Subset<T, User$questionScoresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionScorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    examScores<T extends User$examScoresArgs<ExtArgs> = {}>(args?: Subset<T, User$examScoresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamScorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userPerformances<T extends User$userPerformancesArgs<ExtArgs> = {}>(args?: Subset<T, User$userPerformancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPerformancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userSessions<T extends User$userSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$userSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    examCategories<T extends User$examCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, User$examCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamCategoryUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    studyGroups<T extends User$studyGroupsArgs<ExtArgs> = {}>(args?: Subset<T, User$studyGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyGroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    certificates<T extends User$certificatesArgs<ExtArgs> = {}>(args?: Subset<T, User$certificatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    grantedExamCategories<T extends User$grantedExamCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, User$grantedExamCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamCategoryUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdStudyGroups<T extends User$createdStudyGroupsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdStudyGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdQuestions<T extends User$createdQuestionsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdQuestionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    approvedQuestions<T extends User$approvedQuestionsArgs<ExtArgs> = {}>(args?: Subset<T, User$approvedQuestionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdExams<T extends User$createdExamsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdExamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    approvedExams<T extends User$approvedExamsArgs<ExtArgs> = {}>(args?: Subset<T, User$approvedExamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    revokedCertificates<T extends User$revokedCertificatesArgs<ExtArgs> = {}>(args?: Subset<T, User$revokedCertificatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly dateOfBirth: FieldRef<"User", 'DateTime'>
    readonly gender: FieldRef<"User", 'Gender'>
    readonly profileImage: FieldRef<"User", 'String'>
    readonly profilePicture: FieldRef<"User", 'String'>
    readonly address: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly isEmailVerified: FieldRef<"User", 'Boolean'>
    readonly isPhoneVerified: FieldRef<"User", 'Boolean'>
    readonly emailVerificationToken: FieldRef<"User", 'String'>
    readonly passwordResetToken: FieldRef<"User", 'String'>
    readonly passwordResetExpires: FieldRef<"User", 'DateTime'>
    readonly lastLoginAt: FieldRef<"User", 'DateTime'>
    readonly loginAttempts: FieldRef<"User", 'Int'>
    readonly lockedUntil: FieldRef<"User", 'DateTime'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly status: FieldRef<"User", 'String'>
    readonly departmentId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.examBookings
   */
  export type User$examBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamBooking
     */
    select?: ExamBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamBooking
     */
    omit?: ExamBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamBookingInclude<ExtArgs> | null
    where?: ExamBookingWhereInput
    orderBy?: ExamBookingOrderByWithRelationInput | ExamBookingOrderByWithRelationInput[]
    cursor?: ExamBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamBookingScalarFieldEnum | ExamBookingScalarFieldEnum[]
  }

  /**
   * User.payments
   */
  export type User$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * User.examAttempts
   */
  export type User$examAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAttempt
     */
    omit?: ExamAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    where?: ExamAttemptWhereInput
    orderBy?: ExamAttemptOrderByWithRelationInput | ExamAttemptOrderByWithRelationInput[]
    cursor?: ExamAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamAttemptScalarFieldEnum | ExamAttemptScalarFieldEnum[]
  }

  /**
   * User.questionResponses
   */
  export type User$questionResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionResponse
     */
    select?: QuestionResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionResponse
     */
    omit?: QuestionResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionResponseInclude<ExtArgs> | null
    where?: QuestionResponseWhereInput
    orderBy?: QuestionResponseOrderByWithRelationInput | QuestionResponseOrderByWithRelationInput[]
    cursor?: QuestionResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionResponseScalarFieldEnum | QuestionResponseScalarFieldEnum[]
  }

  /**
   * User.questionScores
   */
  export type User$questionScoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionScore
     */
    select?: QuestionScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionScore
     */
    omit?: QuestionScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionScoreInclude<ExtArgs> | null
    where?: QuestionScoreWhereInput
    orderBy?: QuestionScoreOrderByWithRelationInput | QuestionScoreOrderByWithRelationInput[]
    cursor?: QuestionScoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionScoreScalarFieldEnum | QuestionScoreScalarFieldEnum[]
  }

  /**
   * User.examScores
   */
  export type User$examScoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamScore
     */
    select?: ExamScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamScore
     */
    omit?: ExamScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScoreInclude<ExtArgs> | null
    where?: ExamScoreWhereInput
    orderBy?: ExamScoreOrderByWithRelationInput | ExamScoreOrderByWithRelationInput[]
    cursor?: ExamScoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamScoreScalarFieldEnum | ExamScoreScalarFieldEnum[]
  }

  /**
   * User.userPerformances
   */
  export type User$userPerformancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPerformance
     */
    select?: UserPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPerformance
     */
    omit?: UserPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPerformanceInclude<ExtArgs> | null
    where?: UserPerformanceWhereInput
    orderBy?: UserPerformanceOrderByWithRelationInput | UserPerformanceOrderByWithRelationInput[]
    cursor?: UserPerformanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPerformanceScalarFieldEnum | UserPerformanceScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.userSessions
   */
  export type User$userSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    cursor?: UserSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * User.examCategories
   */
  export type User$examCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamCategoryUser
     */
    select?: ExamCategoryUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamCategoryUser
     */
    omit?: ExamCategoryUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamCategoryUserInclude<ExtArgs> | null
    where?: ExamCategoryUserWhereInput
    orderBy?: ExamCategoryUserOrderByWithRelationInput | ExamCategoryUserOrderByWithRelationInput[]
    cursor?: ExamCategoryUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamCategoryUserScalarFieldEnum | ExamCategoryUserScalarFieldEnum[]
  }

  /**
   * User.studyGroups
   */
  export type User$studyGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyGroupMember
     */
    select?: StudyGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyGroupMember
     */
    omit?: StudyGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyGroupMemberInclude<ExtArgs> | null
    where?: StudyGroupMemberWhereInput
    orderBy?: StudyGroupMemberOrderByWithRelationInput | StudyGroupMemberOrderByWithRelationInput[]
    cursor?: StudyGroupMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudyGroupMemberScalarFieldEnum | StudyGroupMemberScalarFieldEnum[]
  }

  /**
   * User.certificates
   */
  export type User$certificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    cursor?: CertificateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * User.grantedExamCategories
   */
  export type User$grantedExamCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamCategoryUser
     */
    select?: ExamCategoryUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamCategoryUser
     */
    omit?: ExamCategoryUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamCategoryUserInclude<ExtArgs> | null
    where?: ExamCategoryUserWhereInput
    orderBy?: ExamCategoryUserOrderByWithRelationInput | ExamCategoryUserOrderByWithRelationInput[]
    cursor?: ExamCategoryUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamCategoryUserScalarFieldEnum | ExamCategoryUserScalarFieldEnum[]
  }

  /**
   * User.createdStudyGroups
   */
  export type User$createdStudyGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyGroup
     */
    select?: StudyGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyGroup
     */
    omit?: StudyGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyGroupInclude<ExtArgs> | null
    where?: StudyGroupWhereInput
    orderBy?: StudyGroupOrderByWithRelationInput | StudyGroupOrderByWithRelationInput[]
    cursor?: StudyGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudyGroupScalarFieldEnum | StudyGroupScalarFieldEnum[]
  }

  /**
   * User.createdQuestions
   */
  export type User$createdQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    where?: QuestionWhereInput
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    cursor?: QuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * User.approvedQuestions
   */
  export type User$approvedQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    where?: QuestionWhereInput
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    cursor?: QuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * User.createdExams
   */
  export type User$createdExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    cursor?: ExamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * User.approvedExams
   */
  export type User$approvedExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    cursor?: ExamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * User.revokedCertificates
   */
  export type User$revokedCertificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    cursor?: CertificateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserSession
   */

  export type AggregateUserSession = {
    _count: UserSessionCountAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  export type UserSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    sessionToken: string | null
    expiresAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type UserSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    sessionToken: string | null
    expiresAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type UserSessionCountAggregateOutputType = {
    id: number
    userId: number
    sessionToken: number
    expiresAt: number
    ipAddress: number
    userAgent: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type UserSessionMinAggregateInputType = {
    id?: true
    userId?: true
    sessionToken?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    isActive?: true
    createdAt?: true
  }

  export type UserSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    sessionToken?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    isActive?: true
    createdAt?: true
  }

  export type UserSessionCountAggregateInputType = {
    id?: true
    userId?: true
    sessionToken?: true
    expiresAt?: true
    ipAddress?: true
    userAgent?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type UserSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSession to aggregate.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSessions
    **/
    _count?: true | UserSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSessionMaxAggregateInputType
  }

  export type GetUserSessionAggregateType<T extends UserSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSession[P]>
      : GetScalarType<T[P], AggregateUserSession[P]>
  }




  export type UserSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithAggregationInput | UserSessionOrderByWithAggregationInput[]
    by: UserSessionScalarFieldEnum[] | UserSessionScalarFieldEnum
    having?: UserSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSessionCountAggregateInputType | true
    _min?: UserSessionMinAggregateInputType
    _max?: UserSessionMaxAggregateInputType
  }

  export type UserSessionGroupByOutputType = {
    id: string
    userId: string
    sessionToken: string
    expiresAt: Date
    ipAddress: string | null
    userAgent: string | null
    isActive: boolean
    createdAt: Date
    _count: UserSessionCountAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  type GetUserSessionGroupByPayload<T extends UserSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
            : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
        }
      >
    >


  export type UserSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sessionToken?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    isActive?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sessionToken?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    isActive?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sessionToken?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    isActive?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    sessionToken?: boolean
    expiresAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type UserSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "sessionToken" | "expiresAt" | "ipAddress" | "userAgent" | "isActive" | "createdAt", ExtArgs["result"]["userSession"]>
  export type UserSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      sessionToken: string
      expiresAt: Date
      ipAddress: string | null
      userAgent: string | null
      isActive: boolean
      createdAt: Date
    }, ExtArgs["result"]["userSession"]>
    composites: {}
  }

  type UserSessionGetPayload<S extends boolean | null | undefined | UserSessionDefaultArgs> = $Result.GetResult<Prisma.$UserSessionPayload, S>

  type UserSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSessionCountAggregateInputType | true
    }

  export interface UserSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSession'], meta: { name: 'UserSession' } }
    /**
     * Find zero or one UserSession that matches the filter.
     * @param {UserSessionFindUniqueArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSessionFindUniqueArgs>(args: SelectSubset<T, UserSessionFindUniqueArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSessionFindUniqueOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSessionFindFirstArgs>(args?: SelectSubset<T, UserSessionFindFirstArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSessions
     * const userSessions = await prisma.userSession.findMany()
     * 
     * // Get first 10 UserSessions
     * const userSessions = await prisma.userSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSessionWithIdOnly = await prisma.userSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSessionFindManyArgs>(args?: SelectSubset<T, UserSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSession.
     * @param {UserSessionCreateArgs} args - Arguments to create a UserSession.
     * @example
     * // Create one UserSession
     * const UserSession = await prisma.userSession.create({
     *   data: {
     *     // ... data to create a UserSession
     *   }
     * })
     * 
     */
    create<T extends UserSessionCreateArgs>(args: SelectSubset<T, UserSessionCreateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSessions.
     * @param {UserSessionCreateManyArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSessionCreateManyArgs>(args?: SelectSubset<T, UserSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSessions and returns the data saved in the database.
     * @param {UserSessionCreateManyAndReturnArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSessions and only return the `id`
     * const userSessionWithIdOnly = await prisma.userSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSession.
     * @param {UserSessionDeleteArgs} args - Arguments to delete one UserSession.
     * @example
     * // Delete one UserSession
     * const UserSession = await prisma.userSession.delete({
     *   where: {
     *     // ... filter to delete one UserSession
     *   }
     * })
     * 
     */
    delete<T extends UserSessionDeleteArgs>(args: SelectSubset<T, UserSessionDeleteArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSession.
     * @param {UserSessionUpdateArgs} args - Arguments to update one UserSession.
     * @example
     * // Update one UserSession
     * const userSession = await prisma.userSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSessionUpdateArgs>(args: SelectSubset<T, UserSessionUpdateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSessions.
     * @param {UserSessionDeleteManyArgs} args - Arguments to filter UserSessions to delete.
     * @example
     * // Delete a few UserSessions
     * const { count } = await prisma.userSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSessionDeleteManyArgs>(args?: SelectSubset<T, UserSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSessionUpdateManyArgs>(args: SelectSubset<T, UserSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions and returns the data updated in the database.
     * @param {UserSessionUpdateManyAndReturnArgs} args - Arguments to update many UserSessions.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSessions and only return the `id`
     * const userSessionWithIdOnly = await prisma.userSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSession.
     * @param {UserSessionUpsertArgs} args - Arguments to update or create a UserSession.
     * @example
     * // Update or create a UserSession
     * const userSession = await prisma.userSession.upsert({
     *   create: {
     *     // ... data to create a UserSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSession we want to update
     *   }
     * })
     */
    upsert<T extends UserSessionUpsertArgs>(args: SelectSubset<T, UserSessionUpsertArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionCountArgs} args - Arguments to filter UserSessions to count.
     * @example
     * // Count the number of UserSessions
     * const count = await prisma.userSession.count({
     *   where: {
     *     // ... the filter for the UserSessions we want to count
     *   }
     * })
    **/
    count<T extends UserSessionCountArgs>(
      args?: Subset<T, UserSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSessionAggregateArgs>(args: Subset<T, UserSessionAggregateArgs>): Prisma.PrismaPromise<GetUserSessionAggregateType<T>>

    /**
     * Group by UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSessionGroupByArgs['orderBy'] }
        : { orderBy?: UserSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSession model
   */
  readonly fields: UserSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSession model
   */
  interface UserSessionFieldRefs {
    readonly id: FieldRef<"UserSession", 'String'>
    readonly userId: FieldRef<"UserSession", 'String'>
    readonly sessionToken: FieldRef<"UserSession", 'String'>
    readonly expiresAt: FieldRef<"UserSession", 'DateTime'>
    readonly ipAddress: FieldRef<"UserSession", 'String'>
    readonly userAgent: FieldRef<"UserSession", 'String'>
    readonly isActive: FieldRef<"UserSession", 'Boolean'>
    readonly createdAt: FieldRef<"UserSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSession findUnique
   */
  export type UserSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findUniqueOrThrow
   */
  export type UserSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findFirst
   */
  export type UserSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findFirstOrThrow
   */
  export type UserSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findMany
   */
  export type UserSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSessions to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession create
   */
  export type UserSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSession.
     */
    data: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
  }

  /**
   * UserSession createMany
   */
  export type UserSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSession createManyAndReturn
   */
  export type UserSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession update
   */
  export type UserSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSession.
     */
    data: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
    /**
     * Choose, which UserSession to update.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession updateMany
   */
  export type UserSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to update.
     */
    limit?: number
  }

  /**
   * UserSession updateManyAndReturn
   */
  export type UserSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession upsert
   */
  export type UserSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSession to update in case it exists.
     */
    where: UserSessionWhereUniqueInput
    /**
     * In case the UserSession found by the `where` argument doesn't exist, create a new UserSession with this data.
     */
    create: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
    /**
     * In case the UserSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
  }

  /**
   * UserSession delete
   */
  export type UserSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter which UserSession to delete.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession deleteMany
   */
  export type UserSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSessions to delete
     */
    where?: UserSessionWhereInput
    /**
     * Limit how many UserSessions to delete.
     */
    limit?: number
  }

  /**
   * UserSession without action
   */
  export type UserSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSession
     */
    omit?: UserSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
  }


  /**
   * Model ExamCategory
   */

  export type AggregateExamCategory = {
    _count: ExamCategoryCountAggregateOutputType | null
    _avg: ExamCategoryAvgAggregateOutputType | null
    _sum: ExamCategorySumAggregateOutputType | null
    _min: ExamCategoryMinAggregateOutputType | null
    _max: ExamCategoryMaxAggregateOutputType | null
  }

  export type ExamCategoryAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type ExamCategorySumAggregateOutputType = {
    sortOrder: number | null
  }

  export type ExamCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    icon: string | null
    color: string | null
    isActive: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    icon: string | null
    color: string | null
    isActive: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamCategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    icon: number
    color: number
    isActive: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExamCategoryAvgAggregateInputType = {
    sortOrder?: true
  }

  export type ExamCategorySumAggregateInputType = {
    sortOrder?: true
  }

  export type ExamCategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    icon?: true
    color?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    icon?: true
    color?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamCategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    icon?: true
    color?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExamCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamCategory to aggregate.
     */
    where?: ExamCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamCategories to fetch.
     */
    orderBy?: ExamCategoryOrderByWithRelationInput | ExamCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExamCategories
    **/
    _count?: true | ExamCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamCategoryMaxAggregateInputType
  }

  export type GetExamCategoryAggregateType<T extends ExamCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateExamCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamCategory[P]>
      : GetScalarType<T[P], AggregateExamCategory[P]>
  }




  export type ExamCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamCategoryWhereInput
    orderBy?: ExamCategoryOrderByWithAggregationInput | ExamCategoryOrderByWithAggregationInput[]
    by: ExamCategoryScalarFieldEnum[] | ExamCategoryScalarFieldEnum
    having?: ExamCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamCategoryCountAggregateInputType | true
    _avg?: ExamCategoryAvgAggregateInputType
    _sum?: ExamCategorySumAggregateInputType
    _min?: ExamCategoryMinAggregateInputType
    _max?: ExamCategoryMaxAggregateInputType
  }

  export type ExamCategoryGroupByOutputType = {
    id: string
    name: string
    description: string | null
    icon: string | null
    color: string | null
    isActive: boolean
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: ExamCategoryCountAggregateOutputType | null
    _avg: ExamCategoryAvgAggregateOutputType | null
    _sum: ExamCategorySumAggregateOutputType | null
    _min: ExamCategoryMinAggregateOutputType | null
    _max: ExamCategoryMaxAggregateOutputType | null
  }

  type GetExamCategoryGroupByPayload<T extends ExamCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ExamCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ExamCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    exams?: boolean | ExamCategory$examsArgs<ExtArgs>
    questions?: boolean | ExamCategory$questionsArgs<ExtArgs>
    users?: boolean | ExamCategory$usersArgs<ExtArgs>
    userPerformances?: boolean | ExamCategory$userPerformancesArgs<ExtArgs>
    _count?: boolean | ExamCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examCategory"]>

  export type ExamCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["examCategory"]>

  export type ExamCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["examCategory"]>

  export type ExamCategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExamCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "icon" | "color" | "isActive" | "sortOrder" | "createdAt" | "updatedAt", ExtArgs["result"]["examCategory"]>
  export type ExamCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exams?: boolean | ExamCategory$examsArgs<ExtArgs>
    questions?: boolean | ExamCategory$questionsArgs<ExtArgs>
    users?: boolean | ExamCategory$usersArgs<ExtArgs>
    userPerformances?: boolean | ExamCategory$userPerformancesArgs<ExtArgs>
    _count?: boolean | ExamCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExamCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ExamCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ExamCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExamCategory"
    objects: {
      exams: Prisma.$ExamPayload<ExtArgs>[]
      questions: Prisma.$QuestionPayload<ExtArgs>[]
      users: Prisma.$ExamCategoryUserPayload<ExtArgs>[]
      userPerformances: Prisma.$UserPerformancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      icon: string | null
      color: string | null
      isActive: boolean
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["examCategory"]>
    composites: {}
  }

  type ExamCategoryGetPayload<S extends boolean | null | undefined | ExamCategoryDefaultArgs> = $Result.GetResult<Prisma.$ExamCategoryPayload, S>

  type ExamCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExamCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExamCategoryCountAggregateInputType | true
    }

  export interface ExamCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExamCategory'], meta: { name: 'ExamCategory' } }
    /**
     * Find zero or one ExamCategory that matches the filter.
     * @param {ExamCategoryFindUniqueArgs} args - Arguments to find a ExamCategory
     * @example
     * // Get one ExamCategory
     * const examCategory = await prisma.examCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamCategoryFindUniqueArgs>(args: SelectSubset<T, ExamCategoryFindUniqueArgs<ExtArgs>>): Prisma__ExamCategoryClient<$Result.GetResult<Prisma.$ExamCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExamCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExamCategoryFindUniqueOrThrowArgs} args - Arguments to find a ExamCategory
     * @example
     * // Get one ExamCategory
     * const examCategory = await prisma.examCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamCategoryClient<$Result.GetResult<Prisma.$ExamCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExamCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamCategoryFindFirstArgs} args - Arguments to find a ExamCategory
     * @example
     * // Get one ExamCategory
     * const examCategory = await prisma.examCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamCategoryFindFirstArgs>(args?: SelectSubset<T, ExamCategoryFindFirstArgs<ExtArgs>>): Prisma__ExamCategoryClient<$Result.GetResult<Prisma.$ExamCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExamCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamCategoryFindFirstOrThrowArgs} args - Arguments to find a ExamCategory
     * @example
     * // Get one ExamCategory
     * const examCategory = await prisma.examCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamCategoryClient<$Result.GetResult<Prisma.$ExamCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExamCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExamCategories
     * const examCategories = await prisma.examCategory.findMany()
     * 
     * // Get first 10 ExamCategories
     * const examCategories = await prisma.examCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examCategoryWithIdOnly = await prisma.examCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamCategoryFindManyArgs>(args?: SelectSubset<T, ExamCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExamCategory.
     * @param {ExamCategoryCreateArgs} args - Arguments to create a ExamCategory.
     * @example
     * // Create one ExamCategory
     * const ExamCategory = await prisma.examCategory.create({
     *   data: {
     *     // ... data to create a ExamCategory
     *   }
     * })
     * 
     */
    create<T extends ExamCategoryCreateArgs>(args: SelectSubset<T, ExamCategoryCreateArgs<ExtArgs>>): Prisma__ExamCategoryClient<$Result.GetResult<Prisma.$ExamCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExamCategories.
     * @param {ExamCategoryCreateManyArgs} args - Arguments to create many ExamCategories.
     * @example
     * // Create many ExamCategories
     * const examCategory = await prisma.examCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamCategoryCreateManyArgs>(args?: SelectSubset<T, ExamCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExamCategories and returns the data saved in the database.
     * @param {ExamCategoryCreateManyAndReturnArgs} args - Arguments to create many ExamCategories.
     * @example
     * // Create many ExamCategories
     * const examCategory = await prisma.examCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExamCategories and only return the `id`
     * const examCategoryWithIdOnly = await prisma.examCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExamCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ExamCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExamCategory.
     * @param {ExamCategoryDeleteArgs} args - Arguments to delete one ExamCategory.
     * @example
     * // Delete one ExamCategory
     * const ExamCategory = await prisma.examCategory.delete({
     *   where: {
     *     // ... filter to delete one ExamCategory
     *   }
     * })
     * 
     */
    delete<T extends ExamCategoryDeleteArgs>(args: SelectSubset<T, ExamCategoryDeleteArgs<ExtArgs>>): Prisma__ExamCategoryClient<$Result.GetResult<Prisma.$ExamCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExamCategory.
     * @param {ExamCategoryUpdateArgs} args - Arguments to update one ExamCategory.
     * @example
     * // Update one ExamCategory
     * const examCategory = await prisma.examCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamCategoryUpdateArgs>(args: SelectSubset<T, ExamCategoryUpdateArgs<ExtArgs>>): Prisma__ExamCategoryClient<$Result.GetResult<Prisma.$ExamCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExamCategories.
     * @param {ExamCategoryDeleteManyArgs} args - Arguments to filter ExamCategories to delete.
     * @example
     * // Delete a few ExamCategories
     * const { count } = await prisma.examCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamCategoryDeleteManyArgs>(args?: SelectSubset<T, ExamCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExamCategories
     * const examCategory = await prisma.examCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamCategoryUpdateManyArgs>(args: SelectSubset<T, ExamCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamCategories and returns the data updated in the database.
     * @param {ExamCategoryUpdateManyAndReturnArgs} args - Arguments to update many ExamCategories.
     * @example
     * // Update many ExamCategories
     * const examCategory = await prisma.examCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExamCategories and only return the `id`
     * const examCategoryWithIdOnly = await prisma.examCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExamCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ExamCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExamCategory.
     * @param {ExamCategoryUpsertArgs} args - Arguments to update or create a ExamCategory.
     * @example
     * // Update or create a ExamCategory
     * const examCategory = await prisma.examCategory.upsert({
     *   create: {
     *     // ... data to create a ExamCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExamCategory we want to update
     *   }
     * })
     */
    upsert<T extends ExamCategoryUpsertArgs>(args: SelectSubset<T, ExamCategoryUpsertArgs<ExtArgs>>): Prisma__ExamCategoryClient<$Result.GetResult<Prisma.$ExamCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExamCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamCategoryCountArgs} args - Arguments to filter ExamCategories to count.
     * @example
     * // Count the number of ExamCategories
     * const count = await prisma.examCategory.count({
     *   where: {
     *     // ... the filter for the ExamCategories we want to count
     *   }
     * })
    **/
    count<T extends ExamCategoryCountArgs>(
      args?: Subset<T, ExamCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExamCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamCategoryAggregateArgs>(args: Subset<T, ExamCategoryAggregateArgs>): Prisma.PrismaPromise<GetExamCategoryAggregateType<T>>

    /**
     * Group by ExamCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ExamCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExamCategory model
   */
  readonly fields: ExamCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExamCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    exams<T extends ExamCategory$examsArgs<ExtArgs> = {}>(args?: Subset<T, ExamCategory$examsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    questions<T extends ExamCategory$questionsArgs<ExtArgs> = {}>(args?: Subset<T, ExamCategory$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends ExamCategory$usersArgs<ExtArgs> = {}>(args?: Subset<T, ExamCategory$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamCategoryUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userPerformances<T extends ExamCategory$userPerformancesArgs<ExtArgs> = {}>(args?: Subset<T, ExamCategory$userPerformancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPerformancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExamCategory model
   */
  interface ExamCategoryFieldRefs {
    readonly id: FieldRef<"ExamCategory", 'String'>
    readonly name: FieldRef<"ExamCategory", 'String'>
    readonly description: FieldRef<"ExamCategory", 'String'>
    readonly icon: FieldRef<"ExamCategory", 'String'>
    readonly color: FieldRef<"ExamCategory", 'String'>
    readonly isActive: FieldRef<"ExamCategory", 'Boolean'>
    readonly sortOrder: FieldRef<"ExamCategory", 'Int'>
    readonly createdAt: FieldRef<"ExamCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"ExamCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExamCategory findUnique
   */
  export type ExamCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamCategory
     */
    select?: ExamCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamCategory
     */
    omit?: ExamCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExamCategory to fetch.
     */
    where: ExamCategoryWhereUniqueInput
  }

  /**
   * ExamCategory findUniqueOrThrow
   */
  export type ExamCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamCategory
     */
    select?: ExamCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamCategory
     */
    omit?: ExamCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExamCategory to fetch.
     */
    where: ExamCategoryWhereUniqueInput
  }

  /**
   * ExamCategory findFirst
   */
  export type ExamCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamCategory
     */
    select?: ExamCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamCategory
     */
    omit?: ExamCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExamCategory to fetch.
     */
    where?: ExamCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamCategories to fetch.
     */
    orderBy?: ExamCategoryOrderByWithRelationInput | ExamCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamCategories.
     */
    cursor?: ExamCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamCategories.
     */
    distinct?: ExamCategoryScalarFieldEnum | ExamCategoryScalarFieldEnum[]
  }

  /**
   * ExamCategory findFirstOrThrow
   */
  export type ExamCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamCategory
     */
    select?: ExamCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamCategory
     */
    omit?: ExamCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExamCategory to fetch.
     */
    where?: ExamCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamCategories to fetch.
     */
    orderBy?: ExamCategoryOrderByWithRelationInput | ExamCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamCategories.
     */
    cursor?: ExamCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamCategories.
     */
    distinct?: ExamCategoryScalarFieldEnum | ExamCategoryScalarFieldEnum[]
  }

  /**
   * ExamCategory findMany
   */
  export type ExamCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamCategory
     */
    select?: ExamCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamCategory
     */
    omit?: ExamCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExamCategories to fetch.
     */
    where?: ExamCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamCategories to fetch.
     */
    orderBy?: ExamCategoryOrderByWithRelationInput | ExamCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExamCategories.
     */
    cursor?: ExamCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamCategories.
     */
    skip?: number
    distinct?: ExamCategoryScalarFieldEnum | ExamCategoryScalarFieldEnum[]
  }

  /**
   * ExamCategory create
   */
  export type ExamCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamCategory
     */
    select?: ExamCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamCategory
     */
    omit?: ExamCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ExamCategory.
     */
    data: XOR<ExamCategoryCreateInput, ExamCategoryUncheckedCreateInput>
  }

  /**
   * ExamCategory createMany
   */
  export type ExamCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExamCategories.
     */
    data: ExamCategoryCreateManyInput | ExamCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExamCategory createManyAndReturn
   */
  export type ExamCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamCategory
     */
    select?: ExamCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExamCategory
     */
    omit?: ExamCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ExamCategories.
     */
    data: ExamCategoryCreateManyInput | ExamCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExamCategory update
   */
  export type ExamCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamCategory
     */
    select?: ExamCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamCategory
     */
    omit?: ExamCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ExamCategory.
     */
    data: XOR<ExamCategoryUpdateInput, ExamCategoryUncheckedUpdateInput>
    /**
     * Choose, which ExamCategory to update.
     */
    where: ExamCategoryWhereUniqueInput
  }

  /**
   * ExamCategory updateMany
   */
  export type ExamCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExamCategories.
     */
    data: XOR<ExamCategoryUpdateManyMutationInput, ExamCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ExamCategories to update
     */
    where?: ExamCategoryWhereInput
    /**
     * Limit how many ExamCategories to update.
     */
    limit?: number
  }

  /**
   * ExamCategory updateManyAndReturn
   */
  export type ExamCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamCategory
     */
    select?: ExamCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExamCategory
     */
    omit?: ExamCategoryOmit<ExtArgs> | null
    /**
     * The data used to update ExamCategories.
     */
    data: XOR<ExamCategoryUpdateManyMutationInput, ExamCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ExamCategories to update
     */
    where?: ExamCategoryWhereInput
    /**
     * Limit how many ExamCategories to update.
     */
    limit?: number
  }

  /**
   * ExamCategory upsert
   */
  export type ExamCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamCategory
     */
    select?: ExamCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamCategory
     */
    omit?: ExamCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ExamCategory to update in case it exists.
     */
    where: ExamCategoryWhereUniqueInput
    /**
     * In case the ExamCategory found by the `where` argument doesn't exist, create a new ExamCategory with this data.
     */
    create: XOR<ExamCategoryCreateInput, ExamCategoryUncheckedCreateInput>
    /**
     * In case the ExamCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamCategoryUpdateInput, ExamCategoryUncheckedUpdateInput>
  }

  /**
   * ExamCategory delete
   */
  export type ExamCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamCategory
     */
    select?: ExamCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamCategory
     */
    omit?: ExamCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamCategoryInclude<ExtArgs> | null
    /**
     * Filter which ExamCategory to delete.
     */
    where: ExamCategoryWhereUniqueInput
  }

  /**
   * ExamCategory deleteMany
   */
  export type ExamCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamCategories to delete
     */
    where?: ExamCategoryWhereInput
    /**
     * Limit how many ExamCategories to delete.
     */
    limit?: number
  }

  /**
   * ExamCategory.exams
   */
  export type ExamCategory$examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    cursor?: ExamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * ExamCategory.questions
   */
  export type ExamCategory$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    where?: QuestionWhereInput
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    cursor?: QuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * ExamCategory.users
   */
  export type ExamCategory$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamCategoryUser
     */
    select?: ExamCategoryUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamCategoryUser
     */
    omit?: ExamCategoryUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamCategoryUserInclude<ExtArgs> | null
    where?: ExamCategoryUserWhereInput
    orderBy?: ExamCategoryUserOrderByWithRelationInput | ExamCategoryUserOrderByWithRelationInput[]
    cursor?: ExamCategoryUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamCategoryUserScalarFieldEnum | ExamCategoryUserScalarFieldEnum[]
  }

  /**
   * ExamCategory.userPerformances
   */
  export type ExamCategory$userPerformancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPerformance
     */
    select?: UserPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPerformance
     */
    omit?: UserPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPerformanceInclude<ExtArgs> | null
    where?: UserPerformanceWhereInput
    orderBy?: UserPerformanceOrderByWithRelationInput | UserPerformanceOrderByWithRelationInput[]
    cursor?: UserPerformanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPerformanceScalarFieldEnum | UserPerformanceScalarFieldEnum[]
  }

  /**
   * ExamCategory without action
   */
  export type ExamCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamCategory
     */
    select?: ExamCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamCategory
     */
    omit?: ExamCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Question
   */

  export type AggregateQuestion = {
    _count: QuestionCountAggregateOutputType | null
    _avg: QuestionAvgAggregateOutputType | null
    _sum: QuestionSumAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  export type QuestionAvgAggregateOutputType = {
    marks: number | null
    timeLimit: number | null
    usageCount: number | null
    correctAnswerRate: number | null
    averageTime: number | null
  }

  export type QuestionSumAggregateOutputType = {
    marks: number | null
    timeLimit: number | null
    usageCount: number | null
    correctAnswerRate: number | null
    averageTime: number | null
  }

  export type QuestionMinAggregateOutputType = {
    id: string | null
    text: string | null
    type: $Enums.QuestionType | null
    difficulty: $Enums.QuestionDifficulty | null
    examCategoryId: string | null
    marks: number | null
    timeLimit: number | null
    isActive: boolean | null
    isPublic: boolean | null
    createdBy: string | null
    approvedBy: string | null
    approvedAt: Date | null
    usageCount: number | null
    correctAnswerRate: number | null
    averageTime: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionMaxAggregateOutputType = {
    id: string | null
    text: string | null
    type: $Enums.QuestionType | null
    difficulty: $Enums.QuestionDifficulty | null
    examCategoryId: string | null
    marks: number | null
    timeLimit: number | null
    isActive: boolean | null
    isPublic: boolean | null
    createdBy: string | null
    approvedBy: string | null
    approvedAt: Date | null
    usageCount: number | null
    correctAnswerRate: number | null
    averageTime: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionCountAggregateOutputType = {
    id: number
    text: number
    type: number
    difficulty: number
    examCategoryId: number
    marks: number
    timeLimit: number
    isActive: number
    isPublic: number
    createdBy: number
    approvedBy: number
    approvedAt: number
    usageCount: number
    correctAnswerRate: number
    averageTime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuestionAvgAggregateInputType = {
    marks?: true
    timeLimit?: true
    usageCount?: true
    correctAnswerRate?: true
    averageTime?: true
  }

  export type QuestionSumAggregateInputType = {
    marks?: true
    timeLimit?: true
    usageCount?: true
    correctAnswerRate?: true
    averageTime?: true
  }

  export type QuestionMinAggregateInputType = {
    id?: true
    text?: true
    type?: true
    difficulty?: true
    examCategoryId?: true
    marks?: true
    timeLimit?: true
    isActive?: true
    isPublic?: true
    createdBy?: true
    approvedBy?: true
    approvedAt?: true
    usageCount?: true
    correctAnswerRate?: true
    averageTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionMaxAggregateInputType = {
    id?: true
    text?: true
    type?: true
    difficulty?: true
    examCategoryId?: true
    marks?: true
    timeLimit?: true
    isActive?: true
    isPublic?: true
    createdBy?: true
    approvedBy?: true
    approvedAt?: true
    usageCount?: true
    correctAnswerRate?: true
    averageTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionCountAggregateInputType = {
    id?: true
    text?: true
    type?: true
    difficulty?: true
    examCategoryId?: true
    marks?: true
    timeLimit?: true
    isActive?: true
    isPublic?: true
    createdBy?: true
    approvedBy?: true
    approvedAt?: true
    usageCount?: true
    correctAnswerRate?: true
    averageTime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Question to aggregate.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Questions
    **/
    _count?: true | QuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionMaxAggregateInputType
  }

  export type GetQuestionAggregateType<T extends QuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestion[P]>
      : GetScalarType<T[P], AggregateQuestion[P]>
  }




  export type QuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionWhereInput
    orderBy?: QuestionOrderByWithAggregationInput | QuestionOrderByWithAggregationInput[]
    by: QuestionScalarFieldEnum[] | QuestionScalarFieldEnum
    having?: QuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionCountAggregateInputType | true
    _avg?: QuestionAvgAggregateInputType
    _sum?: QuestionSumAggregateInputType
    _min?: QuestionMinAggregateInputType
    _max?: QuestionMaxAggregateInputType
  }

  export type QuestionGroupByOutputType = {
    id: string
    text: string
    type: $Enums.QuestionType
    difficulty: $Enums.QuestionDifficulty
    examCategoryId: string
    marks: number
    timeLimit: number | null
    isActive: boolean
    isPublic: boolean
    createdBy: string
    approvedBy: string | null
    approvedAt: Date | null
    usageCount: number
    correctAnswerRate: number | null
    averageTime: number | null
    createdAt: Date
    updatedAt: Date
    _count: QuestionCountAggregateOutputType | null
    _avg: QuestionAvgAggregateOutputType | null
    _sum: QuestionSumAggregateOutputType | null
    _min: QuestionMinAggregateOutputType | null
    _max: QuestionMaxAggregateOutputType | null
  }

  type GetQuestionGroupByPayload<T extends QuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionGroupByOutputType[P]>
        }
      >
    >


  export type QuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    type?: boolean
    difficulty?: boolean
    examCategoryId?: boolean
    marks?: boolean
    timeLimit?: boolean
    isActive?: boolean
    isPublic?: boolean
    createdBy?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    usageCount?: boolean
    correctAnswerRate?: boolean
    averageTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    examCategory?: boolean | ExamCategoryDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | Question$approverArgs<ExtArgs>
    options?: boolean | Question$optionsArgs<ExtArgs>
    images?: boolean | Question$imagesArgs<ExtArgs>
    tags?: boolean | Question$tagsArgs<ExtArgs>
    examQuestions?: boolean | Question$examQuestionsArgs<ExtArgs>
    responses?: boolean | Question$responsesArgs<ExtArgs>
    scores?: boolean | Question$scoresArgs<ExtArgs>
    _count?: boolean | QuestionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>

  export type QuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    type?: boolean
    difficulty?: boolean
    examCategoryId?: boolean
    marks?: boolean
    timeLimit?: boolean
    isActive?: boolean
    isPublic?: boolean
    createdBy?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    usageCount?: boolean
    correctAnswerRate?: boolean
    averageTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    examCategory?: boolean | ExamCategoryDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | Question$approverArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>

  export type QuestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    type?: boolean
    difficulty?: boolean
    examCategoryId?: boolean
    marks?: boolean
    timeLimit?: boolean
    isActive?: boolean
    isPublic?: boolean
    createdBy?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    usageCount?: boolean
    correctAnswerRate?: boolean
    averageTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    examCategory?: boolean | ExamCategoryDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | Question$approverArgs<ExtArgs>
  }, ExtArgs["result"]["question"]>

  export type QuestionSelectScalar = {
    id?: boolean
    text?: boolean
    type?: boolean
    difficulty?: boolean
    examCategoryId?: boolean
    marks?: boolean
    timeLimit?: boolean
    isActive?: boolean
    isPublic?: boolean
    createdBy?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    usageCount?: boolean
    correctAnswerRate?: boolean
    averageTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "text" | "type" | "difficulty" | "examCategoryId" | "marks" | "timeLimit" | "isActive" | "isPublic" | "createdBy" | "approvedBy" | "approvedAt" | "usageCount" | "correctAnswerRate" | "averageTime" | "createdAt" | "updatedAt", ExtArgs["result"]["question"]>
  export type QuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examCategory?: boolean | ExamCategoryDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | Question$approverArgs<ExtArgs>
    options?: boolean | Question$optionsArgs<ExtArgs>
    images?: boolean | Question$imagesArgs<ExtArgs>
    tags?: boolean | Question$tagsArgs<ExtArgs>
    examQuestions?: boolean | Question$examQuestionsArgs<ExtArgs>
    responses?: boolean | Question$responsesArgs<ExtArgs>
    scores?: boolean | Question$scoresArgs<ExtArgs>
    _count?: boolean | QuestionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examCategory?: boolean | ExamCategoryDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | Question$approverArgs<ExtArgs>
  }
  export type QuestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examCategory?: boolean | ExamCategoryDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | Question$approverArgs<ExtArgs>
  }

  export type $QuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Question"
    objects: {
      examCategory: Prisma.$ExamCategoryPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
      approver: Prisma.$UserPayload<ExtArgs> | null
      options: Prisma.$QuestionOptionPayload<ExtArgs>[]
      images: Prisma.$QuestionImagePayload<ExtArgs>[]
      tags: Prisma.$QuestionTagPayload<ExtArgs>[]
      examQuestions: Prisma.$ExamQuestionPayload<ExtArgs>[]
      responses: Prisma.$QuestionResponsePayload<ExtArgs>[]
      scores: Prisma.$QuestionScorePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      text: string
      type: $Enums.QuestionType
      difficulty: $Enums.QuestionDifficulty
      examCategoryId: string
      marks: number
      timeLimit: number | null
      isActive: boolean
      isPublic: boolean
      createdBy: string
      approvedBy: string | null
      approvedAt: Date | null
      usageCount: number
      correctAnswerRate: number | null
      averageTime: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["question"]>
    composites: {}
  }

  type QuestionGetPayload<S extends boolean | null | undefined | QuestionDefaultArgs> = $Result.GetResult<Prisma.$QuestionPayload, S>

  type QuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuestionCountAggregateInputType | true
    }

  export interface QuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Question'], meta: { name: 'Question' } }
    /**
     * Find zero or one Question that matches the filter.
     * @param {QuestionFindUniqueArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionFindUniqueArgs>(args: SelectSubset<T, QuestionFindUniqueArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Question that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuestionFindUniqueOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Question that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindFirstArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionFindFirstArgs>(args?: SelectSubset<T, QuestionFindFirstArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Question that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindFirstOrThrowArgs} args - Arguments to find a Question
     * @example
     * // Get one Question
     * const question = await prisma.question.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questions
     * const questions = await prisma.question.findMany()
     * 
     * // Get first 10 Questions
     * const questions = await prisma.question.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionWithIdOnly = await prisma.question.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionFindManyArgs>(args?: SelectSubset<T, QuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Question.
     * @param {QuestionCreateArgs} args - Arguments to create a Question.
     * @example
     * // Create one Question
     * const Question = await prisma.question.create({
     *   data: {
     *     // ... data to create a Question
     *   }
     * })
     * 
     */
    create<T extends QuestionCreateArgs>(args: SelectSubset<T, QuestionCreateArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Questions.
     * @param {QuestionCreateManyArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const question = await prisma.question.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionCreateManyArgs>(args?: SelectSubset<T, QuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Questions and returns the data saved in the database.
     * @param {QuestionCreateManyAndReturnArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const question = await prisma.question.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Questions and only return the `id`
     * const questionWithIdOnly = await prisma.question.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Question.
     * @param {QuestionDeleteArgs} args - Arguments to delete one Question.
     * @example
     * // Delete one Question
     * const Question = await prisma.question.delete({
     *   where: {
     *     // ... filter to delete one Question
     *   }
     * })
     * 
     */
    delete<T extends QuestionDeleteArgs>(args: SelectSubset<T, QuestionDeleteArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Question.
     * @param {QuestionUpdateArgs} args - Arguments to update one Question.
     * @example
     * // Update one Question
     * const question = await prisma.question.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionUpdateArgs>(args: SelectSubset<T, QuestionUpdateArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Questions.
     * @param {QuestionDeleteManyArgs} args - Arguments to filter Questions to delete.
     * @example
     * // Delete a few Questions
     * const { count } = await prisma.question.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionDeleteManyArgs>(args?: SelectSubset<T, QuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questions
     * const question = await prisma.question.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionUpdateManyArgs>(args: SelectSubset<T, QuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions and returns the data updated in the database.
     * @param {QuestionUpdateManyAndReturnArgs} args - Arguments to update many Questions.
     * @example
     * // Update many Questions
     * const question = await prisma.question.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Questions and only return the `id`
     * const questionWithIdOnly = await prisma.question.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuestionUpdateManyAndReturnArgs>(args: SelectSubset<T, QuestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Question.
     * @param {QuestionUpsertArgs} args - Arguments to update or create a Question.
     * @example
     * // Update or create a Question
     * const question = await prisma.question.upsert({
     *   create: {
     *     // ... data to create a Question
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Question we want to update
     *   }
     * })
     */
    upsert<T extends QuestionUpsertArgs>(args: SelectSubset<T, QuestionUpsertArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionCountArgs} args - Arguments to filter Questions to count.
     * @example
     * // Count the number of Questions
     * const count = await prisma.question.count({
     *   where: {
     *     // ... the filter for the Questions we want to count
     *   }
     * })
    **/
    count<T extends QuestionCountArgs>(
      args?: Subset<T, QuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionAggregateArgs>(args: Subset<T, QuestionAggregateArgs>): Prisma.PrismaPromise<GetQuestionAggregateType<T>>

    /**
     * Group by Question.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionGroupByArgs['orderBy'] }
        : { orderBy?: QuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Question model
   */
  readonly fields: QuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Question.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    examCategory<T extends ExamCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamCategoryDefaultArgs<ExtArgs>>): Prisma__ExamCategoryClient<$Result.GetResult<Prisma.$ExamCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    approver<T extends Question$approverArgs<ExtArgs> = {}>(args?: Subset<T, Question$approverArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    options<T extends Question$optionsArgs<ExtArgs> = {}>(args?: Subset<T, Question$optionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    images<T extends Question$imagesArgs<ExtArgs> = {}>(args?: Subset<T, Question$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Question$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Question$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    examQuestions<T extends Question$examQuestionsArgs<ExtArgs> = {}>(args?: Subset<T, Question$examQuestionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    responses<T extends Question$responsesArgs<ExtArgs> = {}>(args?: Subset<T, Question$responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    scores<T extends Question$scoresArgs<ExtArgs> = {}>(args?: Subset<T, Question$scoresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionScorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Question model
   */
  interface QuestionFieldRefs {
    readonly id: FieldRef<"Question", 'String'>
    readonly text: FieldRef<"Question", 'String'>
    readonly type: FieldRef<"Question", 'QuestionType'>
    readonly difficulty: FieldRef<"Question", 'QuestionDifficulty'>
    readonly examCategoryId: FieldRef<"Question", 'String'>
    readonly marks: FieldRef<"Question", 'Int'>
    readonly timeLimit: FieldRef<"Question", 'Int'>
    readonly isActive: FieldRef<"Question", 'Boolean'>
    readonly isPublic: FieldRef<"Question", 'Boolean'>
    readonly createdBy: FieldRef<"Question", 'String'>
    readonly approvedBy: FieldRef<"Question", 'String'>
    readonly approvedAt: FieldRef<"Question", 'DateTime'>
    readonly usageCount: FieldRef<"Question", 'Int'>
    readonly correctAnswerRate: FieldRef<"Question", 'Float'>
    readonly averageTime: FieldRef<"Question", 'Int'>
    readonly createdAt: FieldRef<"Question", 'DateTime'>
    readonly updatedAt: FieldRef<"Question", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Question findUnique
   */
  export type QuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question findUniqueOrThrow
   */
  export type QuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question findFirst
   */
  export type QuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     */
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question findFirstOrThrow
   */
  export type QuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Question to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Questions.
     */
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question findMany
   */
  export type QuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter, which Questions to fetch.
     */
    where?: QuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Questions to fetch.
     */
    orderBy?: QuestionOrderByWithRelationInput | QuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Questions.
     */
    cursor?: QuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Questions.
     */
    skip?: number
    distinct?: QuestionScalarFieldEnum | QuestionScalarFieldEnum[]
  }

  /**
   * Question create
   */
  export type QuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a Question.
     */
    data: XOR<QuestionCreateInput, QuestionUncheckedCreateInput>
  }

  /**
   * Question createMany
   */
  export type QuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Questions.
     */
    data: QuestionCreateManyInput | QuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Question createManyAndReturn
   */
  export type QuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * The data used to create many Questions.
     */
    data: QuestionCreateManyInput | QuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Question update
   */
  export type QuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a Question.
     */
    data: XOR<QuestionUpdateInput, QuestionUncheckedUpdateInput>
    /**
     * Choose, which Question to update.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question updateMany
   */
  export type QuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Questions.
     */
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyInput>
    /**
     * Filter which Questions to update
     */
    where?: QuestionWhereInput
    /**
     * Limit how many Questions to update.
     */
    limit?: number
  }

  /**
   * Question updateManyAndReturn
   */
  export type QuestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * The data used to update Questions.
     */
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyInput>
    /**
     * Filter which Questions to update
     */
    where?: QuestionWhereInput
    /**
     * Limit how many Questions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Question upsert
   */
  export type QuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the Question to update in case it exists.
     */
    where: QuestionWhereUniqueInput
    /**
     * In case the Question found by the `where` argument doesn't exist, create a new Question with this data.
     */
    create: XOR<QuestionCreateInput, QuestionUncheckedCreateInput>
    /**
     * In case the Question was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionUpdateInput, QuestionUncheckedUpdateInput>
  }

  /**
   * Question delete
   */
  export type QuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
    /**
     * Filter which Question to delete.
     */
    where: QuestionWhereUniqueInput
  }

  /**
   * Question deleteMany
   */
  export type QuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Questions to delete
     */
    where?: QuestionWhereInput
    /**
     * Limit how many Questions to delete.
     */
    limit?: number
  }

  /**
   * Question.approver
   */
  export type Question$approverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Question.options
   */
  export type Question$optionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionOption
     */
    select?: QuestionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionOption
     */
    omit?: QuestionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionOptionInclude<ExtArgs> | null
    where?: QuestionOptionWhereInput
    orderBy?: QuestionOptionOrderByWithRelationInput | QuestionOptionOrderByWithRelationInput[]
    cursor?: QuestionOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionOptionScalarFieldEnum | QuestionOptionScalarFieldEnum[]
  }

  /**
   * Question.images
   */
  export type Question$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionImage
     */
    select?: QuestionImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionImage
     */
    omit?: QuestionImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionImageInclude<ExtArgs> | null
    where?: QuestionImageWhereInput
    orderBy?: QuestionImageOrderByWithRelationInput | QuestionImageOrderByWithRelationInput[]
    cursor?: QuestionImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionImageScalarFieldEnum | QuestionImageScalarFieldEnum[]
  }

  /**
   * Question.tags
   */
  export type Question$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionTag
     */
    select?: QuestionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionTag
     */
    omit?: QuestionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionTagInclude<ExtArgs> | null
    where?: QuestionTagWhereInput
    orderBy?: QuestionTagOrderByWithRelationInput | QuestionTagOrderByWithRelationInput[]
    cursor?: QuestionTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionTagScalarFieldEnum | QuestionTagScalarFieldEnum[]
  }

  /**
   * Question.examQuestions
   */
  export type Question$examQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamQuestion
     */
    select?: ExamQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamQuestion
     */
    omit?: ExamQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamQuestionInclude<ExtArgs> | null
    where?: ExamQuestionWhereInput
    orderBy?: ExamQuestionOrderByWithRelationInput | ExamQuestionOrderByWithRelationInput[]
    cursor?: ExamQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamQuestionScalarFieldEnum | ExamQuestionScalarFieldEnum[]
  }

  /**
   * Question.responses
   */
  export type Question$responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionResponse
     */
    select?: QuestionResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionResponse
     */
    omit?: QuestionResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionResponseInclude<ExtArgs> | null
    where?: QuestionResponseWhereInput
    orderBy?: QuestionResponseOrderByWithRelationInput | QuestionResponseOrderByWithRelationInput[]
    cursor?: QuestionResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionResponseScalarFieldEnum | QuestionResponseScalarFieldEnum[]
  }

  /**
   * Question.scores
   */
  export type Question$scoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionScore
     */
    select?: QuestionScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionScore
     */
    omit?: QuestionScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionScoreInclude<ExtArgs> | null
    where?: QuestionScoreWhereInput
    orderBy?: QuestionScoreOrderByWithRelationInput | QuestionScoreOrderByWithRelationInput[]
    cursor?: QuestionScoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionScoreScalarFieldEnum | QuestionScoreScalarFieldEnum[]
  }

  /**
   * Question without action
   */
  export type QuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Question
     */
    select?: QuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Question
     */
    omit?: QuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionInclude<ExtArgs> | null
  }


  /**
   * Model QuestionOption
   */

  export type AggregateQuestionOption = {
    _count: QuestionOptionCountAggregateOutputType | null
    _avg: QuestionOptionAvgAggregateOutputType | null
    _sum: QuestionOptionSumAggregateOutputType | null
    _min: QuestionOptionMinAggregateOutputType | null
    _max: QuestionOptionMaxAggregateOutputType | null
  }

  export type QuestionOptionAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type QuestionOptionSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type QuestionOptionMinAggregateOutputType = {
    id: string | null
    questionId: string | null
    text: string | null
    isCorrect: boolean | null
    sortOrder: number | null
    createdAt: Date | null
  }

  export type QuestionOptionMaxAggregateOutputType = {
    id: string | null
    questionId: string | null
    text: string | null
    isCorrect: boolean | null
    sortOrder: number | null
    createdAt: Date | null
  }

  export type QuestionOptionCountAggregateOutputType = {
    id: number
    questionId: number
    text: number
    isCorrect: number
    sortOrder: number
    createdAt: number
    _all: number
  }


  export type QuestionOptionAvgAggregateInputType = {
    sortOrder?: true
  }

  export type QuestionOptionSumAggregateInputType = {
    sortOrder?: true
  }

  export type QuestionOptionMinAggregateInputType = {
    id?: true
    questionId?: true
    text?: true
    isCorrect?: true
    sortOrder?: true
    createdAt?: true
  }

  export type QuestionOptionMaxAggregateInputType = {
    id?: true
    questionId?: true
    text?: true
    isCorrect?: true
    sortOrder?: true
    createdAt?: true
  }

  export type QuestionOptionCountAggregateInputType = {
    id?: true
    questionId?: true
    text?: true
    isCorrect?: true
    sortOrder?: true
    createdAt?: true
    _all?: true
  }

  export type QuestionOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionOption to aggregate.
     */
    where?: QuestionOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionOptions to fetch.
     */
    orderBy?: QuestionOptionOrderByWithRelationInput | QuestionOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestionOptions
    **/
    _count?: true | QuestionOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionOptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionOptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionOptionMaxAggregateInputType
  }

  export type GetQuestionOptionAggregateType<T extends QuestionOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionOption[P]>
      : GetScalarType<T[P], AggregateQuestionOption[P]>
  }




  export type QuestionOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionOptionWhereInput
    orderBy?: QuestionOptionOrderByWithAggregationInput | QuestionOptionOrderByWithAggregationInput[]
    by: QuestionOptionScalarFieldEnum[] | QuestionOptionScalarFieldEnum
    having?: QuestionOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionOptionCountAggregateInputType | true
    _avg?: QuestionOptionAvgAggregateInputType
    _sum?: QuestionOptionSumAggregateInputType
    _min?: QuestionOptionMinAggregateInputType
    _max?: QuestionOptionMaxAggregateInputType
  }

  export type QuestionOptionGroupByOutputType = {
    id: string
    questionId: string
    text: string
    isCorrect: boolean
    sortOrder: number
    createdAt: Date
    _count: QuestionOptionCountAggregateOutputType | null
    _avg: QuestionOptionAvgAggregateOutputType | null
    _sum: QuestionOptionSumAggregateOutputType | null
    _min: QuestionOptionMinAggregateOutputType | null
    _max: QuestionOptionMaxAggregateOutputType | null
  }

  type GetQuestionOptionGroupByPayload<T extends QuestionOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionOptionGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionOptionGroupByOutputType[P]>
        }
      >
    >


  export type QuestionOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    text?: boolean
    isCorrect?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionOption"]>

  export type QuestionOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    text?: boolean
    isCorrect?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionOption"]>

  export type QuestionOptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    text?: boolean
    isCorrect?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionOption"]>

  export type QuestionOptionSelectScalar = {
    id?: boolean
    questionId?: boolean
    text?: boolean
    isCorrect?: boolean
    sortOrder?: boolean
    createdAt?: boolean
  }

  export type QuestionOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "questionId" | "text" | "isCorrect" | "sortOrder" | "createdAt", ExtArgs["result"]["questionOption"]>
  export type QuestionOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }
  export type QuestionOptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }
  export type QuestionOptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }

  export type $QuestionOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuestionOption"
    objects: {
      question: Prisma.$QuestionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      questionId: string
      text: string
      isCorrect: boolean
      sortOrder: number
      createdAt: Date
    }, ExtArgs["result"]["questionOption"]>
    composites: {}
  }

  type QuestionOptionGetPayload<S extends boolean | null | undefined | QuestionOptionDefaultArgs> = $Result.GetResult<Prisma.$QuestionOptionPayload, S>

  type QuestionOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuestionOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuestionOptionCountAggregateInputType | true
    }

  export interface QuestionOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuestionOption'], meta: { name: 'QuestionOption' } }
    /**
     * Find zero or one QuestionOption that matches the filter.
     * @param {QuestionOptionFindUniqueArgs} args - Arguments to find a QuestionOption
     * @example
     * // Get one QuestionOption
     * const questionOption = await prisma.questionOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionOptionFindUniqueArgs>(args: SelectSubset<T, QuestionOptionFindUniqueArgs<ExtArgs>>): Prisma__QuestionOptionClient<$Result.GetResult<Prisma.$QuestionOptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuestionOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuestionOptionFindUniqueOrThrowArgs} args - Arguments to find a QuestionOption
     * @example
     * // Get one QuestionOption
     * const questionOption = await prisma.questionOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionOptionClient<$Result.GetResult<Prisma.$QuestionOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuestionOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionOptionFindFirstArgs} args - Arguments to find a QuestionOption
     * @example
     * // Get one QuestionOption
     * const questionOption = await prisma.questionOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionOptionFindFirstArgs>(args?: SelectSubset<T, QuestionOptionFindFirstArgs<ExtArgs>>): Prisma__QuestionOptionClient<$Result.GetResult<Prisma.$QuestionOptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuestionOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionOptionFindFirstOrThrowArgs} args - Arguments to find a QuestionOption
     * @example
     * // Get one QuestionOption
     * const questionOption = await prisma.questionOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionOptionClient<$Result.GetResult<Prisma.$QuestionOptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuestionOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionOptions
     * const questionOptions = await prisma.questionOption.findMany()
     * 
     * // Get first 10 QuestionOptions
     * const questionOptions = await prisma.questionOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionOptionWithIdOnly = await prisma.questionOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionOptionFindManyArgs>(args?: SelectSubset<T, QuestionOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuestionOption.
     * @param {QuestionOptionCreateArgs} args - Arguments to create a QuestionOption.
     * @example
     * // Create one QuestionOption
     * const QuestionOption = await prisma.questionOption.create({
     *   data: {
     *     // ... data to create a QuestionOption
     *   }
     * })
     * 
     */
    create<T extends QuestionOptionCreateArgs>(args: SelectSubset<T, QuestionOptionCreateArgs<ExtArgs>>): Prisma__QuestionOptionClient<$Result.GetResult<Prisma.$QuestionOptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuestionOptions.
     * @param {QuestionOptionCreateManyArgs} args - Arguments to create many QuestionOptions.
     * @example
     * // Create many QuestionOptions
     * const questionOption = await prisma.questionOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionOptionCreateManyArgs>(args?: SelectSubset<T, QuestionOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuestionOptions and returns the data saved in the database.
     * @param {QuestionOptionCreateManyAndReturnArgs} args - Arguments to create many QuestionOptions.
     * @example
     * // Create many QuestionOptions
     * const questionOption = await prisma.questionOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuestionOptions and only return the `id`
     * const questionOptionWithIdOnly = await prisma.questionOption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestionOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestionOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionOptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuestionOption.
     * @param {QuestionOptionDeleteArgs} args - Arguments to delete one QuestionOption.
     * @example
     * // Delete one QuestionOption
     * const QuestionOption = await prisma.questionOption.delete({
     *   where: {
     *     // ... filter to delete one QuestionOption
     *   }
     * })
     * 
     */
    delete<T extends QuestionOptionDeleteArgs>(args: SelectSubset<T, QuestionOptionDeleteArgs<ExtArgs>>): Prisma__QuestionOptionClient<$Result.GetResult<Prisma.$QuestionOptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuestionOption.
     * @param {QuestionOptionUpdateArgs} args - Arguments to update one QuestionOption.
     * @example
     * // Update one QuestionOption
     * const questionOption = await prisma.questionOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionOptionUpdateArgs>(args: SelectSubset<T, QuestionOptionUpdateArgs<ExtArgs>>): Prisma__QuestionOptionClient<$Result.GetResult<Prisma.$QuestionOptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuestionOptions.
     * @param {QuestionOptionDeleteManyArgs} args - Arguments to filter QuestionOptions to delete.
     * @example
     * // Delete a few QuestionOptions
     * const { count } = await prisma.questionOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionOptionDeleteManyArgs>(args?: SelectSubset<T, QuestionOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionOptions
     * const questionOption = await prisma.questionOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionOptionUpdateManyArgs>(args: SelectSubset<T, QuestionOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionOptions and returns the data updated in the database.
     * @param {QuestionOptionUpdateManyAndReturnArgs} args - Arguments to update many QuestionOptions.
     * @example
     * // Update many QuestionOptions
     * const questionOption = await prisma.questionOption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuestionOptions and only return the `id`
     * const questionOptionWithIdOnly = await prisma.questionOption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuestionOptionUpdateManyAndReturnArgs>(args: SelectSubset<T, QuestionOptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionOptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuestionOption.
     * @param {QuestionOptionUpsertArgs} args - Arguments to update or create a QuestionOption.
     * @example
     * // Update or create a QuestionOption
     * const questionOption = await prisma.questionOption.upsert({
     *   create: {
     *     // ... data to create a QuestionOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionOption we want to update
     *   }
     * })
     */
    upsert<T extends QuestionOptionUpsertArgs>(args: SelectSubset<T, QuestionOptionUpsertArgs<ExtArgs>>): Prisma__QuestionOptionClient<$Result.GetResult<Prisma.$QuestionOptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuestionOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionOptionCountArgs} args - Arguments to filter QuestionOptions to count.
     * @example
     * // Count the number of QuestionOptions
     * const count = await prisma.questionOption.count({
     *   where: {
     *     // ... the filter for the QuestionOptions we want to count
     *   }
     * })
    **/
    count<T extends QuestionOptionCountArgs>(
      args?: Subset<T, QuestionOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionOptionAggregateArgs>(args: Subset<T, QuestionOptionAggregateArgs>): Prisma.PrismaPromise<GetQuestionOptionAggregateType<T>>

    /**
     * Group by QuestionOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionOptionGroupByArgs['orderBy'] }
        : { orderBy?: QuestionOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuestionOption model
   */
  readonly fields: QuestionOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestionOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    question<T extends QuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuestionDefaultArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuestionOption model
   */
  interface QuestionOptionFieldRefs {
    readonly id: FieldRef<"QuestionOption", 'String'>
    readonly questionId: FieldRef<"QuestionOption", 'String'>
    readonly text: FieldRef<"QuestionOption", 'String'>
    readonly isCorrect: FieldRef<"QuestionOption", 'Boolean'>
    readonly sortOrder: FieldRef<"QuestionOption", 'Int'>
    readonly createdAt: FieldRef<"QuestionOption", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuestionOption findUnique
   */
  export type QuestionOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionOption
     */
    select?: QuestionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionOption
     */
    omit?: QuestionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionOptionInclude<ExtArgs> | null
    /**
     * Filter, which QuestionOption to fetch.
     */
    where: QuestionOptionWhereUniqueInput
  }

  /**
   * QuestionOption findUniqueOrThrow
   */
  export type QuestionOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionOption
     */
    select?: QuestionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionOption
     */
    omit?: QuestionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionOptionInclude<ExtArgs> | null
    /**
     * Filter, which QuestionOption to fetch.
     */
    where: QuestionOptionWhereUniqueInput
  }

  /**
   * QuestionOption findFirst
   */
  export type QuestionOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionOption
     */
    select?: QuestionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionOption
     */
    omit?: QuestionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionOptionInclude<ExtArgs> | null
    /**
     * Filter, which QuestionOption to fetch.
     */
    where?: QuestionOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionOptions to fetch.
     */
    orderBy?: QuestionOptionOrderByWithRelationInput | QuestionOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionOptions.
     */
    cursor?: QuestionOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionOptions.
     */
    distinct?: QuestionOptionScalarFieldEnum | QuestionOptionScalarFieldEnum[]
  }

  /**
   * QuestionOption findFirstOrThrow
   */
  export type QuestionOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionOption
     */
    select?: QuestionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionOption
     */
    omit?: QuestionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionOptionInclude<ExtArgs> | null
    /**
     * Filter, which QuestionOption to fetch.
     */
    where?: QuestionOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionOptions to fetch.
     */
    orderBy?: QuestionOptionOrderByWithRelationInput | QuestionOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionOptions.
     */
    cursor?: QuestionOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionOptions.
     */
    distinct?: QuestionOptionScalarFieldEnum | QuestionOptionScalarFieldEnum[]
  }

  /**
   * QuestionOption findMany
   */
  export type QuestionOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionOption
     */
    select?: QuestionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionOption
     */
    omit?: QuestionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionOptionInclude<ExtArgs> | null
    /**
     * Filter, which QuestionOptions to fetch.
     */
    where?: QuestionOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionOptions to fetch.
     */
    orderBy?: QuestionOptionOrderByWithRelationInput | QuestionOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestionOptions.
     */
    cursor?: QuestionOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionOptions.
     */
    skip?: number
    distinct?: QuestionOptionScalarFieldEnum | QuestionOptionScalarFieldEnum[]
  }

  /**
   * QuestionOption create
   */
  export type QuestionOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionOption
     */
    select?: QuestionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionOption
     */
    omit?: QuestionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a QuestionOption.
     */
    data: XOR<QuestionOptionCreateInput, QuestionOptionUncheckedCreateInput>
  }

  /**
   * QuestionOption createMany
   */
  export type QuestionOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuestionOptions.
     */
    data: QuestionOptionCreateManyInput | QuestionOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuestionOption createManyAndReturn
   */
  export type QuestionOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionOption
     */
    select?: QuestionOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionOption
     */
    omit?: QuestionOptionOmit<ExtArgs> | null
    /**
     * The data used to create many QuestionOptions.
     */
    data: QuestionOptionCreateManyInput | QuestionOptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionOptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuestionOption update
   */
  export type QuestionOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionOption
     */
    select?: QuestionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionOption
     */
    omit?: QuestionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a QuestionOption.
     */
    data: XOR<QuestionOptionUpdateInput, QuestionOptionUncheckedUpdateInput>
    /**
     * Choose, which QuestionOption to update.
     */
    where: QuestionOptionWhereUniqueInput
  }

  /**
   * QuestionOption updateMany
   */
  export type QuestionOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuestionOptions.
     */
    data: XOR<QuestionOptionUpdateManyMutationInput, QuestionOptionUncheckedUpdateManyInput>
    /**
     * Filter which QuestionOptions to update
     */
    where?: QuestionOptionWhereInput
    /**
     * Limit how many QuestionOptions to update.
     */
    limit?: number
  }

  /**
   * QuestionOption updateManyAndReturn
   */
  export type QuestionOptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionOption
     */
    select?: QuestionOptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionOption
     */
    omit?: QuestionOptionOmit<ExtArgs> | null
    /**
     * The data used to update QuestionOptions.
     */
    data: XOR<QuestionOptionUpdateManyMutationInput, QuestionOptionUncheckedUpdateManyInput>
    /**
     * Filter which QuestionOptions to update
     */
    where?: QuestionOptionWhereInput
    /**
     * Limit how many QuestionOptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionOptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuestionOption upsert
   */
  export type QuestionOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionOption
     */
    select?: QuestionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionOption
     */
    omit?: QuestionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the QuestionOption to update in case it exists.
     */
    where: QuestionOptionWhereUniqueInput
    /**
     * In case the QuestionOption found by the `where` argument doesn't exist, create a new QuestionOption with this data.
     */
    create: XOR<QuestionOptionCreateInput, QuestionOptionUncheckedCreateInput>
    /**
     * In case the QuestionOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionOptionUpdateInput, QuestionOptionUncheckedUpdateInput>
  }

  /**
   * QuestionOption delete
   */
  export type QuestionOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionOption
     */
    select?: QuestionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionOption
     */
    omit?: QuestionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionOptionInclude<ExtArgs> | null
    /**
     * Filter which QuestionOption to delete.
     */
    where: QuestionOptionWhereUniqueInput
  }

  /**
   * QuestionOption deleteMany
   */
  export type QuestionOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionOptions to delete
     */
    where?: QuestionOptionWhereInput
    /**
     * Limit how many QuestionOptions to delete.
     */
    limit?: number
  }

  /**
   * QuestionOption without action
   */
  export type QuestionOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionOption
     */
    select?: QuestionOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionOption
     */
    omit?: QuestionOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionOptionInclude<ExtArgs> | null
  }


  /**
   * Model QuestionImage
   */

  export type AggregateQuestionImage = {
    _count: QuestionImageCountAggregateOutputType | null
    _avg: QuestionImageAvgAggregateOutputType | null
    _sum: QuestionImageSumAggregateOutputType | null
    _min: QuestionImageMinAggregateOutputType | null
    _max: QuestionImageMaxAggregateOutputType | null
  }

  export type QuestionImageAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type QuestionImageSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type QuestionImageMinAggregateOutputType = {
    id: string | null
    questionId: string | null
    imageUrl: string | null
    altText: string | null
    sortOrder: number | null
    createdAt: Date | null
  }

  export type QuestionImageMaxAggregateOutputType = {
    id: string | null
    questionId: string | null
    imageUrl: string | null
    altText: string | null
    sortOrder: number | null
    createdAt: Date | null
  }

  export type QuestionImageCountAggregateOutputType = {
    id: number
    questionId: number
    imageUrl: number
    altText: number
    sortOrder: number
    createdAt: number
    _all: number
  }


  export type QuestionImageAvgAggregateInputType = {
    sortOrder?: true
  }

  export type QuestionImageSumAggregateInputType = {
    sortOrder?: true
  }

  export type QuestionImageMinAggregateInputType = {
    id?: true
    questionId?: true
    imageUrl?: true
    altText?: true
    sortOrder?: true
    createdAt?: true
  }

  export type QuestionImageMaxAggregateInputType = {
    id?: true
    questionId?: true
    imageUrl?: true
    altText?: true
    sortOrder?: true
    createdAt?: true
  }

  export type QuestionImageCountAggregateInputType = {
    id?: true
    questionId?: true
    imageUrl?: true
    altText?: true
    sortOrder?: true
    createdAt?: true
    _all?: true
  }

  export type QuestionImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionImage to aggregate.
     */
    where?: QuestionImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionImages to fetch.
     */
    orderBy?: QuestionImageOrderByWithRelationInput | QuestionImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestionImages
    **/
    _count?: true | QuestionImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionImageMaxAggregateInputType
  }

  export type GetQuestionImageAggregateType<T extends QuestionImageAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionImage[P]>
      : GetScalarType<T[P], AggregateQuestionImage[P]>
  }




  export type QuestionImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionImageWhereInput
    orderBy?: QuestionImageOrderByWithAggregationInput | QuestionImageOrderByWithAggregationInput[]
    by: QuestionImageScalarFieldEnum[] | QuestionImageScalarFieldEnum
    having?: QuestionImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionImageCountAggregateInputType | true
    _avg?: QuestionImageAvgAggregateInputType
    _sum?: QuestionImageSumAggregateInputType
    _min?: QuestionImageMinAggregateInputType
    _max?: QuestionImageMaxAggregateInputType
  }

  export type QuestionImageGroupByOutputType = {
    id: string
    questionId: string
    imageUrl: string
    altText: string | null
    sortOrder: number
    createdAt: Date
    _count: QuestionImageCountAggregateOutputType | null
    _avg: QuestionImageAvgAggregateOutputType | null
    _sum: QuestionImageSumAggregateOutputType | null
    _min: QuestionImageMinAggregateOutputType | null
    _max: QuestionImageMaxAggregateOutputType | null
  }

  type GetQuestionImageGroupByPayload<T extends QuestionImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionImageGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionImageGroupByOutputType[P]>
        }
      >
    >


  export type QuestionImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    imageUrl?: boolean
    altText?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionImage"]>

  export type QuestionImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    imageUrl?: boolean
    altText?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionImage"]>

  export type QuestionImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    imageUrl?: boolean
    altText?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionImage"]>

  export type QuestionImageSelectScalar = {
    id?: boolean
    questionId?: boolean
    imageUrl?: boolean
    altText?: boolean
    sortOrder?: boolean
    createdAt?: boolean
  }

  export type QuestionImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "questionId" | "imageUrl" | "altText" | "sortOrder" | "createdAt", ExtArgs["result"]["questionImage"]>
  export type QuestionImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }
  export type QuestionImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }
  export type QuestionImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }

  export type $QuestionImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuestionImage"
    objects: {
      question: Prisma.$QuestionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      questionId: string
      imageUrl: string
      altText: string | null
      sortOrder: number
      createdAt: Date
    }, ExtArgs["result"]["questionImage"]>
    composites: {}
  }

  type QuestionImageGetPayload<S extends boolean | null | undefined | QuestionImageDefaultArgs> = $Result.GetResult<Prisma.$QuestionImagePayload, S>

  type QuestionImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuestionImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuestionImageCountAggregateInputType | true
    }

  export interface QuestionImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuestionImage'], meta: { name: 'QuestionImage' } }
    /**
     * Find zero or one QuestionImage that matches the filter.
     * @param {QuestionImageFindUniqueArgs} args - Arguments to find a QuestionImage
     * @example
     * // Get one QuestionImage
     * const questionImage = await prisma.questionImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionImageFindUniqueArgs>(args: SelectSubset<T, QuestionImageFindUniqueArgs<ExtArgs>>): Prisma__QuestionImageClient<$Result.GetResult<Prisma.$QuestionImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuestionImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuestionImageFindUniqueOrThrowArgs} args - Arguments to find a QuestionImage
     * @example
     * // Get one QuestionImage
     * const questionImage = await prisma.questionImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionImageFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionImageClient<$Result.GetResult<Prisma.$QuestionImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuestionImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionImageFindFirstArgs} args - Arguments to find a QuestionImage
     * @example
     * // Get one QuestionImage
     * const questionImage = await prisma.questionImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionImageFindFirstArgs>(args?: SelectSubset<T, QuestionImageFindFirstArgs<ExtArgs>>): Prisma__QuestionImageClient<$Result.GetResult<Prisma.$QuestionImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuestionImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionImageFindFirstOrThrowArgs} args - Arguments to find a QuestionImage
     * @example
     * // Get one QuestionImage
     * const questionImage = await prisma.questionImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionImageFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionImageClient<$Result.GetResult<Prisma.$QuestionImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuestionImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionImages
     * const questionImages = await prisma.questionImage.findMany()
     * 
     * // Get first 10 QuestionImages
     * const questionImages = await prisma.questionImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionImageWithIdOnly = await prisma.questionImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionImageFindManyArgs>(args?: SelectSubset<T, QuestionImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuestionImage.
     * @param {QuestionImageCreateArgs} args - Arguments to create a QuestionImage.
     * @example
     * // Create one QuestionImage
     * const QuestionImage = await prisma.questionImage.create({
     *   data: {
     *     // ... data to create a QuestionImage
     *   }
     * })
     * 
     */
    create<T extends QuestionImageCreateArgs>(args: SelectSubset<T, QuestionImageCreateArgs<ExtArgs>>): Prisma__QuestionImageClient<$Result.GetResult<Prisma.$QuestionImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuestionImages.
     * @param {QuestionImageCreateManyArgs} args - Arguments to create many QuestionImages.
     * @example
     * // Create many QuestionImages
     * const questionImage = await prisma.questionImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionImageCreateManyArgs>(args?: SelectSubset<T, QuestionImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuestionImages and returns the data saved in the database.
     * @param {QuestionImageCreateManyAndReturnArgs} args - Arguments to create many QuestionImages.
     * @example
     * // Create many QuestionImages
     * const questionImage = await prisma.questionImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuestionImages and only return the `id`
     * const questionImageWithIdOnly = await prisma.questionImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestionImageCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestionImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuestionImage.
     * @param {QuestionImageDeleteArgs} args - Arguments to delete one QuestionImage.
     * @example
     * // Delete one QuestionImage
     * const QuestionImage = await prisma.questionImage.delete({
     *   where: {
     *     // ... filter to delete one QuestionImage
     *   }
     * })
     * 
     */
    delete<T extends QuestionImageDeleteArgs>(args: SelectSubset<T, QuestionImageDeleteArgs<ExtArgs>>): Prisma__QuestionImageClient<$Result.GetResult<Prisma.$QuestionImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuestionImage.
     * @param {QuestionImageUpdateArgs} args - Arguments to update one QuestionImage.
     * @example
     * // Update one QuestionImage
     * const questionImage = await prisma.questionImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionImageUpdateArgs>(args: SelectSubset<T, QuestionImageUpdateArgs<ExtArgs>>): Prisma__QuestionImageClient<$Result.GetResult<Prisma.$QuestionImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuestionImages.
     * @param {QuestionImageDeleteManyArgs} args - Arguments to filter QuestionImages to delete.
     * @example
     * // Delete a few QuestionImages
     * const { count } = await prisma.questionImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionImageDeleteManyArgs>(args?: SelectSubset<T, QuestionImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionImages
     * const questionImage = await prisma.questionImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionImageUpdateManyArgs>(args: SelectSubset<T, QuestionImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionImages and returns the data updated in the database.
     * @param {QuestionImageUpdateManyAndReturnArgs} args - Arguments to update many QuestionImages.
     * @example
     * // Update many QuestionImages
     * const questionImage = await prisma.questionImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuestionImages and only return the `id`
     * const questionImageWithIdOnly = await prisma.questionImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuestionImageUpdateManyAndReturnArgs>(args: SelectSubset<T, QuestionImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuestionImage.
     * @param {QuestionImageUpsertArgs} args - Arguments to update or create a QuestionImage.
     * @example
     * // Update or create a QuestionImage
     * const questionImage = await prisma.questionImage.upsert({
     *   create: {
     *     // ... data to create a QuestionImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionImage we want to update
     *   }
     * })
     */
    upsert<T extends QuestionImageUpsertArgs>(args: SelectSubset<T, QuestionImageUpsertArgs<ExtArgs>>): Prisma__QuestionImageClient<$Result.GetResult<Prisma.$QuestionImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuestionImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionImageCountArgs} args - Arguments to filter QuestionImages to count.
     * @example
     * // Count the number of QuestionImages
     * const count = await prisma.questionImage.count({
     *   where: {
     *     // ... the filter for the QuestionImages we want to count
     *   }
     * })
    **/
    count<T extends QuestionImageCountArgs>(
      args?: Subset<T, QuestionImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionImageAggregateArgs>(args: Subset<T, QuestionImageAggregateArgs>): Prisma.PrismaPromise<GetQuestionImageAggregateType<T>>

    /**
     * Group by QuestionImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionImageGroupByArgs['orderBy'] }
        : { orderBy?: QuestionImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuestionImage model
   */
  readonly fields: QuestionImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestionImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    question<T extends QuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuestionDefaultArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuestionImage model
   */
  interface QuestionImageFieldRefs {
    readonly id: FieldRef<"QuestionImage", 'String'>
    readonly questionId: FieldRef<"QuestionImage", 'String'>
    readonly imageUrl: FieldRef<"QuestionImage", 'String'>
    readonly altText: FieldRef<"QuestionImage", 'String'>
    readonly sortOrder: FieldRef<"QuestionImage", 'Int'>
    readonly createdAt: FieldRef<"QuestionImage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuestionImage findUnique
   */
  export type QuestionImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionImage
     */
    select?: QuestionImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionImage
     */
    omit?: QuestionImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionImageInclude<ExtArgs> | null
    /**
     * Filter, which QuestionImage to fetch.
     */
    where: QuestionImageWhereUniqueInput
  }

  /**
   * QuestionImage findUniqueOrThrow
   */
  export type QuestionImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionImage
     */
    select?: QuestionImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionImage
     */
    omit?: QuestionImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionImageInclude<ExtArgs> | null
    /**
     * Filter, which QuestionImage to fetch.
     */
    where: QuestionImageWhereUniqueInput
  }

  /**
   * QuestionImage findFirst
   */
  export type QuestionImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionImage
     */
    select?: QuestionImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionImage
     */
    omit?: QuestionImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionImageInclude<ExtArgs> | null
    /**
     * Filter, which QuestionImage to fetch.
     */
    where?: QuestionImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionImages to fetch.
     */
    orderBy?: QuestionImageOrderByWithRelationInput | QuestionImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionImages.
     */
    cursor?: QuestionImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionImages.
     */
    distinct?: QuestionImageScalarFieldEnum | QuestionImageScalarFieldEnum[]
  }

  /**
   * QuestionImage findFirstOrThrow
   */
  export type QuestionImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionImage
     */
    select?: QuestionImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionImage
     */
    omit?: QuestionImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionImageInclude<ExtArgs> | null
    /**
     * Filter, which QuestionImage to fetch.
     */
    where?: QuestionImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionImages to fetch.
     */
    orderBy?: QuestionImageOrderByWithRelationInput | QuestionImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionImages.
     */
    cursor?: QuestionImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionImages.
     */
    distinct?: QuestionImageScalarFieldEnum | QuestionImageScalarFieldEnum[]
  }

  /**
   * QuestionImage findMany
   */
  export type QuestionImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionImage
     */
    select?: QuestionImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionImage
     */
    omit?: QuestionImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionImageInclude<ExtArgs> | null
    /**
     * Filter, which QuestionImages to fetch.
     */
    where?: QuestionImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionImages to fetch.
     */
    orderBy?: QuestionImageOrderByWithRelationInput | QuestionImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestionImages.
     */
    cursor?: QuestionImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionImages.
     */
    skip?: number
    distinct?: QuestionImageScalarFieldEnum | QuestionImageScalarFieldEnum[]
  }

  /**
   * QuestionImage create
   */
  export type QuestionImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionImage
     */
    select?: QuestionImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionImage
     */
    omit?: QuestionImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionImageInclude<ExtArgs> | null
    /**
     * The data needed to create a QuestionImage.
     */
    data: XOR<QuestionImageCreateInput, QuestionImageUncheckedCreateInput>
  }

  /**
   * QuestionImage createMany
   */
  export type QuestionImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuestionImages.
     */
    data: QuestionImageCreateManyInput | QuestionImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuestionImage createManyAndReturn
   */
  export type QuestionImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionImage
     */
    select?: QuestionImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionImage
     */
    omit?: QuestionImageOmit<ExtArgs> | null
    /**
     * The data used to create many QuestionImages.
     */
    data: QuestionImageCreateManyInput | QuestionImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuestionImage update
   */
  export type QuestionImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionImage
     */
    select?: QuestionImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionImage
     */
    omit?: QuestionImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionImageInclude<ExtArgs> | null
    /**
     * The data needed to update a QuestionImage.
     */
    data: XOR<QuestionImageUpdateInput, QuestionImageUncheckedUpdateInput>
    /**
     * Choose, which QuestionImage to update.
     */
    where: QuestionImageWhereUniqueInput
  }

  /**
   * QuestionImage updateMany
   */
  export type QuestionImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuestionImages.
     */
    data: XOR<QuestionImageUpdateManyMutationInput, QuestionImageUncheckedUpdateManyInput>
    /**
     * Filter which QuestionImages to update
     */
    where?: QuestionImageWhereInput
    /**
     * Limit how many QuestionImages to update.
     */
    limit?: number
  }

  /**
   * QuestionImage updateManyAndReturn
   */
  export type QuestionImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionImage
     */
    select?: QuestionImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionImage
     */
    omit?: QuestionImageOmit<ExtArgs> | null
    /**
     * The data used to update QuestionImages.
     */
    data: XOR<QuestionImageUpdateManyMutationInput, QuestionImageUncheckedUpdateManyInput>
    /**
     * Filter which QuestionImages to update
     */
    where?: QuestionImageWhereInput
    /**
     * Limit how many QuestionImages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuestionImage upsert
   */
  export type QuestionImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionImage
     */
    select?: QuestionImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionImage
     */
    omit?: QuestionImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionImageInclude<ExtArgs> | null
    /**
     * The filter to search for the QuestionImage to update in case it exists.
     */
    where: QuestionImageWhereUniqueInput
    /**
     * In case the QuestionImage found by the `where` argument doesn't exist, create a new QuestionImage with this data.
     */
    create: XOR<QuestionImageCreateInput, QuestionImageUncheckedCreateInput>
    /**
     * In case the QuestionImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionImageUpdateInput, QuestionImageUncheckedUpdateInput>
  }

  /**
   * QuestionImage delete
   */
  export type QuestionImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionImage
     */
    select?: QuestionImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionImage
     */
    omit?: QuestionImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionImageInclude<ExtArgs> | null
    /**
     * Filter which QuestionImage to delete.
     */
    where: QuestionImageWhereUniqueInput
  }

  /**
   * QuestionImage deleteMany
   */
  export type QuestionImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionImages to delete
     */
    where?: QuestionImageWhereInput
    /**
     * Limit how many QuestionImages to delete.
     */
    limit?: number
  }

  /**
   * QuestionImage without action
   */
  export type QuestionImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionImage
     */
    select?: QuestionImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionImage
     */
    omit?: QuestionImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionImageInclude<ExtArgs> | null
  }


  /**
   * Model QuestionTag
   */

  export type AggregateQuestionTag = {
    _count: QuestionTagCountAggregateOutputType | null
    _min: QuestionTagMinAggregateOutputType | null
    _max: QuestionTagMaxAggregateOutputType | null
  }

  export type QuestionTagMinAggregateOutputType = {
    id: string | null
    questionId: string | null
    tag: string | null
    createdAt: Date | null
  }

  export type QuestionTagMaxAggregateOutputType = {
    id: string | null
    questionId: string | null
    tag: string | null
    createdAt: Date | null
  }

  export type QuestionTagCountAggregateOutputType = {
    id: number
    questionId: number
    tag: number
    createdAt: number
    _all: number
  }


  export type QuestionTagMinAggregateInputType = {
    id?: true
    questionId?: true
    tag?: true
    createdAt?: true
  }

  export type QuestionTagMaxAggregateInputType = {
    id?: true
    questionId?: true
    tag?: true
    createdAt?: true
  }

  export type QuestionTagCountAggregateInputType = {
    id?: true
    questionId?: true
    tag?: true
    createdAt?: true
    _all?: true
  }

  export type QuestionTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionTag to aggregate.
     */
    where?: QuestionTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionTags to fetch.
     */
    orderBy?: QuestionTagOrderByWithRelationInput | QuestionTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestionTags
    **/
    _count?: true | QuestionTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionTagMaxAggregateInputType
  }

  export type GetQuestionTagAggregateType<T extends QuestionTagAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionTag[P]>
      : GetScalarType<T[P], AggregateQuestionTag[P]>
  }




  export type QuestionTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionTagWhereInput
    orderBy?: QuestionTagOrderByWithAggregationInput | QuestionTagOrderByWithAggregationInput[]
    by: QuestionTagScalarFieldEnum[] | QuestionTagScalarFieldEnum
    having?: QuestionTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionTagCountAggregateInputType | true
    _min?: QuestionTagMinAggregateInputType
    _max?: QuestionTagMaxAggregateInputType
  }

  export type QuestionTagGroupByOutputType = {
    id: string
    questionId: string
    tag: string
    createdAt: Date
    _count: QuestionTagCountAggregateOutputType | null
    _min: QuestionTagMinAggregateOutputType | null
    _max: QuestionTagMaxAggregateOutputType | null
  }

  type GetQuestionTagGroupByPayload<T extends QuestionTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionTagGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionTagGroupByOutputType[P]>
        }
      >
    >


  export type QuestionTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    tag?: boolean
    createdAt?: boolean
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionTag"]>

  export type QuestionTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    tag?: boolean
    createdAt?: boolean
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionTag"]>

  export type QuestionTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    questionId?: boolean
    tag?: boolean
    createdAt?: boolean
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionTag"]>

  export type QuestionTagSelectScalar = {
    id?: boolean
    questionId?: boolean
    tag?: boolean
    createdAt?: boolean
  }

  export type QuestionTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "questionId" | "tag" | "createdAt", ExtArgs["result"]["questionTag"]>
  export type QuestionTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }
  export type QuestionTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }
  export type QuestionTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }

  export type $QuestionTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuestionTag"
    objects: {
      question: Prisma.$QuestionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      questionId: string
      tag: string
      createdAt: Date
    }, ExtArgs["result"]["questionTag"]>
    composites: {}
  }

  type QuestionTagGetPayload<S extends boolean | null | undefined | QuestionTagDefaultArgs> = $Result.GetResult<Prisma.$QuestionTagPayload, S>

  type QuestionTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuestionTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuestionTagCountAggregateInputType | true
    }

  export interface QuestionTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuestionTag'], meta: { name: 'QuestionTag' } }
    /**
     * Find zero or one QuestionTag that matches the filter.
     * @param {QuestionTagFindUniqueArgs} args - Arguments to find a QuestionTag
     * @example
     * // Get one QuestionTag
     * const questionTag = await prisma.questionTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionTagFindUniqueArgs>(args: SelectSubset<T, QuestionTagFindUniqueArgs<ExtArgs>>): Prisma__QuestionTagClient<$Result.GetResult<Prisma.$QuestionTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuestionTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuestionTagFindUniqueOrThrowArgs} args - Arguments to find a QuestionTag
     * @example
     * // Get one QuestionTag
     * const questionTag = await prisma.questionTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionTagFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionTagClient<$Result.GetResult<Prisma.$QuestionTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuestionTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionTagFindFirstArgs} args - Arguments to find a QuestionTag
     * @example
     * // Get one QuestionTag
     * const questionTag = await prisma.questionTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionTagFindFirstArgs>(args?: SelectSubset<T, QuestionTagFindFirstArgs<ExtArgs>>): Prisma__QuestionTagClient<$Result.GetResult<Prisma.$QuestionTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuestionTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionTagFindFirstOrThrowArgs} args - Arguments to find a QuestionTag
     * @example
     * // Get one QuestionTag
     * const questionTag = await prisma.questionTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionTagFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionTagClient<$Result.GetResult<Prisma.$QuestionTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuestionTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionTags
     * const questionTags = await prisma.questionTag.findMany()
     * 
     * // Get first 10 QuestionTags
     * const questionTags = await prisma.questionTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionTagWithIdOnly = await prisma.questionTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionTagFindManyArgs>(args?: SelectSubset<T, QuestionTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuestionTag.
     * @param {QuestionTagCreateArgs} args - Arguments to create a QuestionTag.
     * @example
     * // Create one QuestionTag
     * const QuestionTag = await prisma.questionTag.create({
     *   data: {
     *     // ... data to create a QuestionTag
     *   }
     * })
     * 
     */
    create<T extends QuestionTagCreateArgs>(args: SelectSubset<T, QuestionTagCreateArgs<ExtArgs>>): Prisma__QuestionTagClient<$Result.GetResult<Prisma.$QuestionTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuestionTags.
     * @param {QuestionTagCreateManyArgs} args - Arguments to create many QuestionTags.
     * @example
     * // Create many QuestionTags
     * const questionTag = await prisma.questionTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionTagCreateManyArgs>(args?: SelectSubset<T, QuestionTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuestionTags and returns the data saved in the database.
     * @param {QuestionTagCreateManyAndReturnArgs} args - Arguments to create many QuestionTags.
     * @example
     * // Create many QuestionTags
     * const questionTag = await prisma.questionTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuestionTags and only return the `id`
     * const questionTagWithIdOnly = await prisma.questionTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestionTagCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestionTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuestionTag.
     * @param {QuestionTagDeleteArgs} args - Arguments to delete one QuestionTag.
     * @example
     * // Delete one QuestionTag
     * const QuestionTag = await prisma.questionTag.delete({
     *   where: {
     *     // ... filter to delete one QuestionTag
     *   }
     * })
     * 
     */
    delete<T extends QuestionTagDeleteArgs>(args: SelectSubset<T, QuestionTagDeleteArgs<ExtArgs>>): Prisma__QuestionTagClient<$Result.GetResult<Prisma.$QuestionTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuestionTag.
     * @param {QuestionTagUpdateArgs} args - Arguments to update one QuestionTag.
     * @example
     * // Update one QuestionTag
     * const questionTag = await prisma.questionTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionTagUpdateArgs>(args: SelectSubset<T, QuestionTagUpdateArgs<ExtArgs>>): Prisma__QuestionTagClient<$Result.GetResult<Prisma.$QuestionTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuestionTags.
     * @param {QuestionTagDeleteManyArgs} args - Arguments to filter QuestionTags to delete.
     * @example
     * // Delete a few QuestionTags
     * const { count } = await prisma.questionTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionTagDeleteManyArgs>(args?: SelectSubset<T, QuestionTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionTags
     * const questionTag = await prisma.questionTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionTagUpdateManyArgs>(args: SelectSubset<T, QuestionTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionTags and returns the data updated in the database.
     * @param {QuestionTagUpdateManyAndReturnArgs} args - Arguments to update many QuestionTags.
     * @example
     * // Update many QuestionTags
     * const questionTag = await prisma.questionTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuestionTags and only return the `id`
     * const questionTagWithIdOnly = await prisma.questionTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuestionTagUpdateManyAndReturnArgs>(args: SelectSubset<T, QuestionTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuestionTag.
     * @param {QuestionTagUpsertArgs} args - Arguments to update or create a QuestionTag.
     * @example
     * // Update or create a QuestionTag
     * const questionTag = await prisma.questionTag.upsert({
     *   create: {
     *     // ... data to create a QuestionTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionTag we want to update
     *   }
     * })
     */
    upsert<T extends QuestionTagUpsertArgs>(args: SelectSubset<T, QuestionTagUpsertArgs<ExtArgs>>): Prisma__QuestionTagClient<$Result.GetResult<Prisma.$QuestionTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuestionTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionTagCountArgs} args - Arguments to filter QuestionTags to count.
     * @example
     * // Count the number of QuestionTags
     * const count = await prisma.questionTag.count({
     *   where: {
     *     // ... the filter for the QuestionTags we want to count
     *   }
     * })
    **/
    count<T extends QuestionTagCountArgs>(
      args?: Subset<T, QuestionTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionTagAggregateArgs>(args: Subset<T, QuestionTagAggregateArgs>): Prisma.PrismaPromise<GetQuestionTagAggregateType<T>>

    /**
     * Group by QuestionTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionTagGroupByArgs['orderBy'] }
        : { orderBy?: QuestionTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuestionTag model
   */
  readonly fields: QuestionTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestionTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    question<T extends QuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuestionDefaultArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuestionTag model
   */
  interface QuestionTagFieldRefs {
    readonly id: FieldRef<"QuestionTag", 'String'>
    readonly questionId: FieldRef<"QuestionTag", 'String'>
    readonly tag: FieldRef<"QuestionTag", 'String'>
    readonly createdAt: FieldRef<"QuestionTag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuestionTag findUnique
   */
  export type QuestionTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionTag
     */
    select?: QuestionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionTag
     */
    omit?: QuestionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionTagInclude<ExtArgs> | null
    /**
     * Filter, which QuestionTag to fetch.
     */
    where: QuestionTagWhereUniqueInput
  }

  /**
   * QuestionTag findUniqueOrThrow
   */
  export type QuestionTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionTag
     */
    select?: QuestionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionTag
     */
    omit?: QuestionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionTagInclude<ExtArgs> | null
    /**
     * Filter, which QuestionTag to fetch.
     */
    where: QuestionTagWhereUniqueInput
  }

  /**
   * QuestionTag findFirst
   */
  export type QuestionTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionTag
     */
    select?: QuestionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionTag
     */
    omit?: QuestionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionTagInclude<ExtArgs> | null
    /**
     * Filter, which QuestionTag to fetch.
     */
    where?: QuestionTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionTags to fetch.
     */
    orderBy?: QuestionTagOrderByWithRelationInput | QuestionTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionTags.
     */
    cursor?: QuestionTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionTags.
     */
    distinct?: QuestionTagScalarFieldEnum | QuestionTagScalarFieldEnum[]
  }

  /**
   * QuestionTag findFirstOrThrow
   */
  export type QuestionTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionTag
     */
    select?: QuestionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionTag
     */
    omit?: QuestionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionTagInclude<ExtArgs> | null
    /**
     * Filter, which QuestionTag to fetch.
     */
    where?: QuestionTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionTags to fetch.
     */
    orderBy?: QuestionTagOrderByWithRelationInput | QuestionTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionTags.
     */
    cursor?: QuestionTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionTags.
     */
    distinct?: QuestionTagScalarFieldEnum | QuestionTagScalarFieldEnum[]
  }

  /**
   * QuestionTag findMany
   */
  export type QuestionTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionTag
     */
    select?: QuestionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionTag
     */
    omit?: QuestionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionTagInclude<ExtArgs> | null
    /**
     * Filter, which QuestionTags to fetch.
     */
    where?: QuestionTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionTags to fetch.
     */
    orderBy?: QuestionTagOrderByWithRelationInput | QuestionTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestionTags.
     */
    cursor?: QuestionTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionTags.
     */
    skip?: number
    distinct?: QuestionTagScalarFieldEnum | QuestionTagScalarFieldEnum[]
  }

  /**
   * QuestionTag create
   */
  export type QuestionTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionTag
     */
    select?: QuestionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionTag
     */
    omit?: QuestionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionTagInclude<ExtArgs> | null
    /**
     * The data needed to create a QuestionTag.
     */
    data: XOR<QuestionTagCreateInput, QuestionTagUncheckedCreateInput>
  }

  /**
   * QuestionTag createMany
   */
  export type QuestionTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuestionTags.
     */
    data: QuestionTagCreateManyInput | QuestionTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuestionTag createManyAndReturn
   */
  export type QuestionTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionTag
     */
    select?: QuestionTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionTag
     */
    omit?: QuestionTagOmit<ExtArgs> | null
    /**
     * The data used to create many QuestionTags.
     */
    data: QuestionTagCreateManyInput | QuestionTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuestionTag update
   */
  export type QuestionTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionTag
     */
    select?: QuestionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionTag
     */
    omit?: QuestionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionTagInclude<ExtArgs> | null
    /**
     * The data needed to update a QuestionTag.
     */
    data: XOR<QuestionTagUpdateInput, QuestionTagUncheckedUpdateInput>
    /**
     * Choose, which QuestionTag to update.
     */
    where: QuestionTagWhereUniqueInput
  }

  /**
   * QuestionTag updateMany
   */
  export type QuestionTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuestionTags.
     */
    data: XOR<QuestionTagUpdateManyMutationInput, QuestionTagUncheckedUpdateManyInput>
    /**
     * Filter which QuestionTags to update
     */
    where?: QuestionTagWhereInput
    /**
     * Limit how many QuestionTags to update.
     */
    limit?: number
  }

  /**
   * QuestionTag updateManyAndReturn
   */
  export type QuestionTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionTag
     */
    select?: QuestionTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionTag
     */
    omit?: QuestionTagOmit<ExtArgs> | null
    /**
     * The data used to update QuestionTags.
     */
    data: XOR<QuestionTagUpdateManyMutationInput, QuestionTagUncheckedUpdateManyInput>
    /**
     * Filter which QuestionTags to update
     */
    where?: QuestionTagWhereInput
    /**
     * Limit how many QuestionTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuestionTag upsert
   */
  export type QuestionTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionTag
     */
    select?: QuestionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionTag
     */
    omit?: QuestionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionTagInclude<ExtArgs> | null
    /**
     * The filter to search for the QuestionTag to update in case it exists.
     */
    where: QuestionTagWhereUniqueInput
    /**
     * In case the QuestionTag found by the `where` argument doesn't exist, create a new QuestionTag with this data.
     */
    create: XOR<QuestionTagCreateInput, QuestionTagUncheckedCreateInput>
    /**
     * In case the QuestionTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionTagUpdateInput, QuestionTagUncheckedUpdateInput>
  }

  /**
   * QuestionTag delete
   */
  export type QuestionTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionTag
     */
    select?: QuestionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionTag
     */
    omit?: QuestionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionTagInclude<ExtArgs> | null
    /**
     * Filter which QuestionTag to delete.
     */
    where: QuestionTagWhereUniqueInput
  }

  /**
   * QuestionTag deleteMany
   */
  export type QuestionTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionTags to delete
     */
    where?: QuestionTagWhereInput
    /**
     * Limit how many QuestionTags to delete.
     */
    limit?: number
  }

  /**
   * QuestionTag without action
   */
  export type QuestionTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionTag
     */
    select?: QuestionTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionTag
     */
    omit?: QuestionTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionTagInclude<ExtArgs> | null
  }


  /**
   * Model Exam
   */

  export type AggregateExam = {
    _count: ExamCountAggregateOutputType | null
    _avg: ExamAvgAggregateOutputType | null
    _sum: ExamSumAggregateOutputType | null
    _min: ExamMinAggregateOutputType | null
    _max: ExamMaxAggregateOutputType | null
  }

  export type ExamAvgAggregateOutputType = {
    duration: number | null
    totalMarks: number | null
    passingMarks: number | null
    price: Decimal | null
    maxRetakes: number | null
    questionOverlapPercentage: number | null
  }

  export type ExamSumAggregateOutputType = {
    duration: number | null
    totalMarks: number | null
    passingMarks: number | null
    price: Decimal | null
    maxRetakes: number | null
    questionOverlapPercentage: number | null
  }

  export type ExamMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    examCategoryId: string | null
    duration: number | null
    totalMarks: number | null
    passingMarks: number | null
    price: Decimal | null
    currency: string | null
    isActive: boolean | null
    isPublic: boolean | null
    allowRetakes: boolean | null
    maxRetakes: number | null
    showResults: boolean | null
    showAnswers: boolean | null
    randomizeQuestions: boolean | null
    randomizeOptions: boolean | null
    questionOverlapPercentage: number | null
    createdBy: string | null
    approvedBy: string | null
    approvedAt: Date | null
    scheduledStart: Date | null
    scheduledEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    examCategoryId: string | null
    duration: number | null
    totalMarks: number | null
    passingMarks: number | null
    price: Decimal | null
    currency: string | null
    isActive: boolean | null
    isPublic: boolean | null
    allowRetakes: boolean | null
    maxRetakes: number | null
    showResults: boolean | null
    showAnswers: boolean | null
    randomizeQuestions: boolean | null
    randomizeOptions: boolean | null
    questionOverlapPercentage: number | null
    createdBy: string | null
    approvedBy: string | null
    approvedAt: Date | null
    scheduledStart: Date | null
    scheduledEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamCountAggregateOutputType = {
    id: number
    title: number
    description: number
    examCategoryId: number
    duration: number
    totalMarks: number
    passingMarks: number
    price: number
    currency: number
    isActive: number
    isPublic: number
    allowRetakes: number
    maxRetakes: number
    showResults: number
    showAnswers: number
    randomizeQuestions: number
    randomizeOptions: number
    questionOverlapPercentage: number
    createdBy: number
    approvedBy: number
    approvedAt: number
    scheduledStart: number
    scheduledEnd: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExamAvgAggregateInputType = {
    duration?: true
    totalMarks?: true
    passingMarks?: true
    price?: true
    maxRetakes?: true
    questionOverlapPercentage?: true
  }

  export type ExamSumAggregateInputType = {
    duration?: true
    totalMarks?: true
    passingMarks?: true
    price?: true
    maxRetakes?: true
    questionOverlapPercentage?: true
  }

  export type ExamMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    examCategoryId?: true
    duration?: true
    totalMarks?: true
    passingMarks?: true
    price?: true
    currency?: true
    isActive?: true
    isPublic?: true
    allowRetakes?: true
    maxRetakes?: true
    showResults?: true
    showAnswers?: true
    randomizeQuestions?: true
    randomizeOptions?: true
    questionOverlapPercentage?: true
    createdBy?: true
    approvedBy?: true
    approvedAt?: true
    scheduledStart?: true
    scheduledEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    examCategoryId?: true
    duration?: true
    totalMarks?: true
    passingMarks?: true
    price?: true
    currency?: true
    isActive?: true
    isPublic?: true
    allowRetakes?: true
    maxRetakes?: true
    showResults?: true
    showAnswers?: true
    randomizeQuestions?: true
    randomizeOptions?: true
    questionOverlapPercentage?: true
    createdBy?: true
    approvedBy?: true
    approvedAt?: true
    scheduledStart?: true
    scheduledEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    examCategoryId?: true
    duration?: true
    totalMarks?: true
    passingMarks?: true
    price?: true
    currency?: true
    isActive?: true
    isPublic?: true
    allowRetakes?: true
    maxRetakes?: true
    showResults?: true
    showAnswers?: true
    randomizeQuestions?: true
    randomizeOptions?: true
    questionOverlapPercentage?: true
    createdBy?: true
    approvedBy?: true
    approvedAt?: true
    scheduledStart?: true
    scheduledEnd?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exam to aggregate.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Exams
    **/
    _count?: true | ExamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamMaxAggregateInputType
  }

  export type GetExamAggregateType<T extends ExamAggregateArgs> = {
        [P in keyof T & keyof AggregateExam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExam[P]>
      : GetScalarType<T[P], AggregateExam[P]>
  }




  export type ExamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithAggregationInput | ExamOrderByWithAggregationInput[]
    by: ExamScalarFieldEnum[] | ExamScalarFieldEnum
    having?: ExamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamCountAggregateInputType | true
    _avg?: ExamAvgAggregateInputType
    _sum?: ExamSumAggregateInputType
    _min?: ExamMinAggregateInputType
    _max?: ExamMaxAggregateInputType
  }

  export type ExamGroupByOutputType = {
    id: string
    title: string
    description: string | null
    examCategoryId: string
    duration: number
    totalMarks: number
    passingMarks: number
    price: Decimal
    currency: string
    isActive: boolean
    isPublic: boolean
    allowRetakes: boolean
    maxRetakes: number
    showResults: boolean
    showAnswers: boolean
    randomizeQuestions: boolean
    randomizeOptions: boolean
    questionOverlapPercentage: number
    createdBy: string
    approvedBy: string | null
    approvedAt: Date | null
    scheduledStart: Date | null
    scheduledEnd: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ExamCountAggregateOutputType | null
    _avg: ExamAvgAggregateOutputType | null
    _sum: ExamSumAggregateOutputType | null
    _min: ExamMinAggregateOutputType | null
    _max: ExamMaxAggregateOutputType | null
  }

  type GetExamGroupByPayload<T extends ExamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamGroupByOutputType[P]>
            : GetScalarType<T[P], ExamGroupByOutputType[P]>
        }
      >
    >


  export type ExamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    examCategoryId?: boolean
    duration?: boolean
    totalMarks?: boolean
    passingMarks?: boolean
    price?: boolean
    currency?: boolean
    isActive?: boolean
    isPublic?: boolean
    allowRetakes?: boolean
    maxRetakes?: boolean
    showResults?: boolean
    showAnswers?: boolean
    randomizeQuestions?: boolean
    randomizeOptions?: boolean
    questionOverlapPercentage?: boolean
    createdBy?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    scheduledStart?: boolean
    scheduledEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    examCategory?: boolean | ExamCategoryDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | Exam$approverArgs<ExtArgs>
    questions?: boolean | Exam$questionsArgs<ExtArgs>
    bookings?: boolean | Exam$bookingsArgs<ExtArgs>
    attempts?: boolean | Exam$attemptsArgs<ExtArgs>
    examScores?: boolean | Exam$examScoresArgs<ExtArgs>
    certificates?: boolean | Exam$certificatesArgs<ExtArgs>
    _count?: boolean | ExamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exam"]>

  export type ExamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    examCategoryId?: boolean
    duration?: boolean
    totalMarks?: boolean
    passingMarks?: boolean
    price?: boolean
    currency?: boolean
    isActive?: boolean
    isPublic?: boolean
    allowRetakes?: boolean
    maxRetakes?: boolean
    showResults?: boolean
    showAnswers?: boolean
    randomizeQuestions?: boolean
    randomizeOptions?: boolean
    questionOverlapPercentage?: boolean
    createdBy?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    scheduledStart?: boolean
    scheduledEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    examCategory?: boolean | ExamCategoryDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | Exam$approverArgs<ExtArgs>
  }, ExtArgs["result"]["exam"]>

  export type ExamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    examCategoryId?: boolean
    duration?: boolean
    totalMarks?: boolean
    passingMarks?: boolean
    price?: boolean
    currency?: boolean
    isActive?: boolean
    isPublic?: boolean
    allowRetakes?: boolean
    maxRetakes?: boolean
    showResults?: boolean
    showAnswers?: boolean
    randomizeQuestions?: boolean
    randomizeOptions?: boolean
    questionOverlapPercentage?: boolean
    createdBy?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    scheduledStart?: boolean
    scheduledEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    examCategory?: boolean | ExamCategoryDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | Exam$approverArgs<ExtArgs>
  }, ExtArgs["result"]["exam"]>

  export type ExamSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    examCategoryId?: boolean
    duration?: boolean
    totalMarks?: boolean
    passingMarks?: boolean
    price?: boolean
    currency?: boolean
    isActive?: boolean
    isPublic?: boolean
    allowRetakes?: boolean
    maxRetakes?: boolean
    showResults?: boolean
    showAnswers?: boolean
    randomizeQuestions?: boolean
    randomizeOptions?: boolean
    questionOverlapPercentage?: boolean
    createdBy?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    scheduledStart?: boolean
    scheduledEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "examCategoryId" | "duration" | "totalMarks" | "passingMarks" | "price" | "currency" | "isActive" | "isPublic" | "allowRetakes" | "maxRetakes" | "showResults" | "showAnswers" | "randomizeQuestions" | "randomizeOptions" | "questionOverlapPercentage" | "createdBy" | "approvedBy" | "approvedAt" | "scheduledStart" | "scheduledEnd" | "createdAt" | "updatedAt", ExtArgs["result"]["exam"]>
  export type ExamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examCategory?: boolean | ExamCategoryDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | Exam$approverArgs<ExtArgs>
    questions?: boolean | Exam$questionsArgs<ExtArgs>
    bookings?: boolean | Exam$bookingsArgs<ExtArgs>
    attempts?: boolean | Exam$attemptsArgs<ExtArgs>
    examScores?: boolean | Exam$examScoresArgs<ExtArgs>
    certificates?: boolean | Exam$certificatesArgs<ExtArgs>
    _count?: boolean | ExamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examCategory?: boolean | ExamCategoryDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | Exam$approverArgs<ExtArgs>
  }
  export type ExamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examCategory?: boolean | ExamCategoryDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | Exam$approverArgs<ExtArgs>
  }

  export type $ExamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Exam"
    objects: {
      examCategory: Prisma.$ExamCategoryPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
      approver: Prisma.$UserPayload<ExtArgs> | null
      questions: Prisma.$ExamQuestionPayload<ExtArgs>[]
      bookings: Prisma.$ExamBookingPayload<ExtArgs>[]
      attempts: Prisma.$ExamAttemptPayload<ExtArgs>[]
      examScores: Prisma.$ExamScorePayload<ExtArgs>[]
      certificates: Prisma.$CertificatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      examCategoryId: string
      duration: number
      totalMarks: number
      passingMarks: number
      price: Prisma.Decimal
      currency: string
      isActive: boolean
      isPublic: boolean
      allowRetakes: boolean
      maxRetakes: number
      showResults: boolean
      showAnswers: boolean
      randomizeQuestions: boolean
      randomizeOptions: boolean
      questionOverlapPercentage: number
      createdBy: string
      approvedBy: string | null
      approvedAt: Date | null
      scheduledStart: Date | null
      scheduledEnd: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["exam"]>
    composites: {}
  }

  type ExamGetPayload<S extends boolean | null | undefined | ExamDefaultArgs> = $Result.GetResult<Prisma.$ExamPayload, S>

  type ExamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExamCountAggregateInputType | true
    }

  export interface ExamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Exam'], meta: { name: 'Exam' } }
    /**
     * Find zero or one Exam that matches the filter.
     * @param {ExamFindUniqueArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamFindUniqueArgs>(args: SelectSubset<T, ExamFindUniqueArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Exam that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExamFindUniqueOrThrowArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exam that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindFirstArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamFindFirstArgs>(args?: SelectSubset<T, ExamFindFirstArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exam that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindFirstOrThrowArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Exams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exams
     * const exams = await prisma.exam.findMany()
     * 
     * // Get first 10 Exams
     * const exams = await prisma.exam.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examWithIdOnly = await prisma.exam.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamFindManyArgs>(args?: SelectSubset<T, ExamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Exam.
     * @param {ExamCreateArgs} args - Arguments to create a Exam.
     * @example
     * // Create one Exam
     * const Exam = await prisma.exam.create({
     *   data: {
     *     // ... data to create a Exam
     *   }
     * })
     * 
     */
    create<T extends ExamCreateArgs>(args: SelectSubset<T, ExamCreateArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Exams.
     * @param {ExamCreateManyArgs} args - Arguments to create many Exams.
     * @example
     * // Create many Exams
     * const exam = await prisma.exam.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamCreateManyArgs>(args?: SelectSubset<T, ExamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Exams and returns the data saved in the database.
     * @param {ExamCreateManyAndReturnArgs} args - Arguments to create many Exams.
     * @example
     * // Create many Exams
     * const exam = await prisma.exam.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Exams and only return the `id`
     * const examWithIdOnly = await prisma.exam.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExamCreateManyAndReturnArgs>(args?: SelectSubset<T, ExamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Exam.
     * @param {ExamDeleteArgs} args - Arguments to delete one Exam.
     * @example
     * // Delete one Exam
     * const Exam = await prisma.exam.delete({
     *   where: {
     *     // ... filter to delete one Exam
     *   }
     * })
     * 
     */
    delete<T extends ExamDeleteArgs>(args: SelectSubset<T, ExamDeleteArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Exam.
     * @param {ExamUpdateArgs} args - Arguments to update one Exam.
     * @example
     * // Update one Exam
     * const exam = await prisma.exam.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamUpdateArgs>(args: SelectSubset<T, ExamUpdateArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Exams.
     * @param {ExamDeleteManyArgs} args - Arguments to filter Exams to delete.
     * @example
     * // Delete a few Exams
     * const { count } = await prisma.exam.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamDeleteManyArgs>(args?: SelectSubset<T, ExamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exams
     * const exam = await prisma.exam.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamUpdateManyArgs>(args: SelectSubset<T, ExamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exams and returns the data updated in the database.
     * @param {ExamUpdateManyAndReturnArgs} args - Arguments to update many Exams.
     * @example
     * // Update many Exams
     * const exam = await prisma.exam.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Exams and only return the `id`
     * const examWithIdOnly = await prisma.exam.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExamUpdateManyAndReturnArgs>(args: SelectSubset<T, ExamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Exam.
     * @param {ExamUpsertArgs} args - Arguments to update or create a Exam.
     * @example
     * // Update or create a Exam
     * const exam = await prisma.exam.upsert({
     *   create: {
     *     // ... data to create a Exam
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exam we want to update
     *   }
     * })
     */
    upsert<T extends ExamUpsertArgs>(args: SelectSubset<T, ExamUpsertArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamCountArgs} args - Arguments to filter Exams to count.
     * @example
     * // Count the number of Exams
     * const count = await prisma.exam.count({
     *   where: {
     *     // ... the filter for the Exams we want to count
     *   }
     * })
    **/
    count<T extends ExamCountArgs>(
      args?: Subset<T, ExamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamAggregateArgs>(args: Subset<T, ExamAggregateArgs>): Prisma.PrismaPromise<GetExamAggregateType<T>>

    /**
     * Group by Exam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamGroupByArgs['orderBy'] }
        : { orderBy?: ExamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Exam model
   */
  readonly fields: ExamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Exam.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    examCategory<T extends ExamCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamCategoryDefaultArgs<ExtArgs>>): Prisma__ExamCategoryClient<$Result.GetResult<Prisma.$ExamCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    approver<T extends Exam$approverArgs<ExtArgs> = {}>(args?: Subset<T, Exam$approverArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    questions<T extends Exam$questionsArgs<ExtArgs> = {}>(args?: Subset<T, Exam$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookings<T extends Exam$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Exam$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamBookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attempts<T extends Exam$attemptsArgs<ExtArgs> = {}>(args?: Subset<T, Exam$attemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    examScores<T extends Exam$examScoresArgs<ExtArgs> = {}>(args?: Subset<T, Exam$examScoresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamScorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    certificates<T extends Exam$certificatesArgs<ExtArgs> = {}>(args?: Subset<T, Exam$certificatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Exam model
   */
  interface ExamFieldRefs {
    readonly id: FieldRef<"Exam", 'String'>
    readonly title: FieldRef<"Exam", 'String'>
    readonly description: FieldRef<"Exam", 'String'>
    readonly examCategoryId: FieldRef<"Exam", 'String'>
    readonly duration: FieldRef<"Exam", 'Int'>
    readonly totalMarks: FieldRef<"Exam", 'Int'>
    readonly passingMarks: FieldRef<"Exam", 'Int'>
    readonly price: FieldRef<"Exam", 'Decimal'>
    readonly currency: FieldRef<"Exam", 'String'>
    readonly isActive: FieldRef<"Exam", 'Boolean'>
    readonly isPublic: FieldRef<"Exam", 'Boolean'>
    readonly allowRetakes: FieldRef<"Exam", 'Boolean'>
    readonly maxRetakes: FieldRef<"Exam", 'Int'>
    readonly showResults: FieldRef<"Exam", 'Boolean'>
    readonly showAnswers: FieldRef<"Exam", 'Boolean'>
    readonly randomizeQuestions: FieldRef<"Exam", 'Boolean'>
    readonly randomizeOptions: FieldRef<"Exam", 'Boolean'>
    readonly questionOverlapPercentage: FieldRef<"Exam", 'Float'>
    readonly createdBy: FieldRef<"Exam", 'String'>
    readonly approvedBy: FieldRef<"Exam", 'String'>
    readonly approvedAt: FieldRef<"Exam", 'DateTime'>
    readonly scheduledStart: FieldRef<"Exam", 'DateTime'>
    readonly scheduledEnd: FieldRef<"Exam", 'DateTime'>
    readonly createdAt: FieldRef<"Exam", 'DateTime'>
    readonly updatedAt: FieldRef<"Exam", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Exam findUnique
   */
  export type ExamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam findUniqueOrThrow
   */
  export type ExamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam findFirst
   */
  export type ExamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exams.
     */
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam findFirstOrThrow
   */
  export type ExamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exams.
     */
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam findMany
   */
  export type ExamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exams to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam create
   */
  export type ExamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The data needed to create a Exam.
     */
    data: XOR<ExamCreateInput, ExamUncheckedCreateInput>
  }

  /**
   * Exam createMany
   */
  export type ExamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Exams.
     */
    data: ExamCreateManyInput | ExamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Exam createManyAndReturn
   */
  export type ExamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * The data used to create many Exams.
     */
    data: ExamCreateManyInput | ExamCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Exam update
   */
  export type ExamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The data needed to update a Exam.
     */
    data: XOR<ExamUpdateInput, ExamUncheckedUpdateInput>
    /**
     * Choose, which Exam to update.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam updateMany
   */
  export type ExamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Exams.
     */
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyInput>
    /**
     * Filter which Exams to update
     */
    where?: ExamWhereInput
    /**
     * Limit how many Exams to update.
     */
    limit?: number
  }

  /**
   * Exam updateManyAndReturn
   */
  export type ExamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * The data used to update Exams.
     */
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyInput>
    /**
     * Filter which Exams to update
     */
    where?: ExamWhereInput
    /**
     * Limit how many Exams to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Exam upsert
   */
  export type ExamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The filter to search for the Exam to update in case it exists.
     */
    where: ExamWhereUniqueInput
    /**
     * In case the Exam found by the `where` argument doesn't exist, create a new Exam with this data.
     */
    create: XOR<ExamCreateInput, ExamUncheckedCreateInput>
    /**
     * In case the Exam was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamUpdateInput, ExamUncheckedUpdateInput>
  }

  /**
   * Exam delete
   */
  export type ExamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter which Exam to delete.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam deleteMany
   */
  export type ExamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exams to delete
     */
    where?: ExamWhereInput
    /**
     * Limit how many Exams to delete.
     */
    limit?: number
  }

  /**
   * Exam.approver
   */
  export type Exam$approverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Exam.questions
   */
  export type Exam$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamQuestion
     */
    select?: ExamQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamQuestion
     */
    omit?: ExamQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamQuestionInclude<ExtArgs> | null
    where?: ExamQuestionWhereInput
    orderBy?: ExamQuestionOrderByWithRelationInput | ExamQuestionOrderByWithRelationInput[]
    cursor?: ExamQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamQuestionScalarFieldEnum | ExamQuestionScalarFieldEnum[]
  }

  /**
   * Exam.bookings
   */
  export type Exam$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamBooking
     */
    select?: ExamBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamBooking
     */
    omit?: ExamBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamBookingInclude<ExtArgs> | null
    where?: ExamBookingWhereInput
    orderBy?: ExamBookingOrderByWithRelationInput | ExamBookingOrderByWithRelationInput[]
    cursor?: ExamBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamBookingScalarFieldEnum | ExamBookingScalarFieldEnum[]
  }

  /**
   * Exam.attempts
   */
  export type Exam$attemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAttempt
     */
    omit?: ExamAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    where?: ExamAttemptWhereInput
    orderBy?: ExamAttemptOrderByWithRelationInput | ExamAttemptOrderByWithRelationInput[]
    cursor?: ExamAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamAttemptScalarFieldEnum | ExamAttemptScalarFieldEnum[]
  }

  /**
   * Exam.examScores
   */
  export type Exam$examScoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamScore
     */
    select?: ExamScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamScore
     */
    omit?: ExamScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScoreInclude<ExtArgs> | null
    where?: ExamScoreWhereInput
    orderBy?: ExamScoreOrderByWithRelationInput | ExamScoreOrderByWithRelationInput[]
    cursor?: ExamScoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamScoreScalarFieldEnum | ExamScoreScalarFieldEnum[]
  }

  /**
   * Exam.certificates
   */
  export type Exam$certificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    cursor?: CertificateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Exam without action
   */
  export type ExamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Exam
     */
    omit?: ExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
  }


  /**
   * Model ExamQuestion
   */

  export type AggregateExamQuestion = {
    _count: ExamQuestionCountAggregateOutputType | null
    _avg: ExamQuestionAvgAggregateOutputType | null
    _sum: ExamQuestionSumAggregateOutputType | null
    _min: ExamQuestionMinAggregateOutputType | null
    _max: ExamQuestionMaxAggregateOutputType | null
  }

  export type ExamQuestionAvgAggregateOutputType = {
    order: number | null
    marks: number | null
  }

  export type ExamQuestionSumAggregateOutputType = {
    order: number | null
    marks: number | null
  }

  export type ExamQuestionMinAggregateOutputType = {
    id: string | null
    examId: string | null
    questionId: string | null
    order: number | null
    marks: number | null
    createdAt: Date | null
  }

  export type ExamQuestionMaxAggregateOutputType = {
    id: string | null
    examId: string | null
    questionId: string | null
    order: number | null
    marks: number | null
    createdAt: Date | null
  }

  export type ExamQuestionCountAggregateOutputType = {
    id: number
    examId: number
    questionId: number
    order: number
    marks: number
    createdAt: number
    _all: number
  }


  export type ExamQuestionAvgAggregateInputType = {
    order?: true
    marks?: true
  }

  export type ExamQuestionSumAggregateInputType = {
    order?: true
    marks?: true
  }

  export type ExamQuestionMinAggregateInputType = {
    id?: true
    examId?: true
    questionId?: true
    order?: true
    marks?: true
    createdAt?: true
  }

  export type ExamQuestionMaxAggregateInputType = {
    id?: true
    examId?: true
    questionId?: true
    order?: true
    marks?: true
    createdAt?: true
  }

  export type ExamQuestionCountAggregateInputType = {
    id?: true
    examId?: true
    questionId?: true
    order?: true
    marks?: true
    createdAt?: true
    _all?: true
  }

  export type ExamQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamQuestion to aggregate.
     */
    where?: ExamQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamQuestions to fetch.
     */
    orderBy?: ExamQuestionOrderByWithRelationInput | ExamQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExamQuestions
    **/
    _count?: true | ExamQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamQuestionMaxAggregateInputType
  }

  export type GetExamQuestionAggregateType<T extends ExamQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateExamQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamQuestion[P]>
      : GetScalarType<T[P], AggregateExamQuestion[P]>
  }




  export type ExamQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamQuestionWhereInput
    orderBy?: ExamQuestionOrderByWithAggregationInput | ExamQuestionOrderByWithAggregationInput[]
    by: ExamQuestionScalarFieldEnum[] | ExamQuestionScalarFieldEnum
    having?: ExamQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamQuestionCountAggregateInputType | true
    _avg?: ExamQuestionAvgAggregateInputType
    _sum?: ExamQuestionSumAggregateInputType
    _min?: ExamQuestionMinAggregateInputType
    _max?: ExamQuestionMaxAggregateInputType
  }

  export type ExamQuestionGroupByOutputType = {
    id: string
    examId: string
    questionId: string
    order: number
    marks: number
    createdAt: Date
    _count: ExamQuestionCountAggregateOutputType | null
    _avg: ExamQuestionAvgAggregateOutputType | null
    _sum: ExamQuestionSumAggregateOutputType | null
    _min: ExamQuestionMinAggregateOutputType | null
    _max: ExamQuestionMaxAggregateOutputType | null
  }

  type GetExamQuestionGroupByPayload<T extends ExamQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], ExamQuestionGroupByOutputType[P]>
        }
      >
    >


  export type ExamQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    examId?: boolean
    questionId?: boolean
    order?: boolean
    marks?: boolean
    createdAt?: boolean
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examQuestion"]>

  export type ExamQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    examId?: boolean
    questionId?: boolean
    order?: boolean
    marks?: boolean
    createdAt?: boolean
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examQuestion"]>

  export type ExamQuestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    examId?: boolean
    questionId?: boolean
    order?: boolean
    marks?: boolean
    createdAt?: boolean
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examQuestion"]>

  export type ExamQuestionSelectScalar = {
    id?: boolean
    examId?: boolean
    questionId?: boolean
    order?: boolean
    marks?: boolean
    createdAt?: boolean
  }

  export type ExamQuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "examId" | "questionId" | "order" | "marks" | "createdAt", ExtArgs["result"]["examQuestion"]>
  export type ExamQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }
  export type ExamQuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }
  export type ExamQuestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    question?: boolean | QuestionDefaultArgs<ExtArgs>
  }

  export type $ExamQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExamQuestion"
    objects: {
      exam: Prisma.$ExamPayload<ExtArgs>
      question: Prisma.$QuestionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      examId: string
      questionId: string
      order: number
      marks: number
      createdAt: Date
    }, ExtArgs["result"]["examQuestion"]>
    composites: {}
  }

  type ExamQuestionGetPayload<S extends boolean | null | undefined | ExamQuestionDefaultArgs> = $Result.GetResult<Prisma.$ExamQuestionPayload, S>

  type ExamQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExamQuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExamQuestionCountAggregateInputType | true
    }

  export interface ExamQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExamQuestion'], meta: { name: 'ExamQuestion' } }
    /**
     * Find zero or one ExamQuestion that matches the filter.
     * @param {ExamQuestionFindUniqueArgs} args - Arguments to find a ExamQuestion
     * @example
     * // Get one ExamQuestion
     * const examQuestion = await prisma.examQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamQuestionFindUniqueArgs>(args: SelectSubset<T, ExamQuestionFindUniqueArgs<ExtArgs>>): Prisma__ExamQuestionClient<$Result.GetResult<Prisma.$ExamQuestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExamQuestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExamQuestionFindUniqueOrThrowArgs} args - Arguments to find a ExamQuestion
     * @example
     * // Get one ExamQuestion
     * const examQuestion = await prisma.examQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamQuestionClient<$Result.GetResult<Prisma.$ExamQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExamQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamQuestionFindFirstArgs} args - Arguments to find a ExamQuestion
     * @example
     * // Get one ExamQuestion
     * const examQuestion = await prisma.examQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamQuestionFindFirstArgs>(args?: SelectSubset<T, ExamQuestionFindFirstArgs<ExtArgs>>): Prisma__ExamQuestionClient<$Result.GetResult<Prisma.$ExamQuestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExamQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamQuestionFindFirstOrThrowArgs} args - Arguments to find a ExamQuestion
     * @example
     * // Get one ExamQuestion
     * const examQuestion = await prisma.examQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamQuestionClient<$Result.GetResult<Prisma.$ExamQuestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExamQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExamQuestions
     * const examQuestions = await prisma.examQuestion.findMany()
     * 
     * // Get first 10 ExamQuestions
     * const examQuestions = await prisma.examQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examQuestionWithIdOnly = await prisma.examQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamQuestionFindManyArgs>(args?: SelectSubset<T, ExamQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExamQuestion.
     * @param {ExamQuestionCreateArgs} args - Arguments to create a ExamQuestion.
     * @example
     * // Create one ExamQuestion
     * const ExamQuestion = await prisma.examQuestion.create({
     *   data: {
     *     // ... data to create a ExamQuestion
     *   }
     * })
     * 
     */
    create<T extends ExamQuestionCreateArgs>(args: SelectSubset<T, ExamQuestionCreateArgs<ExtArgs>>): Prisma__ExamQuestionClient<$Result.GetResult<Prisma.$ExamQuestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExamQuestions.
     * @param {ExamQuestionCreateManyArgs} args - Arguments to create many ExamQuestions.
     * @example
     * // Create many ExamQuestions
     * const examQuestion = await prisma.examQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamQuestionCreateManyArgs>(args?: SelectSubset<T, ExamQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExamQuestions and returns the data saved in the database.
     * @param {ExamQuestionCreateManyAndReturnArgs} args - Arguments to create many ExamQuestions.
     * @example
     * // Create many ExamQuestions
     * const examQuestion = await prisma.examQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExamQuestions and only return the `id`
     * const examQuestionWithIdOnly = await prisma.examQuestion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExamQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, ExamQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamQuestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExamQuestion.
     * @param {ExamQuestionDeleteArgs} args - Arguments to delete one ExamQuestion.
     * @example
     * // Delete one ExamQuestion
     * const ExamQuestion = await prisma.examQuestion.delete({
     *   where: {
     *     // ... filter to delete one ExamQuestion
     *   }
     * })
     * 
     */
    delete<T extends ExamQuestionDeleteArgs>(args: SelectSubset<T, ExamQuestionDeleteArgs<ExtArgs>>): Prisma__ExamQuestionClient<$Result.GetResult<Prisma.$ExamQuestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExamQuestion.
     * @param {ExamQuestionUpdateArgs} args - Arguments to update one ExamQuestion.
     * @example
     * // Update one ExamQuestion
     * const examQuestion = await prisma.examQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamQuestionUpdateArgs>(args: SelectSubset<T, ExamQuestionUpdateArgs<ExtArgs>>): Prisma__ExamQuestionClient<$Result.GetResult<Prisma.$ExamQuestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExamQuestions.
     * @param {ExamQuestionDeleteManyArgs} args - Arguments to filter ExamQuestions to delete.
     * @example
     * // Delete a few ExamQuestions
     * const { count } = await prisma.examQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamQuestionDeleteManyArgs>(args?: SelectSubset<T, ExamQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExamQuestions
     * const examQuestion = await prisma.examQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamQuestionUpdateManyArgs>(args: SelectSubset<T, ExamQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamQuestions and returns the data updated in the database.
     * @param {ExamQuestionUpdateManyAndReturnArgs} args - Arguments to update many ExamQuestions.
     * @example
     * // Update many ExamQuestions
     * const examQuestion = await prisma.examQuestion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExamQuestions and only return the `id`
     * const examQuestionWithIdOnly = await prisma.examQuestion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExamQuestionUpdateManyAndReturnArgs>(args: SelectSubset<T, ExamQuestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamQuestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExamQuestion.
     * @param {ExamQuestionUpsertArgs} args - Arguments to update or create a ExamQuestion.
     * @example
     * // Update or create a ExamQuestion
     * const examQuestion = await prisma.examQuestion.upsert({
     *   create: {
     *     // ... data to create a ExamQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExamQuestion we want to update
     *   }
     * })
     */
    upsert<T extends ExamQuestionUpsertArgs>(args: SelectSubset<T, ExamQuestionUpsertArgs<ExtArgs>>): Prisma__ExamQuestionClient<$Result.GetResult<Prisma.$ExamQuestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExamQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamQuestionCountArgs} args - Arguments to filter ExamQuestions to count.
     * @example
     * // Count the number of ExamQuestions
     * const count = await prisma.examQuestion.count({
     *   where: {
     *     // ... the filter for the ExamQuestions we want to count
     *   }
     * })
    **/
    count<T extends ExamQuestionCountArgs>(
      args?: Subset<T, ExamQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExamQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamQuestionAggregateArgs>(args: Subset<T, ExamQuestionAggregateArgs>): Prisma.PrismaPromise<GetExamQuestionAggregateType<T>>

    /**
     * Group by ExamQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamQuestionGroupByArgs['orderBy'] }
        : { orderBy?: ExamQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExamQuestion model
   */
  readonly fields: ExamQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExamQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    exam<T extends ExamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamDefaultArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    question<T extends QuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuestionDefaultArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExamQuestion model
   */
  interface ExamQuestionFieldRefs {
    readonly id: FieldRef<"ExamQuestion", 'String'>
    readonly examId: FieldRef<"ExamQuestion", 'String'>
    readonly questionId: FieldRef<"ExamQuestion", 'String'>
    readonly order: FieldRef<"ExamQuestion", 'Int'>
    readonly marks: FieldRef<"ExamQuestion", 'Int'>
    readonly createdAt: FieldRef<"ExamQuestion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExamQuestion findUnique
   */
  export type ExamQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamQuestion
     */
    select?: ExamQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamQuestion
     */
    omit?: ExamQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ExamQuestion to fetch.
     */
    where: ExamQuestionWhereUniqueInput
  }

  /**
   * ExamQuestion findUniqueOrThrow
   */
  export type ExamQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamQuestion
     */
    select?: ExamQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamQuestion
     */
    omit?: ExamQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ExamQuestion to fetch.
     */
    where: ExamQuestionWhereUniqueInput
  }

  /**
   * ExamQuestion findFirst
   */
  export type ExamQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamQuestion
     */
    select?: ExamQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamQuestion
     */
    omit?: ExamQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ExamQuestion to fetch.
     */
    where?: ExamQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamQuestions to fetch.
     */
    orderBy?: ExamQuestionOrderByWithRelationInput | ExamQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamQuestions.
     */
    cursor?: ExamQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamQuestions.
     */
    distinct?: ExamQuestionScalarFieldEnum | ExamQuestionScalarFieldEnum[]
  }

  /**
   * ExamQuestion findFirstOrThrow
   */
  export type ExamQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamQuestion
     */
    select?: ExamQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamQuestion
     */
    omit?: ExamQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ExamQuestion to fetch.
     */
    where?: ExamQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamQuestions to fetch.
     */
    orderBy?: ExamQuestionOrderByWithRelationInput | ExamQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamQuestions.
     */
    cursor?: ExamQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamQuestions.
     */
    distinct?: ExamQuestionScalarFieldEnum | ExamQuestionScalarFieldEnum[]
  }

  /**
   * ExamQuestion findMany
   */
  export type ExamQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamQuestion
     */
    select?: ExamQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamQuestion
     */
    omit?: ExamQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamQuestionInclude<ExtArgs> | null
    /**
     * Filter, which ExamQuestions to fetch.
     */
    where?: ExamQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamQuestions to fetch.
     */
    orderBy?: ExamQuestionOrderByWithRelationInput | ExamQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExamQuestions.
     */
    cursor?: ExamQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamQuestions.
     */
    skip?: number
    distinct?: ExamQuestionScalarFieldEnum | ExamQuestionScalarFieldEnum[]
  }

  /**
   * ExamQuestion create
   */
  export type ExamQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamQuestion
     */
    select?: ExamQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamQuestion
     */
    omit?: ExamQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a ExamQuestion.
     */
    data: XOR<ExamQuestionCreateInput, ExamQuestionUncheckedCreateInput>
  }

  /**
   * ExamQuestion createMany
   */
  export type ExamQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExamQuestions.
     */
    data: ExamQuestionCreateManyInput | ExamQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExamQuestion createManyAndReturn
   */
  export type ExamQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamQuestion
     */
    select?: ExamQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExamQuestion
     */
    omit?: ExamQuestionOmit<ExtArgs> | null
    /**
     * The data used to create many ExamQuestions.
     */
    data: ExamQuestionCreateManyInput | ExamQuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamQuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExamQuestion update
   */
  export type ExamQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamQuestion
     */
    select?: ExamQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamQuestion
     */
    omit?: ExamQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a ExamQuestion.
     */
    data: XOR<ExamQuestionUpdateInput, ExamQuestionUncheckedUpdateInput>
    /**
     * Choose, which ExamQuestion to update.
     */
    where: ExamQuestionWhereUniqueInput
  }

  /**
   * ExamQuestion updateMany
   */
  export type ExamQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExamQuestions.
     */
    data: XOR<ExamQuestionUpdateManyMutationInput, ExamQuestionUncheckedUpdateManyInput>
    /**
     * Filter which ExamQuestions to update
     */
    where?: ExamQuestionWhereInput
    /**
     * Limit how many ExamQuestions to update.
     */
    limit?: number
  }

  /**
   * ExamQuestion updateManyAndReturn
   */
  export type ExamQuestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamQuestion
     */
    select?: ExamQuestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExamQuestion
     */
    omit?: ExamQuestionOmit<ExtArgs> | null
    /**
     * The data used to update ExamQuestions.
     */
    data: XOR<ExamQuestionUpdateManyMutationInput, ExamQuestionUncheckedUpdateManyInput>
    /**
     * Filter which ExamQuestions to update
     */
    where?: ExamQuestionWhereInput
    /**
     * Limit how many ExamQuestions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamQuestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExamQuestion upsert
   */
  export type ExamQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamQuestion
     */
    select?: ExamQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamQuestion
     */
    omit?: ExamQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the ExamQuestion to update in case it exists.
     */
    where: ExamQuestionWhereUniqueInput
    /**
     * In case the ExamQuestion found by the `where` argument doesn't exist, create a new ExamQuestion with this data.
     */
    create: XOR<ExamQuestionCreateInput, ExamQuestionUncheckedCreateInput>
    /**
     * In case the ExamQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamQuestionUpdateInput, ExamQuestionUncheckedUpdateInput>
  }

  /**
   * ExamQuestion delete
   */
  export type ExamQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamQuestion
     */
    select?: ExamQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamQuestion
     */
    omit?: ExamQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamQuestionInclude<ExtArgs> | null
    /**
     * Filter which ExamQuestion to delete.
     */
    where: ExamQuestionWhereUniqueInput
  }

  /**
   * ExamQuestion deleteMany
   */
  export type ExamQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamQuestions to delete
     */
    where?: ExamQuestionWhereInput
    /**
     * Limit how many ExamQuestions to delete.
     */
    limit?: number
  }

  /**
   * ExamQuestion without action
   */
  export type ExamQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamQuestion
     */
    select?: ExamQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamQuestion
     */
    omit?: ExamQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamQuestionInclude<ExtArgs> | null
  }


  /**
   * Model ExamBooking
   */

  export type AggregateExamBooking = {
    _count: ExamBookingCountAggregateOutputType | null
    _avg: ExamBookingAvgAggregateOutputType | null
    _sum: ExamBookingSumAggregateOutputType | null
    _min: ExamBookingMinAggregateOutputType | null
    _max: ExamBookingMaxAggregateOutputType | null
  }

  export type ExamBookingAvgAggregateOutputType = {
    totalAmount: Decimal | null
  }

  export type ExamBookingSumAggregateOutputType = {
    totalAmount: Decimal | null
  }

  export type ExamBookingMinAggregateOutputType = {
    id: string | null
    userId: string | null
    examId: string | null
    bookingDate: Date | null
    scheduledAt: Date | null
    status: $Enums.BookingStatus | null
    paymentId: string | null
    totalAmount: Decimal | null
    currency: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamBookingMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    examId: string | null
    bookingDate: Date | null
    scheduledAt: Date | null
    status: $Enums.BookingStatus | null
    paymentId: string | null
    totalAmount: Decimal | null
    currency: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamBookingCountAggregateOutputType = {
    id: number
    userId: number
    examId: number
    bookingDate: number
    scheduledAt: number
    status: number
    paymentId: number
    totalAmount: number
    currency: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExamBookingAvgAggregateInputType = {
    totalAmount?: true
  }

  export type ExamBookingSumAggregateInputType = {
    totalAmount?: true
  }

  export type ExamBookingMinAggregateInputType = {
    id?: true
    userId?: true
    examId?: true
    bookingDate?: true
    scheduledAt?: true
    status?: true
    paymentId?: true
    totalAmount?: true
    currency?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamBookingMaxAggregateInputType = {
    id?: true
    userId?: true
    examId?: true
    bookingDate?: true
    scheduledAt?: true
    status?: true
    paymentId?: true
    totalAmount?: true
    currency?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamBookingCountAggregateInputType = {
    id?: true
    userId?: true
    examId?: true
    bookingDate?: true
    scheduledAt?: true
    status?: true
    paymentId?: true
    totalAmount?: true
    currency?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExamBookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamBooking to aggregate.
     */
    where?: ExamBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamBookings to fetch.
     */
    orderBy?: ExamBookingOrderByWithRelationInput | ExamBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExamBookings
    **/
    _count?: true | ExamBookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamBookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamBookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamBookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamBookingMaxAggregateInputType
  }

  export type GetExamBookingAggregateType<T extends ExamBookingAggregateArgs> = {
        [P in keyof T & keyof AggregateExamBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamBooking[P]>
      : GetScalarType<T[P], AggregateExamBooking[P]>
  }




  export type ExamBookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamBookingWhereInput
    orderBy?: ExamBookingOrderByWithAggregationInput | ExamBookingOrderByWithAggregationInput[]
    by: ExamBookingScalarFieldEnum[] | ExamBookingScalarFieldEnum
    having?: ExamBookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamBookingCountAggregateInputType | true
    _avg?: ExamBookingAvgAggregateInputType
    _sum?: ExamBookingSumAggregateInputType
    _min?: ExamBookingMinAggregateInputType
    _max?: ExamBookingMaxAggregateInputType
  }

  export type ExamBookingGroupByOutputType = {
    id: string
    userId: string
    examId: string
    bookingDate: Date
    scheduledAt: Date | null
    status: $Enums.BookingStatus
    paymentId: string | null
    totalAmount: Decimal
    currency: string
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ExamBookingCountAggregateOutputType | null
    _avg: ExamBookingAvgAggregateOutputType | null
    _sum: ExamBookingSumAggregateOutputType | null
    _min: ExamBookingMinAggregateOutputType | null
    _max: ExamBookingMaxAggregateOutputType | null
  }

  type GetExamBookingGroupByPayload<T extends ExamBookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamBookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamBookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamBookingGroupByOutputType[P]>
            : GetScalarType<T[P], ExamBookingGroupByOutputType[P]>
        }
      >
    >


  export type ExamBookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    examId?: boolean
    bookingDate?: boolean
    scheduledAt?: boolean
    status?: boolean
    paymentId?: boolean
    totalAmount?: boolean
    currency?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    payment?: boolean | ExamBooking$paymentArgs<ExtArgs>
    attempts?: boolean | ExamBooking$attemptsArgs<ExtArgs>
    _count?: boolean | ExamBookingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examBooking"]>

  export type ExamBookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    examId?: boolean
    bookingDate?: boolean
    scheduledAt?: boolean
    status?: boolean
    paymentId?: boolean
    totalAmount?: boolean
    currency?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examBooking"]>

  export type ExamBookingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    examId?: boolean
    bookingDate?: boolean
    scheduledAt?: boolean
    status?: boolean
    paymentId?: boolean
    totalAmount?: boolean
    currency?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examBooking"]>

  export type ExamBookingSelectScalar = {
    id?: boolean
    userId?: boolean
    examId?: boolean
    bookingDate?: boolean
    scheduledAt?: boolean
    status?: boolean
    paymentId?: boolean
    totalAmount?: boolean
    currency?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExamBookingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "examId" | "bookingDate" | "scheduledAt" | "status" | "paymentId" | "totalAmount" | "currency" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["examBooking"]>
  export type ExamBookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    payment?: boolean | ExamBooking$paymentArgs<ExtArgs>
    attempts?: boolean | ExamBooking$attemptsArgs<ExtArgs>
    _count?: boolean | ExamBookingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExamBookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
  }
  export type ExamBookingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
  }

  export type $ExamBookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExamBooking"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      exam: Prisma.$ExamPayload<ExtArgs>
      payment: Prisma.$PaymentPayload<ExtArgs> | null
      attempts: Prisma.$ExamAttemptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      examId: string
      bookingDate: Date
      scheduledAt: Date | null
      status: $Enums.BookingStatus
      paymentId: string | null
      totalAmount: Prisma.Decimal
      currency: string
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["examBooking"]>
    composites: {}
  }

  type ExamBookingGetPayload<S extends boolean | null | undefined | ExamBookingDefaultArgs> = $Result.GetResult<Prisma.$ExamBookingPayload, S>

  type ExamBookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExamBookingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExamBookingCountAggregateInputType | true
    }

  export interface ExamBookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExamBooking'], meta: { name: 'ExamBooking' } }
    /**
     * Find zero or one ExamBooking that matches the filter.
     * @param {ExamBookingFindUniqueArgs} args - Arguments to find a ExamBooking
     * @example
     * // Get one ExamBooking
     * const examBooking = await prisma.examBooking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamBookingFindUniqueArgs>(args: SelectSubset<T, ExamBookingFindUniqueArgs<ExtArgs>>): Prisma__ExamBookingClient<$Result.GetResult<Prisma.$ExamBookingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExamBooking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExamBookingFindUniqueOrThrowArgs} args - Arguments to find a ExamBooking
     * @example
     * // Get one ExamBooking
     * const examBooking = await prisma.examBooking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamBookingFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamBookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamBookingClient<$Result.GetResult<Prisma.$ExamBookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExamBooking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamBookingFindFirstArgs} args - Arguments to find a ExamBooking
     * @example
     * // Get one ExamBooking
     * const examBooking = await prisma.examBooking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamBookingFindFirstArgs>(args?: SelectSubset<T, ExamBookingFindFirstArgs<ExtArgs>>): Prisma__ExamBookingClient<$Result.GetResult<Prisma.$ExamBookingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExamBooking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamBookingFindFirstOrThrowArgs} args - Arguments to find a ExamBooking
     * @example
     * // Get one ExamBooking
     * const examBooking = await prisma.examBooking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamBookingFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamBookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamBookingClient<$Result.GetResult<Prisma.$ExamBookingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExamBookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamBookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExamBookings
     * const examBookings = await prisma.examBooking.findMany()
     * 
     * // Get first 10 ExamBookings
     * const examBookings = await prisma.examBooking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examBookingWithIdOnly = await prisma.examBooking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamBookingFindManyArgs>(args?: SelectSubset<T, ExamBookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamBookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExamBooking.
     * @param {ExamBookingCreateArgs} args - Arguments to create a ExamBooking.
     * @example
     * // Create one ExamBooking
     * const ExamBooking = await prisma.examBooking.create({
     *   data: {
     *     // ... data to create a ExamBooking
     *   }
     * })
     * 
     */
    create<T extends ExamBookingCreateArgs>(args: SelectSubset<T, ExamBookingCreateArgs<ExtArgs>>): Prisma__ExamBookingClient<$Result.GetResult<Prisma.$ExamBookingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExamBookings.
     * @param {ExamBookingCreateManyArgs} args - Arguments to create many ExamBookings.
     * @example
     * // Create many ExamBookings
     * const examBooking = await prisma.examBooking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamBookingCreateManyArgs>(args?: SelectSubset<T, ExamBookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExamBookings and returns the data saved in the database.
     * @param {ExamBookingCreateManyAndReturnArgs} args - Arguments to create many ExamBookings.
     * @example
     * // Create many ExamBookings
     * const examBooking = await prisma.examBooking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExamBookings and only return the `id`
     * const examBookingWithIdOnly = await prisma.examBooking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExamBookingCreateManyAndReturnArgs>(args?: SelectSubset<T, ExamBookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamBookingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExamBooking.
     * @param {ExamBookingDeleteArgs} args - Arguments to delete one ExamBooking.
     * @example
     * // Delete one ExamBooking
     * const ExamBooking = await prisma.examBooking.delete({
     *   where: {
     *     // ... filter to delete one ExamBooking
     *   }
     * })
     * 
     */
    delete<T extends ExamBookingDeleteArgs>(args: SelectSubset<T, ExamBookingDeleteArgs<ExtArgs>>): Prisma__ExamBookingClient<$Result.GetResult<Prisma.$ExamBookingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExamBooking.
     * @param {ExamBookingUpdateArgs} args - Arguments to update one ExamBooking.
     * @example
     * // Update one ExamBooking
     * const examBooking = await prisma.examBooking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamBookingUpdateArgs>(args: SelectSubset<T, ExamBookingUpdateArgs<ExtArgs>>): Prisma__ExamBookingClient<$Result.GetResult<Prisma.$ExamBookingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExamBookings.
     * @param {ExamBookingDeleteManyArgs} args - Arguments to filter ExamBookings to delete.
     * @example
     * // Delete a few ExamBookings
     * const { count } = await prisma.examBooking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamBookingDeleteManyArgs>(args?: SelectSubset<T, ExamBookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamBookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExamBookings
     * const examBooking = await prisma.examBooking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamBookingUpdateManyArgs>(args: SelectSubset<T, ExamBookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamBookings and returns the data updated in the database.
     * @param {ExamBookingUpdateManyAndReturnArgs} args - Arguments to update many ExamBookings.
     * @example
     * // Update many ExamBookings
     * const examBooking = await prisma.examBooking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExamBookings and only return the `id`
     * const examBookingWithIdOnly = await prisma.examBooking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExamBookingUpdateManyAndReturnArgs>(args: SelectSubset<T, ExamBookingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamBookingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExamBooking.
     * @param {ExamBookingUpsertArgs} args - Arguments to update or create a ExamBooking.
     * @example
     * // Update or create a ExamBooking
     * const examBooking = await prisma.examBooking.upsert({
     *   create: {
     *     // ... data to create a ExamBooking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExamBooking we want to update
     *   }
     * })
     */
    upsert<T extends ExamBookingUpsertArgs>(args: SelectSubset<T, ExamBookingUpsertArgs<ExtArgs>>): Prisma__ExamBookingClient<$Result.GetResult<Prisma.$ExamBookingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExamBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamBookingCountArgs} args - Arguments to filter ExamBookings to count.
     * @example
     * // Count the number of ExamBookings
     * const count = await prisma.examBooking.count({
     *   where: {
     *     // ... the filter for the ExamBookings we want to count
     *   }
     * })
    **/
    count<T extends ExamBookingCountArgs>(
      args?: Subset<T, ExamBookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamBookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExamBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamBookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamBookingAggregateArgs>(args: Subset<T, ExamBookingAggregateArgs>): Prisma.PrismaPromise<GetExamBookingAggregateType<T>>

    /**
     * Group by ExamBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamBookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamBookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamBookingGroupByArgs['orderBy'] }
        : { orderBy?: ExamBookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamBookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExamBooking model
   */
  readonly fields: ExamBookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExamBooking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamBookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    exam<T extends ExamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamDefaultArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payment<T extends ExamBooking$paymentArgs<ExtArgs> = {}>(args?: Subset<T, ExamBooking$paymentArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    attempts<T extends ExamBooking$attemptsArgs<ExtArgs> = {}>(args?: Subset<T, ExamBooking$attemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExamBooking model
   */
  interface ExamBookingFieldRefs {
    readonly id: FieldRef<"ExamBooking", 'String'>
    readonly userId: FieldRef<"ExamBooking", 'String'>
    readonly examId: FieldRef<"ExamBooking", 'String'>
    readonly bookingDate: FieldRef<"ExamBooking", 'DateTime'>
    readonly scheduledAt: FieldRef<"ExamBooking", 'DateTime'>
    readonly status: FieldRef<"ExamBooking", 'BookingStatus'>
    readonly paymentId: FieldRef<"ExamBooking", 'String'>
    readonly totalAmount: FieldRef<"ExamBooking", 'Decimal'>
    readonly currency: FieldRef<"ExamBooking", 'String'>
    readonly notes: FieldRef<"ExamBooking", 'String'>
    readonly createdAt: FieldRef<"ExamBooking", 'DateTime'>
    readonly updatedAt: FieldRef<"ExamBooking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExamBooking findUnique
   */
  export type ExamBookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamBooking
     */
    select?: ExamBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamBooking
     */
    omit?: ExamBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamBookingInclude<ExtArgs> | null
    /**
     * Filter, which ExamBooking to fetch.
     */
    where: ExamBookingWhereUniqueInput
  }

  /**
   * ExamBooking findUniqueOrThrow
   */
  export type ExamBookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamBooking
     */
    select?: ExamBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamBooking
     */
    omit?: ExamBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamBookingInclude<ExtArgs> | null
    /**
     * Filter, which ExamBooking to fetch.
     */
    where: ExamBookingWhereUniqueInput
  }

  /**
   * ExamBooking findFirst
   */
  export type ExamBookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamBooking
     */
    select?: ExamBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamBooking
     */
    omit?: ExamBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamBookingInclude<ExtArgs> | null
    /**
     * Filter, which ExamBooking to fetch.
     */
    where?: ExamBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamBookings to fetch.
     */
    orderBy?: ExamBookingOrderByWithRelationInput | ExamBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamBookings.
     */
    cursor?: ExamBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamBookings.
     */
    distinct?: ExamBookingScalarFieldEnum | ExamBookingScalarFieldEnum[]
  }

  /**
   * ExamBooking findFirstOrThrow
   */
  export type ExamBookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamBooking
     */
    select?: ExamBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamBooking
     */
    omit?: ExamBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamBookingInclude<ExtArgs> | null
    /**
     * Filter, which ExamBooking to fetch.
     */
    where?: ExamBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamBookings to fetch.
     */
    orderBy?: ExamBookingOrderByWithRelationInput | ExamBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamBookings.
     */
    cursor?: ExamBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamBookings.
     */
    distinct?: ExamBookingScalarFieldEnum | ExamBookingScalarFieldEnum[]
  }

  /**
   * ExamBooking findMany
   */
  export type ExamBookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamBooking
     */
    select?: ExamBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamBooking
     */
    omit?: ExamBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamBookingInclude<ExtArgs> | null
    /**
     * Filter, which ExamBookings to fetch.
     */
    where?: ExamBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamBookings to fetch.
     */
    orderBy?: ExamBookingOrderByWithRelationInput | ExamBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExamBookings.
     */
    cursor?: ExamBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamBookings.
     */
    skip?: number
    distinct?: ExamBookingScalarFieldEnum | ExamBookingScalarFieldEnum[]
  }

  /**
   * ExamBooking create
   */
  export type ExamBookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamBooking
     */
    select?: ExamBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamBooking
     */
    omit?: ExamBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamBookingInclude<ExtArgs> | null
    /**
     * The data needed to create a ExamBooking.
     */
    data: XOR<ExamBookingCreateInput, ExamBookingUncheckedCreateInput>
  }

  /**
   * ExamBooking createMany
   */
  export type ExamBookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExamBookings.
     */
    data: ExamBookingCreateManyInput | ExamBookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExamBooking createManyAndReturn
   */
  export type ExamBookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamBooking
     */
    select?: ExamBookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExamBooking
     */
    omit?: ExamBookingOmit<ExtArgs> | null
    /**
     * The data used to create many ExamBookings.
     */
    data: ExamBookingCreateManyInput | ExamBookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamBookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExamBooking update
   */
  export type ExamBookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamBooking
     */
    select?: ExamBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamBooking
     */
    omit?: ExamBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamBookingInclude<ExtArgs> | null
    /**
     * The data needed to update a ExamBooking.
     */
    data: XOR<ExamBookingUpdateInput, ExamBookingUncheckedUpdateInput>
    /**
     * Choose, which ExamBooking to update.
     */
    where: ExamBookingWhereUniqueInput
  }

  /**
   * ExamBooking updateMany
   */
  export type ExamBookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExamBookings.
     */
    data: XOR<ExamBookingUpdateManyMutationInput, ExamBookingUncheckedUpdateManyInput>
    /**
     * Filter which ExamBookings to update
     */
    where?: ExamBookingWhereInput
    /**
     * Limit how many ExamBookings to update.
     */
    limit?: number
  }

  /**
   * ExamBooking updateManyAndReturn
   */
  export type ExamBookingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamBooking
     */
    select?: ExamBookingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExamBooking
     */
    omit?: ExamBookingOmit<ExtArgs> | null
    /**
     * The data used to update ExamBookings.
     */
    data: XOR<ExamBookingUpdateManyMutationInput, ExamBookingUncheckedUpdateManyInput>
    /**
     * Filter which ExamBookings to update
     */
    where?: ExamBookingWhereInput
    /**
     * Limit how many ExamBookings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamBookingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExamBooking upsert
   */
  export type ExamBookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamBooking
     */
    select?: ExamBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamBooking
     */
    omit?: ExamBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamBookingInclude<ExtArgs> | null
    /**
     * The filter to search for the ExamBooking to update in case it exists.
     */
    where: ExamBookingWhereUniqueInput
    /**
     * In case the ExamBooking found by the `where` argument doesn't exist, create a new ExamBooking with this data.
     */
    create: XOR<ExamBookingCreateInput, ExamBookingUncheckedCreateInput>
    /**
     * In case the ExamBooking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamBookingUpdateInput, ExamBookingUncheckedUpdateInput>
  }

  /**
   * ExamBooking delete
   */
  export type ExamBookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamBooking
     */
    select?: ExamBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamBooking
     */
    omit?: ExamBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamBookingInclude<ExtArgs> | null
    /**
     * Filter which ExamBooking to delete.
     */
    where: ExamBookingWhereUniqueInput
  }

  /**
   * ExamBooking deleteMany
   */
  export type ExamBookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamBookings to delete
     */
    where?: ExamBookingWhereInput
    /**
     * Limit how many ExamBookings to delete.
     */
    limit?: number
  }

  /**
   * ExamBooking.payment
   */
  export type ExamBooking$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
  }

  /**
   * ExamBooking.attempts
   */
  export type ExamBooking$attemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAttempt
     */
    omit?: ExamAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    where?: ExamAttemptWhereInput
    orderBy?: ExamAttemptOrderByWithRelationInput | ExamAttemptOrderByWithRelationInput[]
    cursor?: ExamAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamAttemptScalarFieldEnum | ExamAttemptScalarFieldEnum[]
  }

  /**
   * ExamBooking without action
   */
  export type ExamBookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamBooking
     */
    select?: ExamBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamBooking
     */
    omit?: ExamBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamBookingInclude<ExtArgs> | null
  }


  /**
   * Model ExamAttempt
   */

  export type AggregateExamAttempt = {
    _count: ExamAttemptCountAggregateOutputType | null
    _avg: ExamAttemptAvgAggregateOutputType | null
    _sum: ExamAttemptSumAggregateOutputType | null
    _min: ExamAttemptMinAggregateOutputType | null
    _max: ExamAttemptMaxAggregateOutputType | null
  }

  export type ExamAttemptAvgAggregateOutputType = {
    totalMarks: number | null
    obtainedMarks: number | null
    percentage: number | null
    timeSpent: number | null
  }

  export type ExamAttemptSumAggregateOutputType = {
    totalMarks: number | null
    obtainedMarks: number | null
    percentage: number | null
    timeSpent: number | null
  }

  export type ExamAttemptMinAggregateOutputType = {
    id: string | null
    userId: string | null
    examId: string | null
    bookingId: string | null
    startedAt: Date | null
    completedAt: Date | null
    status: $Enums.AttemptStatus | null
    totalMarks: number | null
    obtainedMarks: number | null
    percentage: number | null
    isPassed: boolean | null
    timeSpent: number | null
    ipAddress: string | null
    userAgent: string | null
    isCheating: boolean | null
    cheatingReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamAttemptMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    examId: string | null
    bookingId: string | null
    startedAt: Date | null
    completedAt: Date | null
    status: $Enums.AttemptStatus | null
    totalMarks: number | null
    obtainedMarks: number | null
    percentage: number | null
    isPassed: boolean | null
    timeSpent: number | null
    ipAddress: string | null
    userAgent: string | null
    isCheating: boolean | null
    cheatingReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamAttemptCountAggregateOutputType = {
    id: number
    userId: number
    examId: number
    bookingId: number
    startedAt: number
    completedAt: number
    status: number
    totalMarks: number
    obtainedMarks: number
    percentage: number
    isPassed: number
    timeSpent: number
    ipAddress: number
    userAgent: number
    isCheating: number
    cheatingReason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExamAttemptAvgAggregateInputType = {
    totalMarks?: true
    obtainedMarks?: true
    percentage?: true
    timeSpent?: true
  }

  export type ExamAttemptSumAggregateInputType = {
    totalMarks?: true
    obtainedMarks?: true
    percentage?: true
    timeSpent?: true
  }

  export type ExamAttemptMinAggregateInputType = {
    id?: true
    userId?: true
    examId?: true
    bookingId?: true
    startedAt?: true
    completedAt?: true
    status?: true
    totalMarks?: true
    obtainedMarks?: true
    percentage?: true
    isPassed?: true
    timeSpent?: true
    ipAddress?: true
    userAgent?: true
    isCheating?: true
    cheatingReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamAttemptMaxAggregateInputType = {
    id?: true
    userId?: true
    examId?: true
    bookingId?: true
    startedAt?: true
    completedAt?: true
    status?: true
    totalMarks?: true
    obtainedMarks?: true
    percentage?: true
    isPassed?: true
    timeSpent?: true
    ipAddress?: true
    userAgent?: true
    isCheating?: true
    cheatingReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamAttemptCountAggregateInputType = {
    id?: true
    userId?: true
    examId?: true
    bookingId?: true
    startedAt?: true
    completedAt?: true
    status?: true
    totalMarks?: true
    obtainedMarks?: true
    percentage?: true
    isPassed?: true
    timeSpent?: true
    ipAddress?: true
    userAgent?: true
    isCheating?: true
    cheatingReason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExamAttemptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamAttempt to aggregate.
     */
    where?: ExamAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamAttempts to fetch.
     */
    orderBy?: ExamAttemptOrderByWithRelationInput | ExamAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExamAttempts
    **/
    _count?: true | ExamAttemptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamAttemptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamAttemptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamAttemptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamAttemptMaxAggregateInputType
  }

  export type GetExamAttemptAggregateType<T extends ExamAttemptAggregateArgs> = {
        [P in keyof T & keyof AggregateExamAttempt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamAttempt[P]>
      : GetScalarType<T[P], AggregateExamAttempt[P]>
  }




  export type ExamAttemptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamAttemptWhereInput
    orderBy?: ExamAttemptOrderByWithAggregationInput | ExamAttemptOrderByWithAggregationInput[]
    by: ExamAttemptScalarFieldEnum[] | ExamAttemptScalarFieldEnum
    having?: ExamAttemptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamAttemptCountAggregateInputType | true
    _avg?: ExamAttemptAvgAggregateInputType
    _sum?: ExamAttemptSumAggregateInputType
    _min?: ExamAttemptMinAggregateInputType
    _max?: ExamAttemptMaxAggregateInputType
  }

  export type ExamAttemptGroupByOutputType = {
    id: string
    userId: string
    examId: string
    bookingId: string | null
    startedAt: Date
    completedAt: Date | null
    status: $Enums.AttemptStatus
    totalMarks: number
    obtainedMarks: number
    percentage: number
    isPassed: boolean
    timeSpent: number | null
    ipAddress: string | null
    userAgent: string | null
    isCheating: boolean
    cheatingReason: string | null
    createdAt: Date
    updatedAt: Date
    _count: ExamAttemptCountAggregateOutputType | null
    _avg: ExamAttemptAvgAggregateOutputType | null
    _sum: ExamAttemptSumAggregateOutputType | null
    _min: ExamAttemptMinAggregateOutputType | null
    _max: ExamAttemptMaxAggregateOutputType | null
  }

  type GetExamAttemptGroupByPayload<T extends ExamAttemptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamAttemptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamAttemptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamAttemptGroupByOutputType[P]>
            : GetScalarType<T[P], ExamAttemptGroupByOutputType[P]>
        }
      >
    >


  export type ExamAttemptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    examId?: boolean
    bookingId?: boolean
    startedAt?: boolean
    completedAt?: boolean
    status?: boolean
    totalMarks?: boolean
    obtainedMarks?: boolean
    percentage?: boolean
    isPassed?: boolean
    timeSpent?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    isCheating?: boolean
    cheatingReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    booking?: boolean | ExamAttempt$bookingArgs<ExtArgs>
    responses?: boolean | ExamAttempt$responsesArgs<ExtArgs>
    questionScores?: boolean | ExamAttempt$questionScoresArgs<ExtArgs>
    examScore?: boolean | ExamAttempt$examScoreArgs<ExtArgs>
    certificate?: boolean | ExamAttempt$certificateArgs<ExtArgs>
    _count?: boolean | ExamAttemptCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examAttempt"]>

  export type ExamAttemptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    examId?: boolean
    bookingId?: boolean
    startedAt?: boolean
    completedAt?: boolean
    status?: boolean
    totalMarks?: boolean
    obtainedMarks?: boolean
    percentage?: boolean
    isPassed?: boolean
    timeSpent?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    isCheating?: boolean
    cheatingReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    booking?: boolean | ExamAttempt$bookingArgs<ExtArgs>
  }, ExtArgs["result"]["examAttempt"]>

  export type ExamAttemptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    examId?: boolean
    bookingId?: boolean
    startedAt?: boolean
    completedAt?: boolean
    status?: boolean
    totalMarks?: boolean
    obtainedMarks?: boolean
    percentage?: boolean
    isPassed?: boolean
    timeSpent?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    isCheating?: boolean
    cheatingReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    booking?: boolean | ExamAttempt$bookingArgs<ExtArgs>
  }, ExtArgs["result"]["examAttempt"]>

  export type ExamAttemptSelectScalar = {
    id?: boolean
    userId?: boolean
    examId?: boolean
    bookingId?: boolean
    startedAt?: boolean
    completedAt?: boolean
    status?: boolean
    totalMarks?: boolean
    obtainedMarks?: boolean
    percentage?: boolean
    isPassed?: boolean
    timeSpent?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    isCheating?: boolean
    cheatingReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExamAttemptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "examId" | "bookingId" | "startedAt" | "completedAt" | "status" | "totalMarks" | "obtainedMarks" | "percentage" | "isPassed" | "timeSpent" | "ipAddress" | "userAgent" | "isCheating" | "cheatingReason" | "createdAt" | "updatedAt", ExtArgs["result"]["examAttempt"]>
  export type ExamAttemptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    booking?: boolean | ExamAttempt$bookingArgs<ExtArgs>
    responses?: boolean | ExamAttempt$responsesArgs<ExtArgs>
    questionScores?: boolean | ExamAttempt$questionScoresArgs<ExtArgs>
    examScore?: boolean | ExamAttempt$examScoreArgs<ExtArgs>
    certificate?: boolean | ExamAttempt$certificateArgs<ExtArgs>
    _count?: boolean | ExamAttemptCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExamAttemptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    booking?: boolean | ExamAttempt$bookingArgs<ExtArgs>
  }
  export type ExamAttemptIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    booking?: boolean | ExamAttempt$bookingArgs<ExtArgs>
  }

  export type $ExamAttemptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExamAttempt"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      exam: Prisma.$ExamPayload<ExtArgs>
      booking: Prisma.$ExamBookingPayload<ExtArgs> | null
      responses: Prisma.$QuestionResponsePayload<ExtArgs>[]
      questionScores: Prisma.$QuestionScorePayload<ExtArgs>[]
      examScore: Prisma.$ExamScorePayload<ExtArgs> | null
      certificate: Prisma.$CertificatePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      examId: string
      bookingId: string | null
      startedAt: Date
      completedAt: Date | null
      status: $Enums.AttemptStatus
      totalMarks: number
      obtainedMarks: number
      percentage: number
      isPassed: boolean
      timeSpent: number | null
      ipAddress: string | null
      userAgent: string | null
      isCheating: boolean
      cheatingReason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["examAttempt"]>
    composites: {}
  }

  type ExamAttemptGetPayload<S extends boolean | null | undefined | ExamAttemptDefaultArgs> = $Result.GetResult<Prisma.$ExamAttemptPayload, S>

  type ExamAttemptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExamAttemptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExamAttemptCountAggregateInputType | true
    }

  export interface ExamAttemptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExamAttempt'], meta: { name: 'ExamAttempt' } }
    /**
     * Find zero or one ExamAttempt that matches the filter.
     * @param {ExamAttemptFindUniqueArgs} args - Arguments to find a ExamAttempt
     * @example
     * // Get one ExamAttempt
     * const examAttempt = await prisma.examAttempt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamAttemptFindUniqueArgs>(args: SelectSubset<T, ExamAttemptFindUniqueArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExamAttempt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExamAttemptFindUniqueOrThrowArgs} args - Arguments to find a ExamAttempt
     * @example
     * // Get one ExamAttempt
     * const examAttempt = await prisma.examAttempt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamAttemptFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamAttemptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExamAttempt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAttemptFindFirstArgs} args - Arguments to find a ExamAttempt
     * @example
     * // Get one ExamAttempt
     * const examAttempt = await prisma.examAttempt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamAttemptFindFirstArgs>(args?: SelectSubset<T, ExamAttemptFindFirstArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExamAttempt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAttemptFindFirstOrThrowArgs} args - Arguments to find a ExamAttempt
     * @example
     * // Get one ExamAttempt
     * const examAttempt = await prisma.examAttempt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamAttemptFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamAttemptFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExamAttempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAttemptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExamAttempts
     * const examAttempts = await prisma.examAttempt.findMany()
     * 
     * // Get first 10 ExamAttempts
     * const examAttempts = await prisma.examAttempt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examAttemptWithIdOnly = await prisma.examAttempt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamAttemptFindManyArgs>(args?: SelectSubset<T, ExamAttemptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExamAttempt.
     * @param {ExamAttemptCreateArgs} args - Arguments to create a ExamAttempt.
     * @example
     * // Create one ExamAttempt
     * const ExamAttempt = await prisma.examAttempt.create({
     *   data: {
     *     // ... data to create a ExamAttempt
     *   }
     * })
     * 
     */
    create<T extends ExamAttemptCreateArgs>(args: SelectSubset<T, ExamAttemptCreateArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExamAttempts.
     * @param {ExamAttemptCreateManyArgs} args - Arguments to create many ExamAttempts.
     * @example
     * // Create many ExamAttempts
     * const examAttempt = await prisma.examAttempt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamAttemptCreateManyArgs>(args?: SelectSubset<T, ExamAttemptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExamAttempts and returns the data saved in the database.
     * @param {ExamAttemptCreateManyAndReturnArgs} args - Arguments to create many ExamAttempts.
     * @example
     * // Create many ExamAttempts
     * const examAttempt = await prisma.examAttempt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExamAttempts and only return the `id`
     * const examAttemptWithIdOnly = await prisma.examAttempt.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExamAttemptCreateManyAndReturnArgs>(args?: SelectSubset<T, ExamAttemptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExamAttempt.
     * @param {ExamAttemptDeleteArgs} args - Arguments to delete one ExamAttempt.
     * @example
     * // Delete one ExamAttempt
     * const ExamAttempt = await prisma.examAttempt.delete({
     *   where: {
     *     // ... filter to delete one ExamAttempt
     *   }
     * })
     * 
     */
    delete<T extends ExamAttemptDeleteArgs>(args: SelectSubset<T, ExamAttemptDeleteArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExamAttempt.
     * @param {ExamAttemptUpdateArgs} args - Arguments to update one ExamAttempt.
     * @example
     * // Update one ExamAttempt
     * const examAttempt = await prisma.examAttempt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamAttemptUpdateArgs>(args: SelectSubset<T, ExamAttemptUpdateArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExamAttempts.
     * @param {ExamAttemptDeleteManyArgs} args - Arguments to filter ExamAttempts to delete.
     * @example
     * // Delete a few ExamAttempts
     * const { count } = await prisma.examAttempt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamAttemptDeleteManyArgs>(args?: SelectSubset<T, ExamAttemptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAttemptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExamAttempts
     * const examAttempt = await prisma.examAttempt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamAttemptUpdateManyArgs>(args: SelectSubset<T, ExamAttemptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamAttempts and returns the data updated in the database.
     * @param {ExamAttemptUpdateManyAndReturnArgs} args - Arguments to update many ExamAttempts.
     * @example
     * // Update many ExamAttempts
     * const examAttempt = await prisma.examAttempt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExamAttempts and only return the `id`
     * const examAttemptWithIdOnly = await prisma.examAttempt.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExamAttemptUpdateManyAndReturnArgs>(args: SelectSubset<T, ExamAttemptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExamAttempt.
     * @param {ExamAttemptUpsertArgs} args - Arguments to update or create a ExamAttempt.
     * @example
     * // Update or create a ExamAttempt
     * const examAttempt = await prisma.examAttempt.upsert({
     *   create: {
     *     // ... data to create a ExamAttempt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExamAttempt we want to update
     *   }
     * })
     */
    upsert<T extends ExamAttemptUpsertArgs>(args: SelectSubset<T, ExamAttemptUpsertArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExamAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAttemptCountArgs} args - Arguments to filter ExamAttempts to count.
     * @example
     * // Count the number of ExamAttempts
     * const count = await prisma.examAttempt.count({
     *   where: {
     *     // ... the filter for the ExamAttempts we want to count
     *   }
     * })
    **/
    count<T extends ExamAttemptCountArgs>(
      args?: Subset<T, ExamAttemptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamAttemptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExamAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAttemptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamAttemptAggregateArgs>(args: Subset<T, ExamAttemptAggregateArgs>): Prisma.PrismaPromise<GetExamAttemptAggregateType<T>>

    /**
     * Group by ExamAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAttemptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamAttemptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamAttemptGroupByArgs['orderBy'] }
        : { orderBy?: ExamAttemptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamAttemptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamAttemptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExamAttempt model
   */
  readonly fields: ExamAttemptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExamAttempt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamAttemptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    exam<T extends ExamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamDefaultArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    booking<T extends ExamAttempt$bookingArgs<ExtArgs> = {}>(args?: Subset<T, ExamAttempt$bookingArgs<ExtArgs>>): Prisma__ExamBookingClient<$Result.GetResult<Prisma.$ExamBookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    responses<T extends ExamAttempt$responsesArgs<ExtArgs> = {}>(args?: Subset<T, ExamAttempt$responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    questionScores<T extends ExamAttempt$questionScoresArgs<ExtArgs> = {}>(args?: Subset<T, ExamAttempt$questionScoresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionScorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    examScore<T extends ExamAttempt$examScoreArgs<ExtArgs> = {}>(args?: Subset<T, ExamAttempt$examScoreArgs<ExtArgs>>): Prisma__ExamScoreClient<$Result.GetResult<Prisma.$ExamScorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    certificate<T extends ExamAttempt$certificateArgs<ExtArgs> = {}>(args?: Subset<T, ExamAttempt$certificateArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExamAttempt model
   */
  interface ExamAttemptFieldRefs {
    readonly id: FieldRef<"ExamAttempt", 'String'>
    readonly userId: FieldRef<"ExamAttempt", 'String'>
    readonly examId: FieldRef<"ExamAttempt", 'String'>
    readonly bookingId: FieldRef<"ExamAttempt", 'String'>
    readonly startedAt: FieldRef<"ExamAttempt", 'DateTime'>
    readonly completedAt: FieldRef<"ExamAttempt", 'DateTime'>
    readonly status: FieldRef<"ExamAttempt", 'AttemptStatus'>
    readonly totalMarks: FieldRef<"ExamAttempt", 'Int'>
    readonly obtainedMarks: FieldRef<"ExamAttempt", 'Int'>
    readonly percentage: FieldRef<"ExamAttempt", 'Float'>
    readonly isPassed: FieldRef<"ExamAttempt", 'Boolean'>
    readonly timeSpent: FieldRef<"ExamAttempt", 'Int'>
    readonly ipAddress: FieldRef<"ExamAttempt", 'String'>
    readonly userAgent: FieldRef<"ExamAttempt", 'String'>
    readonly isCheating: FieldRef<"ExamAttempt", 'Boolean'>
    readonly cheatingReason: FieldRef<"ExamAttempt", 'String'>
    readonly createdAt: FieldRef<"ExamAttempt", 'DateTime'>
    readonly updatedAt: FieldRef<"ExamAttempt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExamAttempt findUnique
   */
  export type ExamAttemptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAttempt
     */
    omit?: ExamAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    /**
     * Filter, which ExamAttempt to fetch.
     */
    where: ExamAttemptWhereUniqueInput
  }

  /**
   * ExamAttempt findUniqueOrThrow
   */
  export type ExamAttemptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAttempt
     */
    omit?: ExamAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    /**
     * Filter, which ExamAttempt to fetch.
     */
    where: ExamAttemptWhereUniqueInput
  }

  /**
   * ExamAttempt findFirst
   */
  export type ExamAttemptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAttempt
     */
    omit?: ExamAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    /**
     * Filter, which ExamAttempt to fetch.
     */
    where?: ExamAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamAttempts to fetch.
     */
    orderBy?: ExamAttemptOrderByWithRelationInput | ExamAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamAttempts.
     */
    cursor?: ExamAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamAttempts.
     */
    distinct?: ExamAttemptScalarFieldEnum | ExamAttemptScalarFieldEnum[]
  }

  /**
   * ExamAttempt findFirstOrThrow
   */
  export type ExamAttemptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAttempt
     */
    omit?: ExamAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    /**
     * Filter, which ExamAttempt to fetch.
     */
    where?: ExamAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamAttempts to fetch.
     */
    orderBy?: ExamAttemptOrderByWithRelationInput | ExamAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamAttempts.
     */
    cursor?: ExamAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamAttempts.
     */
    distinct?: ExamAttemptScalarFieldEnum | ExamAttemptScalarFieldEnum[]
  }

  /**
   * ExamAttempt findMany
   */
  export type ExamAttemptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAttempt
     */
    omit?: ExamAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    /**
     * Filter, which ExamAttempts to fetch.
     */
    where?: ExamAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamAttempts to fetch.
     */
    orderBy?: ExamAttemptOrderByWithRelationInput | ExamAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExamAttempts.
     */
    cursor?: ExamAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamAttempts.
     */
    skip?: number
    distinct?: ExamAttemptScalarFieldEnum | ExamAttemptScalarFieldEnum[]
  }

  /**
   * ExamAttempt create
   */
  export type ExamAttemptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAttempt
     */
    omit?: ExamAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    /**
     * The data needed to create a ExamAttempt.
     */
    data: XOR<ExamAttemptCreateInput, ExamAttemptUncheckedCreateInput>
  }

  /**
   * ExamAttempt createMany
   */
  export type ExamAttemptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExamAttempts.
     */
    data: ExamAttemptCreateManyInput | ExamAttemptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExamAttempt createManyAndReturn
   */
  export type ExamAttemptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAttempt
     */
    omit?: ExamAttemptOmit<ExtArgs> | null
    /**
     * The data used to create many ExamAttempts.
     */
    data: ExamAttemptCreateManyInput | ExamAttemptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExamAttempt update
   */
  export type ExamAttemptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAttempt
     */
    omit?: ExamAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    /**
     * The data needed to update a ExamAttempt.
     */
    data: XOR<ExamAttemptUpdateInput, ExamAttemptUncheckedUpdateInput>
    /**
     * Choose, which ExamAttempt to update.
     */
    where: ExamAttemptWhereUniqueInput
  }

  /**
   * ExamAttempt updateMany
   */
  export type ExamAttemptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExamAttempts.
     */
    data: XOR<ExamAttemptUpdateManyMutationInput, ExamAttemptUncheckedUpdateManyInput>
    /**
     * Filter which ExamAttempts to update
     */
    where?: ExamAttemptWhereInput
    /**
     * Limit how many ExamAttempts to update.
     */
    limit?: number
  }

  /**
   * ExamAttempt updateManyAndReturn
   */
  export type ExamAttemptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAttempt
     */
    omit?: ExamAttemptOmit<ExtArgs> | null
    /**
     * The data used to update ExamAttempts.
     */
    data: XOR<ExamAttemptUpdateManyMutationInput, ExamAttemptUncheckedUpdateManyInput>
    /**
     * Filter which ExamAttempts to update
     */
    where?: ExamAttemptWhereInput
    /**
     * Limit how many ExamAttempts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExamAttempt upsert
   */
  export type ExamAttemptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAttempt
     */
    omit?: ExamAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    /**
     * The filter to search for the ExamAttempt to update in case it exists.
     */
    where: ExamAttemptWhereUniqueInput
    /**
     * In case the ExamAttempt found by the `where` argument doesn't exist, create a new ExamAttempt with this data.
     */
    create: XOR<ExamAttemptCreateInput, ExamAttemptUncheckedCreateInput>
    /**
     * In case the ExamAttempt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamAttemptUpdateInput, ExamAttemptUncheckedUpdateInput>
  }

  /**
   * ExamAttempt delete
   */
  export type ExamAttemptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAttempt
     */
    omit?: ExamAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
    /**
     * Filter which ExamAttempt to delete.
     */
    where: ExamAttemptWhereUniqueInput
  }

  /**
   * ExamAttempt deleteMany
   */
  export type ExamAttemptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamAttempts to delete
     */
    where?: ExamAttemptWhereInput
    /**
     * Limit how many ExamAttempts to delete.
     */
    limit?: number
  }

  /**
   * ExamAttempt.booking
   */
  export type ExamAttempt$bookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamBooking
     */
    select?: ExamBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamBooking
     */
    omit?: ExamBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamBookingInclude<ExtArgs> | null
    where?: ExamBookingWhereInput
  }

  /**
   * ExamAttempt.responses
   */
  export type ExamAttempt$responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionResponse
     */
    select?: QuestionResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionResponse
     */
    omit?: QuestionResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionResponseInclude<ExtArgs> | null
    where?: QuestionResponseWhereInput
    orderBy?: QuestionResponseOrderByWithRelationInput | QuestionResponseOrderByWithRelationInput[]
    cursor?: QuestionResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionResponseScalarFieldEnum | QuestionResponseScalarFieldEnum[]
  }

  /**
   * ExamAttempt.questionScores
   */
  export type ExamAttempt$questionScoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionScore
     */
    select?: QuestionScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionScore
     */
    omit?: QuestionScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionScoreInclude<ExtArgs> | null
    where?: QuestionScoreWhereInput
    orderBy?: QuestionScoreOrderByWithRelationInput | QuestionScoreOrderByWithRelationInput[]
    cursor?: QuestionScoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionScoreScalarFieldEnum | QuestionScoreScalarFieldEnum[]
  }

  /**
   * ExamAttempt.examScore
   */
  export type ExamAttempt$examScoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamScore
     */
    select?: ExamScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamScore
     */
    omit?: ExamScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScoreInclude<ExtArgs> | null
    where?: ExamScoreWhereInput
  }

  /**
   * ExamAttempt.certificate
   */
  export type ExamAttempt$certificateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    where?: CertificateWhereInput
  }

  /**
   * ExamAttempt without action
   */
  export type ExamAttemptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamAttempt
     */
    select?: ExamAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamAttempt
     */
    omit?: ExamAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamAttemptInclude<ExtArgs> | null
  }


  /**
   * Model QuestionResponse
   */

  export type AggregateQuestionResponse = {
    _count: QuestionResponseCountAggregateOutputType | null
    _avg: QuestionResponseAvgAggregateOutputType | null
    _sum: QuestionResponseSumAggregateOutputType | null
    _min: QuestionResponseMinAggregateOutputType | null
    _max: QuestionResponseMaxAggregateOutputType | null
  }

  export type QuestionResponseAvgAggregateOutputType = {
    marksObtained: number | null
    timeSpent: number | null
  }

  export type QuestionResponseSumAggregateOutputType = {
    marksObtained: number | null
    timeSpent: number | null
  }

  export type QuestionResponseMinAggregateOutputType = {
    id: string | null
    attemptId: string | null
    questionId: string | null
    userId: string | null
    isCorrect: boolean | null
    marksObtained: number | null
    timeSpent: number | null
    answeredAt: Date | null
    submittedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionResponseMaxAggregateOutputType = {
    id: string | null
    attemptId: string | null
    questionId: string | null
    userId: string | null
    isCorrect: boolean | null
    marksObtained: number | null
    timeSpent: number | null
    answeredAt: Date | null
    submittedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionResponseCountAggregateOutputType = {
    id: number
    attemptId: number
    questionId: number
    userId: number
    selectedOptions: number
    isCorrect: number
    marksObtained: number
    timeSpent: number
    answeredAt: number
    submittedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuestionResponseAvgAggregateInputType = {
    marksObtained?: true
    timeSpent?: true
  }

  export type QuestionResponseSumAggregateInputType = {
    marksObtained?: true
    timeSpent?: true
  }

  export type QuestionResponseMinAggregateInputType = {
    id?: true
    attemptId?: true
    questionId?: true
    userId?: true
    isCorrect?: true
    marksObtained?: true
    timeSpent?: true
    answeredAt?: true
    submittedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionResponseMaxAggregateInputType = {
    id?: true
    attemptId?: true
    questionId?: true
    userId?: true
    isCorrect?: true
    marksObtained?: true
    timeSpent?: true
    answeredAt?: true
    submittedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionResponseCountAggregateInputType = {
    id?: true
    attemptId?: true
    questionId?: true
    userId?: true
    selectedOptions?: true
    isCorrect?: true
    marksObtained?: true
    timeSpent?: true
    answeredAt?: true
    submittedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuestionResponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionResponse to aggregate.
     */
    where?: QuestionResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionResponses to fetch.
     */
    orderBy?: QuestionResponseOrderByWithRelationInput | QuestionResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestionResponses
    **/
    _count?: true | QuestionResponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionResponseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionResponseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionResponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionResponseMaxAggregateInputType
  }

  export type GetQuestionResponseAggregateType<T extends QuestionResponseAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionResponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionResponse[P]>
      : GetScalarType<T[P], AggregateQuestionResponse[P]>
  }




  export type QuestionResponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionResponseWhereInput
    orderBy?: QuestionResponseOrderByWithAggregationInput | QuestionResponseOrderByWithAggregationInput[]
    by: QuestionResponseScalarFieldEnum[] | QuestionResponseScalarFieldEnum
    having?: QuestionResponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionResponseCountAggregateInputType | true
    _avg?: QuestionResponseAvgAggregateInputType
    _sum?: QuestionResponseSumAggregateInputType
    _min?: QuestionResponseMinAggregateInputType
    _max?: QuestionResponseMaxAggregateInputType
  }

  export type QuestionResponseGroupByOutputType = {
    id: string
    attemptId: string
    questionId: string
    userId: string
    selectedOptions: string[]
    isCorrect: boolean | null
    marksObtained: number
    timeSpent: number | null
    answeredAt: Date
    submittedAt: Date
    createdAt: Date
    updatedAt: Date
    _count: QuestionResponseCountAggregateOutputType | null
    _avg: QuestionResponseAvgAggregateOutputType | null
    _sum: QuestionResponseSumAggregateOutputType | null
    _min: QuestionResponseMinAggregateOutputType | null
    _max: QuestionResponseMaxAggregateOutputType | null
  }

  type GetQuestionResponseGroupByPayload<T extends QuestionResponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionResponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionResponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionResponseGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionResponseGroupByOutputType[P]>
        }
      >
    >


  export type QuestionResponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attemptId?: boolean
    questionId?: boolean
    userId?: boolean
    selectedOptions?: boolean
    isCorrect?: boolean
    marksObtained?: boolean
    timeSpent?: boolean
    answeredAt?: boolean
    submittedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    attempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
    question?: boolean | QuestionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    score?: boolean | QuestionResponse$scoreArgs<ExtArgs>
  }, ExtArgs["result"]["questionResponse"]>

  export type QuestionResponseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attemptId?: boolean
    questionId?: boolean
    userId?: boolean
    selectedOptions?: boolean
    isCorrect?: boolean
    marksObtained?: boolean
    timeSpent?: boolean
    answeredAt?: boolean
    submittedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    attempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
    question?: boolean | QuestionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionResponse"]>

  export type QuestionResponseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attemptId?: boolean
    questionId?: boolean
    userId?: boolean
    selectedOptions?: boolean
    isCorrect?: boolean
    marksObtained?: boolean
    timeSpent?: boolean
    answeredAt?: boolean
    submittedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    attempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
    question?: boolean | QuestionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionResponse"]>

  export type QuestionResponseSelectScalar = {
    id?: boolean
    attemptId?: boolean
    questionId?: boolean
    userId?: boolean
    selectedOptions?: boolean
    isCorrect?: boolean
    marksObtained?: boolean
    timeSpent?: boolean
    answeredAt?: boolean
    submittedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuestionResponseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "attemptId" | "questionId" | "userId" | "selectedOptions" | "isCorrect" | "marksObtained" | "timeSpent" | "answeredAt" | "submittedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["questionResponse"]>
  export type QuestionResponseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
    question?: boolean | QuestionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    score?: boolean | QuestionResponse$scoreArgs<ExtArgs>
  }
  export type QuestionResponseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
    question?: boolean | QuestionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type QuestionResponseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
    question?: boolean | QuestionDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $QuestionResponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuestionResponse"
    objects: {
      attempt: Prisma.$ExamAttemptPayload<ExtArgs>
      question: Prisma.$QuestionPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      score: Prisma.$QuestionScorePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      attemptId: string
      questionId: string
      userId: string
      selectedOptions: string[]
      isCorrect: boolean | null
      marksObtained: number
      timeSpent: number | null
      answeredAt: Date
      submittedAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["questionResponse"]>
    composites: {}
  }

  type QuestionResponseGetPayload<S extends boolean | null | undefined | QuestionResponseDefaultArgs> = $Result.GetResult<Prisma.$QuestionResponsePayload, S>

  type QuestionResponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuestionResponseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuestionResponseCountAggregateInputType | true
    }

  export interface QuestionResponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuestionResponse'], meta: { name: 'QuestionResponse' } }
    /**
     * Find zero or one QuestionResponse that matches the filter.
     * @param {QuestionResponseFindUniqueArgs} args - Arguments to find a QuestionResponse
     * @example
     * // Get one QuestionResponse
     * const questionResponse = await prisma.questionResponse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionResponseFindUniqueArgs>(args: SelectSubset<T, QuestionResponseFindUniqueArgs<ExtArgs>>): Prisma__QuestionResponseClient<$Result.GetResult<Prisma.$QuestionResponsePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuestionResponse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuestionResponseFindUniqueOrThrowArgs} args - Arguments to find a QuestionResponse
     * @example
     * // Get one QuestionResponse
     * const questionResponse = await prisma.questionResponse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionResponseFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionResponseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionResponseClient<$Result.GetResult<Prisma.$QuestionResponsePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuestionResponse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionResponseFindFirstArgs} args - Arguments to find a QuestionResponse
     * @example
     * // Get one QuestionResponse
     * const questionResponse = await prisma.questionResponse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionResponseFindFirstArgs>(args?: SelectSubset<T, QuestionResponseFindFirstArgs<ExtArgs>>): Prisma__QuestionResponseClient<$Result.GetResult<Prisma.$QuestionResponsePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuestionResponse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionResponseFindFirstOrThrowArgs} args - Arguments to find a QuestionResponse
     * @example
     * // Get one QuestionResponse
     * const questionResponse = await prisma.questionResponse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionResponseFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionResponseFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionResponseClient<$Result.GetResult<Prisma.$QuestionResponsePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuestionResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionResponseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionResponses
     * const questionResponses = await prisma.questionResponse.findMany()
     * 
     * // Get first 10 QuestionResponses
     * const questionResponses = await prisma.questionResponse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionResponseWithIdOnly = await prisma.questionResponse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionResponseFindManyArgs>(args?: SelectSubset<T, QuestionResponseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuestionResponse.
     * @param {QuestionResponseCreateArgs} args - Arguments to create a QuestionResponse.
     * @example
     * // Create one QuestionResponse
     * const QuestionResponse = await prisma.questionResponse.create({
     *   data: {
     *     // ... data to create a QuestionResponse
     *   }
     * })
     * 
     */
    create<T extends QuestionResponseCreateArgs>(args: SelectSubset<T, QuestionResponseCreateArgs<ExtArgs>>): Prisma__QuestionResponseClient<$Result.GetResult<Prisma.$QuestionResponsePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuestionResponses.
     * @param {QuestionResponseCreateManyArgs} args - Arguments to create many QuestionResponses.
     * @example
     * // Create many QuestionResponses
     * const questionResponse = await prisma.questionResponse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionResponseCreateManyArgs>(args?: SelectSubset<T, QuestionResponseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuestionResponses and returns the data saved in the database.
     * @param {QuestionResponseCreateManyAndReturnArgs} args - Arguments to create many QuestionResponses.
     * @example
     * // Create many QuestionResponses
     * const questionResponse = await prisma.questionResponse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuestionResponses and only return the `id`
     * const questionResponseWithIdOnly = await prisma.questionResponse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestionResponseCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestionResponseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionResponsePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuestionResponse.
     * @param {QuestionResponseDeleteArgs} args - Arguments to delete one QuestionResponse.
     * @example
     * // Delete one QuestionResponse
     * const QuestionResponse = await prisma.questionResponse.delete({
     *   where: {
     *     // ... filter to delete one QuestionResponse
     *   }
     * })
     * 
     */
    delete<T extends QuestionResponseDeleteArgs>(args: SelectSubset<T, QuestionResponseDeleteArgs<ExtArgs>>): Prisma__QuestionResponseClient<$Result.GetResult<Prisma.$QuestionResponsePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuestionResponse.
     * @param {QuestionResponseUpdateArgs} args - Arguments to update one QuestionResponse.
     * @example
     * // Update one QuestionResponse
     * const questionResponse = await prisma.questionResponse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionResponseUpdateArgs>(args: SelectSubset<T, QuestionResponseUpdateArgs<ExtArgs>>): Prisma__QuestionResponseClient<$Result.GetResult<Prisma.$QuestionResponsePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuestionResponses.
     * @param {QuestionResponseDeleteManyArgs} args - Arguments to filter QuestionResponses to delete.
     * @example
     * // Delete a few QuestionResponses
     * const { count } = await prisma.questionResponse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionResponseDeleteManyArgs>(args?: SelectSubset<T, QuestionResponseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionResponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionResponses
     * const questionResponse = await prisma.questionResponse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionResponseUpdateManyArgs>(args: SelectSubset<T, QuestionResponseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionResponses and returns the data updated in the database.
     * @param {QuestionResponseUpdateManyAndReturnArgs} args - Arguments to update many QuestionResponses.
     * @example
     * // Update many QuestionResponses
     * const questionResponse = await prisma.questionResponse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuestionResponses and only return the `id`
     * const questionResponseWithIdOnly = await prisma.questionResponse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuestionResponseUpdateManyAndReturnArgs>(args: SelectSubset<T, QuestionResponseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionResponsePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuestionResponse.
     * @param {QuestionResponseUpsertArgs} args - Arguments to update or create a QuestionResponse.
     * @example
     * // Update or create a QuestionResponse
     * const questionResponse = await prisma.questionResponse.upsert({
     *   create: {
     *     // ... data to create a QuestionResponse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionResponse we want to update
     *   }
     * })
     */
    upsert<T extends QuestionResponseUpsertArgs>(args: SelectSubset<T, QuestionResponseUpsertArgs<ExtArgs>>): Prisma__QuestionResponseClient<$Result.GetResult<Prisma.$QuestionResponsePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuestionResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionResponseCountArgs} args - Arguments to filter QuestionResponses to count.
     * @example
     * // Count the number of QuestionResponses
     * const count = await prisma.questionResponse.count({
     *   where: {
     *     // ... the filter for the QuestionResponses we want to count
     *   }
     * })
    **/
    count<T extends QuestionResponseCountArgs>(
      args?: Subset<T, QuestionResponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionResponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionResponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionResponseAggregateArgs>(args: Subset<T, QuestionResponseAggregateArgs>): Prisma.PrismaPromise<GetQuestionResponseAggregateType<T>>

    /**
     * Group by QuestionResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionResponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionResponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionResponseGroupByArgs['orderBy'] }
        : { orderBy?: QuestionResponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionResponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionResponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuestionResponse model
   */
  readonly fields: QuestionResponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestionResponse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionResponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attempt<T extends ExamAttemptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamAttemptDefaultArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    question<T extends QuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuestionDefaultArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    score<T extends QuestionResponse$scoreArgs<ExtArgs> = {}>(args?: Subset<T, QuestionResponse$scoreArgs<ExtArgs>>): Prisma__QuestionScoreClient<$Result.GetResult<Prisma.$QuestionScorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuestionResponse model
   */
  interface QuestionResponseFieldRefs {
    readonly id: FieldRef<"QuestionResponse", 'String'>
    readonly attemptId: FieldRef<"QuestionResponse", 'String'>
    readonly questionId: FieldRef<"QuestionResponse", 'String'>
    readonly userId: FieldRef<"QuestionResponse", 'String'>
    readonly selectedOptions: FieldRef<"QuestionResponse", 'String[]'>
    readonly isCorrect: FieldRef<"QuestionResponse", 'Boolean'>
    readonly marksObtained: FieldRef<"QuestionResponse", 'Int'>
    readonly timeSpent: FieldRef<"QuestionResponse", 'Int'>
    readonly answeredAt: FieldRef<"QuestionResponse", 'DateTime'>
    readonly submittedAt: FieldRef<"QuestionResponse", 'DateTime'>
    readonly createdAt: FieldRef<"QuestionResponse", 'DateTime'>
    readonly updatedAt: FieldRef<"QuestionResponse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuestionResponse findUnique
   */
  export type QuestionResponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionResponse
     */
    select?: QuestionResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionResponse
     */
    omit?: QuestionResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionResponseInclude<ExtArgs> | null
    /**
     * Filter, which QuestionResponse to fetch.
     */
    where: QuestionResponseWhereUniqueInput
  }

  /**
   * QuestionResponse findUniqueOrThrow
   */
  export type QuestionResponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionResponse
     */
    select?: QuestionResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionResponse
     */
    omit?: QuestionResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionResponseInclude<ExtArgs> | null
    /**
     * Filter, which QuestionResponse to fetch.
     */
    where: QuestionResponseWhereUniqueInput
  }

  /**
   * QuestionResponse findFirst
   */
  export type QuestionResponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionResponse
     */
    select?: QuestionResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionResponse
     */
    omit?: QuestionResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionResponseInclude<ExtArgs> | null
    /**
     * Filter, which QuestionResponse to fetch.
     */
    where?: QuestionResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionResponses to fetch.
     */
    orderBy?: QuestionResponseOrderByWithRelationInput | QuestionResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionResponses.
     */
    cursor?: QuestionResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionResponses.
     */
    distinct?: QuestionResponseScalarFieldEnum | QuestionResponseScalarFieldEnum[]
  }

  /**
   * QuestionResponse findFirstOrThrow
   */
  export type QuestionResponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionResponse
     */
    select?: QuestionResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionResponse
     */
    omit?: QuestionResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionResponseInclude<ExtArgs> | null
    /**
     * Filter, which QuestionResponse to fetch.
     */
    where?: QuestionResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionResponses to fetch.
     */
    orderBy?: QuestionResponseOrderByWithRelationInput | QuestionResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionResponses.
     */
    cursor?: QuestionResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionResponses.
     */
    distinct?: QuestionResponseScalarFieldEnum | QuestionResponseScalarFieldEnum[]
  }

  /**
   * QuestionResponse findMany
   */
  export type QuestionResponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionResponse
     */
    select?: QuestionResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionResponse
     */
    omit?: QuestionResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionResponseInclude<ExtArgs> | null
    /**
     * Filter, which QuestionResponses to fetch.
     */
    where?: QuestionResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionResponses to fetch.
     */
    orderBy?: QuestionResponseOrderByWithRelationInput | QuestionResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestionResponses.
     */
    cursor?: QuestionResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionResponses.
     */
    skip?: number
    distinct?: QuestionResponseScalarFieldEnum | QuestionResponseScalarFieldEnum[]
  }

  /**
   * QuestionResponse create
   */
  export type QuestionResponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionResponse
     */
    select?: QuestionResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionResponse
     */
    omit?: QuestionResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionResponseInclude<ExtArgs> | null
    /**
     * The data needed to create a QuestionResponse.
     */
    data: XOR<QuestionResponseCreateInput, QuestionResponseUncheckedCreateInput>
  }

  /**
   * QuestionResponse createMany
   */
  export type QuestionResponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuestionResponses.
     */
    data: QuestionResponseCreateManyInput | QuestionResponseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuestionResponse createManyAndReturn
   */
  export type QuestionResponseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionResponse
     */
    select?: QuestionResponseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionResponse
     */
    omit?: QuestionResponseOmit<ExtArgs> | null
    /**
     * The data used to create many QuestionResponses.
     */
    data: QuestionResponseCreateManyInput | QuestionResponseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionResponseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuestionResponse update
   */
  export type QuestionResponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionResponse
     */
    select?: QuestionResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionResponse
     */
    omit?: QuestionResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionResponseInclude<ExtArgs> | null
    /**
     * The data needed to update a QuestionResponse.
     */
    data: XOR<QuestionResponseUpdateInput, QuestionResponseUncheckedUpdateInput>
    /**
     * Choose, which QuestionResponse to update.
     */
    where: QuestionResponseWhereUniqueInput
  }

  /**
   * QuestionResponse updateMany
   */
  export type QuestionResponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuestionResponses.
     */
    data: XOR<QuestionResponseUpdateManyMutationInput, QuestionResponseUncheckedUpdateManyInput>
    /**
     * Filter which QuestionResponses to update
     */
    where?: QuestionResponseWhereInput
    /**
     * Limit how many QuestionResponses to update.
     */
    limit?: number
  }

  /**
   * QuestionResponse updateManyAndReturn
   */
  export type QuestionResponseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionResponse
     */
    select?: QuestionResponseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionResponse
     */
    omit?: QuestionResponseOmit<ExtArgs> | null
    /**
     * The data used to update QuestionResponses.
     */
    data: XOR<QuestionResponseUpdateManyMutationInput, QuestionResponseUncheckedUpdateManyInput>
    /**
     * Filter which QuestionResponses to update
     */
    where?: QuestionResponseWhereInput
    /**
     * Limit how many QuestionResponses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionResponseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuestionResponse upsert
   */
  export type QuestionResponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionResponse
     */
    select?: QuestionResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionResponse
     */
    omit?: QuestionResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionResponseInclude<ExtArgs> | null
    /**
     * The filter to search for the QuestionResponse to update in case it exists.
     */
    where: QuestionResponseWhereUniqueInput
    /**
     * In case the QuestionResponse found by the `where` argument doesn't exist, create a new QuestionResponse with this data.
     */
    create: XOR<QuestionResponseCreateInput, QuestionResponseUncheckedCreateInput>
    /**
     * In case the QuestionResponse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionResponseUpdateInput, QuestionResponseUncheckedUpdateInput>
  }

  /**
   * QuestionResponse delete
   */
  export type QuestionResponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionResponse
     */
    select?: QuestionResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionResponse
     */
    omit?: QuestionResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionResponseInclude<ExtArgs> | null
    /**
     * Filter which QuestionResponse to delete.
     */
    where: QuestionResponseWhereUniqueInput
  }

  /**
   * QuestionResponse deleteMany
   */
  export type QuestionResponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionResponses to delete
     */
    where?: QuestionResponseWhereInput
    /**
     * Limit how many QuestionResponses to delete.
     */
    limit?: number
  }

  /**
   * QuestionResponse.score
   */
  export type QuestionResponse$scoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionScore
     */
    select?: QuestionScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionScore
     */
    omit?: QuestionScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionScoreInclude<ExtArgs> | null
    where?: QuestionScoreWhereInput
  }

  /**
   * QuestionResponse without action
   */
  export type QuestionResponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionResponse
     */
    select?: QuestionResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionResponse
     */
    omit?: QuestionResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionResponseInclude<ExtArgs> | null
  }


  /**
   * Model QuestionScore
   */

  export type AggregateQuestionScore = {
    _count: QuestionScoreCountAggregateOutputType | null
    _avg: QuestionScoreAvgAggregateOutputType | null
    _sum: QuestionScoreSumAggregateOutputType | null
    _min: QuestionScoreMinAggregateOutputType | null
    _max: QuestionScoreMaxAggregateOutputType | null
  }

  export type QuestionScoreAvgAggregateOutputType = {
    marksObtained: number | null
    maxMarks: number | null
    accuracy: number | null
    timeEfficiency: number | null
    difficultyBonus: number | null
    penalty: number | null
    responseTime: number | null
    attemptsCount: number | null
    confidenceLevel: number | null
  }

  export type QuestionScoreSumAggregateOutputType = {
    marksObtained: number | null
    maxMarks: number | null
    accuracy: number | null
    timeEfficiency: number | null
    difficultyBonus: number | null
    penalty: number | null
    responseTime: number | null
    attemptsCount: number | null
    confidenceLevel: number | null
  }

  export type QuestionScoreMinAggregateOutputType = {
    id: string | null
    responseId: string | null
    questionId: string | null
    attemptId: string | null
    userId: string | null
    isCorrect: boolean | null
    marksObtained: number | null
    maxMarks: number | null
    accuracy: number | null
    timeEfficiency: number | null
    difficultyBonus: number | null
    penalty: number | null
    responseTime: number | null
    attemptsCount: number | null
    confidenceLevel: number | null
    questionDifficulty: string | null
    scoredAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionScoreMaxAggregateOutputType = {
    id: string | null
    responseId: string | null
    questionId: string | null
    attemptId: string | null
    userId: string | null
    isCorrect: boolean | null
    marksObtained: number | null
    maxMarks: number | null
    accuracy: number | null
    timeEfficiency: number | null
    difficultyBonus: number | null
    penalty: number | null
    responseTime: number | null
    attemptsCount: number | null
    confidenceLevel: number | null
    questionDifficulty: string | null
    scoredAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionScoreCountAggregateOutputType = {
    id: number
    responseId: number
    questionId: number
    attemptId: number
    userId: number
    isCorrect: number
    marksObtained: number
    maxMarks: number
    accuracy: number
    timeEfficiency: number
    difficultyBonus: number
    penalty: number
    responseTime: number
    attemptsCount: number
    confidenceLevel: number
    questionDifficulty: number
    scoredAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuestionScoreAvgAggregateInputType = {
    marksObtained?: true
    maxMarks?: true
    accuracy?: true
    timeEfficiency?: true
    difficultyBonus?: true
    penalty?: true
    responseTime?: true
    attemptsCount?: true
    confidenceLevel?: true
  }

  export type QuestionScoreSumAggregateInputType = {
    marksObtained?: true
    maxMarks?: true
    accuracy?: true
    timeEfficiency?: true
    difficultyBonus?: true
    penalty?: true
    responseTime?: true
    attemptsCount?: true
    confidenceLevel?: true
  }

  export type QuestionScoreMinAggregateInputType = {
    id?: true
    responseId?: true
    questionId?: true
    attemptId?: true
    userId?: true
    isCorrect?: true
    marksObtained?: true
    maxMarks?: true
    accuracy?: true
    timeEfficiency?: true
    difficultyBonus?: true
    penalty?: true
    responseTime?: true
    attemptsCount?: true
    confidenceLevel?: true
    questionDifficulty?: true
    scoredAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionScoreMaxAggregateInputType = {
    id?: true
    responseId?: true
    questionId?: true
    attemptId?: true
    userId?: true
    isCorrect?: true
    marksObtained?: true
    maxMarks?: true
    accuracy?: true
    timeEfficiency?: true
    difficultyBonus?: true
    penalty?: true
    responseTime?: true
    attemptsCount?: true
    confidenceLevel?: true
    questionDifficulty?: true
    scoredAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionScoreCountAggregateInputType = {
    id?: true
    responseId?: true
    questionId?: true
    attemptId?: true
    userId?: true
    isCorrect?: true
    marksObtained?: true
    maxMarks?: true
    accuracy?: true
    timeEfficiency?: true
    difficultyBonus?: true
    penalty?: true
    responseTime?: true
    attemptsCount?: true
    confidenceLevel?: true
    questionDifficulty?: true
    scoredAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuestionScoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionScore to aggregate.
     */
    where?: QuestionScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionScores to fetch.
     */
    orderBy?: QuestionScoreOrderByWithRelationInput | QuestionScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestionScores
    **/
    _count?: true | QuestionScoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionScoreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionScoreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionScoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionScoreMaxAggregateInputType
  }

  export type GetQuestionScoreAggregateType<T extends QuestionScoreAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionScore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionScore[P]>
      : GetScalarType<T[P], AggregateQuestionScore[P]>
  }




  export type QuestionScoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionScoreWhereInput
    orderBy?: QuestionScoreOrderByWithAggregationInput | QuestionScoreOrderByWithAggregationInput[]
    by: QuestionScoreScalarFieldEnum[] | QuestionScoreScalarFieldEnum
    having?: QuestionScoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionScoreCountAggregateInputType | true
    _avg?: QuestionScoreAvgAggregateInputType
    _sum?: QuestionScoreSumAggregateInputType
    _min?: QuestionScoreMinAggregateInputType
    _max?: QuestionScoreMaxAggregateInputType
  }

  export type QuestionScoreGroupByOutputType = {
    id: string
    responseId: string
    questionId: string
    attemptId: string
    userId: string
    isCorrect: boolean
    marksObtained: number
    maxMarks: number
    accuracy: number
    timeEfficiency: number
    difficultyBonus: number
    penalty: number
    responseTime: number
    attemptsCount: number
    confidenceLevel: number
    questionDifficulty: string
    scoredAt: Date
    createdAt: Date
    updatedAt: Date
    _count: QuestionScoreCountAggregateOutputType | null
    _avg: QuestionScoreAvgAggregateOutputType | null
    _sum: QuestionScoreSumAggregateOutputType | null
    _min: QuestionScoreMinAggregateOutputType | null
    _max: QuestionScoreMaxAggregateOutputType | null
  }

  type GetQuestionScoreGroupByPayload<T extends QuestionScoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionScoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionScoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionScoreGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionScoreGroupByOutputType[P]>
        }
      >
    >


  export type QuestionScoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    responseId?: boolean
    questionId?: boolean
    attemptId?: boolean
    userId?: boolean
    isCorrect?: boolean
    marksObtained?: boolean
    maxMarks?: boolean
    accuracy?: boolean
    timeEfficiency?: boolean
    difficultyBonus?: boolean
    penalty?: boolean
    responseTime?: boolean
    attemptsCount?: boolean
    confidenceLevel?: boolean
    questionDifficulty?: boolean
    scoredAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    response?: boolean | QuestionResponseDefaultArgs<ExtArgs>
    question?: boolean | QuestionDefaultArgs<ExtArgs>
    attempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionScore"]>

  export type QuestionScoreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    responseId?: boolean
    questionId?: boolean
    attemptId?: boolean
    userId?: boolean
    isCorrect?: boolean
    marksObtained?: boolean
    maxMarks?: boolean
    accuracy?: boolean
    timeEfficiency?: boolean
    difficultyBonus?: boolean
    penalty?: boolean
    responseTime?: boolean
    attemptsCount?: boolean
    confidenceLevel?: boolean
    questionDifficulty?: boolean
    scoredAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    response?: boolean | QuestionResponseDefaultArgs<ExtArgs>
    question?: boolean | QuestionDefaultArgs<ExtArgs>
    attempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionScore"]>

  export type QuestionScoreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    responseId?: boolean
    questionId?: boolean
    attemptId?: boolean
    userId?: boolean
    isCorrect?: boolean
    marksObtained?: boolean
    maxMarks?: boolean
    accuracy?: boolean
    timeEfficiency?: boolean
    difficultyBonus?: boolean
    penalty?: boolean
    responseTime?: boolean
    attemptsCount?: boolean
    confidenceLevel?: boolean
    questionDifficulty?: boolean
    scoredAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    response?: boolean | QuestionResponseDefaultArgs<ExtArgs>
    question?: boolean | QuestionDefaultArgs<ExtArgs>
    attempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionScore"]>

  export type QuestionScoreSelectScalar = {
    id?: boolean
    responseId?: boolean
    questionId?: boolean
    attemptId?: boolean
    userId?: boolean
    isCorrect?: boolean
    marksObtained?: boolean
    maxMarks?: boolean
    accuracy?: boolean
    timeEfficiency?: boolean
    difficultyBonus?: boolean
    penalty?: boolean
    responseTime?: boolean
    attemptsCount?: boolean
    confidenceLevel?: boolean
    questionDifficulty?: boolean
    scoredAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuestionScoreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "responseId" | "questionId" | "attemptId" | "userId" | "isCorrect" | "marksObtained" | "maxMarks" | "accuracy" | "timeEfficiency" | "difficultyBonus" | "penalty" | "responseTime" | "attemptsCount" | "confidenceLevel" | "questionDifficulty" | "scoredAt" | "createdAt" | "updatedAt", ExtArgs["result"]["questionScore"]>
  export type QuestionScoreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    response?: boolean | QuestionResponseDefaultArgs<ExtArgs>
    question?: boolean | QuestionDefaultArgs<ExtArgs>
    attempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type QuestionScoreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    response?: boolean | QuestionResponseDefaultArgs<ExtArgs>
    question?: boolean | QuestionDefaultArgs<ExtArgs>
    attempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type QuestionScoreIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    response?: boolean | QuestionResponseDefaultArgs<ExtArgs>
    question?: boolean | QuestionDefaultArgs<ExtArgs>
    attempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $QuestionScorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuestionScore"
    objects: {
      response: Prisma.$QuestionResponsePayload<ExtArgs>
      question: Prisma.$QuestionPayload<ExtArgs>
      attempt: Prisma.$ExamAttemptPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      responseId: string
      questionId: string
      attemptId: string
      userId: string
      isCorrect: boolean
      marksObtained: number
      maxMarks: number
      accuracy: number
      timeEfficiency: number
      difficultyBonus: number
      penalty: number
      responseTime: number
      attemptsCount: number
      confidenceLevel: number
      questionDifficulty: string
      scoredAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["questionScore"]>
    composites: {}
  }

  type QuestionScoreGetPayload<S extends boolean | null | undefined | QuestionScoreDefaultArgs> = $Result.GetResult<Prisma.$QuestionScorePayload, S>

  type QuestionScoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuestionScoreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuestionScoreCountAggregateInputType | true
    }

  export interface QuestionScoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuestionScore'], meta: { name: 'QuestionScore' } }
    /**
     * Find zero or one QuestionScore that matches the filter.
     * @param {QuestionScoreFindUniqueArgs} args - Arguments to find a QuestionScore
     * @example
     * // Get one QuestionScore
     * const questionScore = await prisma.questionScore.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionScoreFindUniqueArgs>(args: SelectSubset<T, QuestionScoreFindUniqueArgs<ExtArgs>>): Prisma__QuestionScoreClient<$Result.GetResult<Prisma.$QuestionScorePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuestionScore that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuestionScoreFindUniqueOrThrowArgs} args - Arguments to find a QuestionScore
     * @example
     * // Get one QuestionScore
     * const questionScore = await prisma.questionScore.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionScoreFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionScoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionScoreClient<$Result.GetResult<Prisma.$QuestionScorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuestionScore that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionScoreFindFirstArgs} args - Arguments to find a QuestionScore
     * @example
     * // Get one QuestionScore
     * const questionScore = await prisma.questionScore.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionScoreFindFirstArgs>(args?: SelectSubset<T, QuestionScoreFindFirstArgs<ExtArgs>>): Prisma__QuestionScoreClient<$Result.GetResult<Prisma.$QuestionScorePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuestionScore that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionScoreFindFirstOrThrowArgs} args - Arguments to find a QuestionScore
     * @example
     * // Get one QuestionScore
     * const questionScore = await prisma.questionScore.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionScoreFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionScoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionScoreClient<$Result.GetResult<Prisma.$QuestionScorePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuestionScores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionScoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionScores
     * const questionScores = await prisma.questionScore.findMany()
     * 
     * // Get first 10 QuestionScores
     * const questionScores = await prisma.questionScore.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionScoreWithIdOnly = await prisma.questionScore.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionScoreFindManyArgs>(args?: SelectSubset<T, QuestionScoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionScorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuestionScore.
     * @param {QuestionScoreCreateArgs} args - Arguments to create a QuestionScore.
     * @example
     * // Create one QuestionScore
     * const QuestionScore = await prisma.questionScore.create({
     *   data: {
     *     // ... data to create a QuestionScore
     *   }
     * })
     * 
     */
    create<T extends QuestionScoreCreateArgs>(args: SelectSubset<T, QuestionScoreCreateArgs<ExtArgs>>): Prisma__QuestionScoreClient<$Result.GetResult<Prisma.$QuestionScorePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuestionScores.
     * @param {QuestionScoreCreateManyArgs} args - Arguments to create many QuestionScores.
     * @example
     * // Create many QuestionScores
     * const questionScore = await prisma.questionScore.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionScoreCreateManyArgs>(args?: SelectSubset<T, QuestionScoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuestionScores and returns the data saved in the database.
     * @param {QuestionScoreCreateManyAndReturnArgs} args - Arguments to create many QuestionScores.
     * @example
     * // Create many QuestionScores
     * const questionScore = await prisma.questionScore.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuestionScores and only return the `id`
     * const questionScoreWithIdOnly = await prisma.questionScore.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestionScoreCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestionScoreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionScorePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuestionScore.
     * @param {QuestionScoreDeleteArgs} args - Arguments to delete one QuestionScore.
     * @example
     * // Delete one QuestionScore
     * const QuestionScore = await prisma.questionScore.delete({
     *   where: {
     *     // ... filter to delete one QuestionScore
     *   }
     * })
     * 
     */
    delete<T extends QuestionScoreDeleteArgs>(args: SelectSubset<T, QuestionScoreDeleteArgs<ExtArgs>>): Prisma__QuestionScoreClient<$Result.GetResult<Prisma.$QuestionScorePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuestionScore.
     * @param {QuestionScoreUpdateArgs} args - Arguments to update one QuestionScore.
     * @example
     * // Update one QuestionScore
     * const questionScore = await prisma.questionScore.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionScoreUpdateArgs>(args: SelectSubset<T, QuestionScoreUpdateArgs<ExtArgs>>): Prisma__QuestionScoreClient<$Result.GetResult<Prisma.$QuestionScorePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuestionScores.
     * @param {QuestionScoreDeleteManyArgs} args - Arguments to filter QuestionScores to delete.
     * @example
     * // Delete a few QuestionScores
     * const { count } = await prisma.questionScore.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionScoreDeleteManyArgs>(args?: SelectSubset<T, QuestionScoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionScores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionScoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionScores
     * const questionScore = await prisma.questionScore.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionScoreUpdateManyArgs>(args: SelectSubset<T, QuestionScoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionScores and returns the data updated in the database.
     * @param {QuestionScoreUpdateManyAndReturnArgs} args - Arguments to update many QuestionScores.
     * @example
     * // Update many QuestionScores
     * const questionScore = await prisma.questionScore.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuestionScores and only return the `id`
     * const questionScoreWithIdOnly = await prisma.questionScore.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuestionScoreUpdateManyAndReturnArgs>(args: SelectSubset<T, QuestionScoreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionScorePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuestionScore.
     * @param {QuestionScoreUpsertArgs} args - Arguments to update or create a QuestionScore.
     * @example
     * // Update or create a QuestionScore
     * const questionScore = await prisma.questionScore.upsert({
     *   create: {
     *     // ... data to create a QuestionScore
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionScore we want to update
     *   }
     * })
     */
    upsert<T extends QuestionScoreUpsertArgs>(args: SelectSubset<T, QuestionScoreUpsertArgs<ExtArgs>>): Prisma__QuestionScoreClient<$Result.GetResult<Prisma.$QuestionScorePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuestionScores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionScoreCountArgs} args - Arguments to filter QuestionScores to count.
     * @example
     * // Count the number of QuestionScores
     * const count = await prisma.questionScore.count({
     *   where: {
     *     // ... the filter for the QuestionScores we want to count
     *   }
     * })
    **/
    count<T extends QuestionScoreCountArgs>(
      args?: Subset<T, QuestionScoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionScoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionScore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionScoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionScoreAggregateArgs>(args: Subset<T, QuestionScoreAggregateArgs>): Prisma.PrismaPromise<GetQuestionScoreAggregateType<T>>

    /**
     * Group by QuestionScore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionScoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionScoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionScoreGroupByArgs['orderBy'] }
        : { orderBy?: QuestionScoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionScoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionScoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuestionScore model
   */
  readonly fields: QuestionScoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestionScore.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionScoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    response<T extends QuestionResponseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuestionResponseDefaultArgs<ExtArgs>>): Prisma__QuestionResponseClient<$Result.GetResult<Prisma.$QuestionResponsePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    question<T extends QuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuestionDefaultArgs<ExtArgs>>): Prisma__QuestionClient<$Result.GetResult<Prisma.$QuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attempt<T extends ExamAttemptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamAttemptDefaultArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuestionScore model
   */
  interface QuestionScoreFieldRefs {
    readonly id: FieldRef<"QuestionScore", 'String'>
    readonly responseId: FieldRef<"QuestionScore", 'String'>
    readonly questionId: FieldRef<"QuestionScore", 'String'>
    readonly attemptId: FieldRef<"QuestionScore", 'String'>
    readonly userId: FieldRef<"QuestionScore", 'String'>
    readonly isCorrect: FieldRef<"QuestionScore", 'Boolean'>
    readonly marksObtained: FieldRef<"QuestionScore", 'Float'>
    readonly maxMarks: FieldRef<"QuestionScore", 'Float'>
    readonly accuracy: FieldRef<"QuestionScore", 'Float'>
    readonly timeEfficiency: FieldRef<"QuestionScore", 'Float'>
    readonly difficultyBonus: FieldRef<"QuestionScore", 'Float'>
    readonly penalty: FieldRef<"QuestionScore", 'Float'>
    readonly responseTime: FieldRef<"QuestionScore", 'Int'>
    readonly attemptsCount: FieldRef<"QuestionScore", 'Int'>
    readonly confidenceLevel: FieldRef<"QuestionScore", 'Float'>
    readonly questionDifficulty: FieldRef<"QuestionScore", 'String'>
    readonly scoredAt: FieldRef<"QuestionScore", 'DateTime'>
    readonly createdAt: FieldRef<"QuestionScore", 'DateTime'>
    readonly updatedAt: FieldRef<"QuestionScore", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuestionScore findUnique
   */
  export type QuestionScoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionScore
     */
    select?: QuestionScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionScore
     */
    omit?: QuestionScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionScoreInclude<ExtArgs> | null
    /**
     * Filter, which QuestionScore to fetch.
     */
    where: QuestionScoreWhereUniqueInput
  }

  /**
   * QuestionScore findUniqueOrThrow
   */
  export type QuestionScoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionScore
     */
    select?: QuestionScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionScore
     */
    omit?: QuestionScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionScoreInclude<ExtArgs> | null
    /**
     * Filter, which QuestionScore to fetch.
     */
    where: QuestionScoreWhereUniqueInput
  }

  /**
   * QuestionScore findFirst
   */
  export type QuestionScoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionScore
     */
    select?: QuestionScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionScore
     */
    omit?: QuestionScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionScoreInclude<ExtArgs> | null
    /**
     * Filter, which QuestionScore to fetch.
     */
    where?: QuestionScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionScores to fetch.
     */
    orderBy?: QuestionScoreOrderByWithRelationInput | QuestionScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionScores.
     */
    cursor?: QuestionScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionScores.
     */
    distinct?: QuestionScoreScalarFieldEnum | QuestionScoreScalarFieldEnum[]
  }

  /**
   * QuestionScore findFirstOrThrow
   */
  export type QuestionScoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionScore
     */
    select?: QuestionScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionScore
     */
    omit?: QuestionScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionScoreInclude<ExtArgs> | null
    /**
     * Filter, which QuestionScore to fetch.
     */
    where?: QuestionScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionScores to fetch.
     */
    orderBy?: QuestionScoreOrderByWithRelationInput | QuestionScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionScores.
     */
    cursor?: QuestionScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionScores.
     */
    distinct?: QuestionScoreScalarFieldEnum | QuestionScoreScalarFieldEnum[]
  }

  /**
   * QuestionScore findMany
   */
  export type QuestionScoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionScore
     */
    select?: QuestionScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionScore
     */
    omit?: QuestionScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionScoreInclude<ExtArgs> | null
    /**
     * Filter, which QuestionScores to fetch.
     */
    where?: QuestionScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionScores to fetch.
     */
    orderBy?: QuestionScoreOrderByWithRelationInput | QuestionScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestionScores.
     */
    cursor?: QuestionScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionScores.
     */
    skip?: number
    distinct?: QuestionScoreScalarFieldEnum | QuestionScoreScalarFieldEnum[]
  }

  /**
   * QuestionScore create
   */
  export type QuestionScoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionScore
     */
    select?: QuestionScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionScore
     */
    omit?: QuestionScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionScoreInclude<ExtArgs> | null
    /**
     * The data needed to create a QuestionScore.
     */
    data: XOR<QuestionScoreCreateInput, QuestionScoreUncheckedCreateInput>
  }

  /**
   * QuestionScore createMany
   */
  export type QuestionScoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuestionScores.
     */
    data: QuestionScoreCreateManyInput | QuestionScoreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuestionScore createManyAndReturn
   */
  export type QuestionScoreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionScore
     */
    select?: QuestionScoreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionScore
     */
    omit?: QuestionScoreOmit<ExtArgs> | null
    /**
     * The data used to create many QuestionScores.
     */
    data: QuestionScoreCreateManyInput | QuestionScoreCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionScoreIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuestionScore update
   */
  export type QuestionScoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionScore
     */
    select?: QuestionScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionScore
     */
    omit?: QuestionScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionScoreInclude<ExtArgs> | null
    /**
     * The data needed to update a QuestionScore.
     */
    data: XOR<QuestionScoreUpdateInput, QuestionScoreUncheckedUpdateInput>
    /**
     * Choose, which QuestionScore to update.
     */
    where: QuestionScoreWhereUniqueInput
  }

  /**
   * QuestionScore updateMany
   */
  export type QuestionScoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuestionScores.
     */
    data: XOR<QuestionScoreUpdateManyMutationInput, QuestionScoreUncheckedUpdateManyInput>
    /**
     * Filter which QuestionScores to update
     */
    where?: QuestionScoreWhereInput
    /**
     * Limit how many QuestionScores to update.
     */
    limit?: number
  }

  /**
   * QuestionScore updateManyAndReturn
   */
  export type QuestionScoreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionScore
     */
    select?: QuestionScoreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionScore
     */
    omit?: QuestionScoreOmit<ExtArgs> | null
    /**
     * The data used to update QuestionScores.
     */
    data: XOR<QuestionScoreUpdateManyMutationInput, QuestionScoreUncheckedUpdateManyInput>
    /**
     * Filter which QuestionScores to update
     */
    where?: QuestionScoreWhereInput
    /**
     * Limit how many QuestionScores to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionScoreIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuestionScore upsert
   */
  export type QuestionScoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionScore
     */
    select?: QuestionScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionScore
     */
    omit?: QuestionScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionScoreInclude<ExtArgs> | null
    /**
     * The filter to search for the QuestionScore to update in case it exists.
     */
    where: QuestionScoreWhereUniqueInput
    /**
     * In case the QuestionScore found by the `where` argument doesn't exist, create a new QuestionScore with this data.
     */
    create: XOR<QuestionScoreCreateInput, QuestionScoreUncheckedCreateInput>
    /**
     * In case the QuestionScore was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionScoreUpdateInput, QuestionScoreUncheckedUpdateInput>
  }

  /**
   * QuestionScore delete
   */
  export type QuestionScoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionScore
     */
    select?: QuestionScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionScore
     */
    omit?: QuestionScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionScoreInclude<ExtArgs> | null
    /**
     * Filter which QuestionScore to delete.
     */
    where: QuestionScoreWhereUniqueInput
  }

  /**
   * QuestionScore deleteMany
   */
  export type QuestionScoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionScores to delete
     */
    where?: QuestionScoreWhereInput
    /**
     * Limit how many QuestionScores to delete.
     */
    limit?: number
  }

  /**
   * QuestionScore without action
   */
  export type QuestionScoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionScore
     */
    select?: QuestionScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionScore
     */
    omit?: QuestionScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionScoreInclude<ExtArgs> | null
  }


  /**
   * Model ExamScore
   */

  export type AggregateExamScore = {
    _count: ExamScoreCountAggregateOutputType | null
    _avg: ExamScoreAvgAggregateOutputType | null
    _sum: ExamScoreSumAggregateOutputType | null
    _min: ExamScoreMinAggregateOutputType | null
    _max: ExamScoreMaxAggregateOutputType | null
  }

  export type ExamScoreAvgAggregateOutputType = {
    totalMarks: number | null
    maxMarks: number | null
    percentage: number | null
    correctAnswers: number | null
    wrongAnswers: number | null
    unanswered: number | null
    totalQuestions: number | null
    totalTimeSpent: number | null
    averageTimePerQuestion: number | null
    timeEfficiency: number | null
    easyCorrect: number | null
    easyTotal: number | null
    mediumCorrect: number | null
    mediumTotal: number | null
    hardCorrect: number | null
    hardTotal: number | null
    accuracy: number | null
    speedScore: number | null
    consistencyScore: number | null
    difficultyScore: number | null
    percentile: number | null
    rank: number | null
    improvement: number | null
  }

  export type ExamScoreSumAggregateOutputType = {
    totalMarks: number | null
    maxMarks: number | null
    percentage: number | null
    correctAnswers: number | null
    wrongAnswers: number | null
    unanswered: number | null
    totalQuestions: number | null
    totalTimeSpent: number | null
    averageTimePerQuestion: number | null
    timeEfficiency: number | null
    easyCorrect: number | null
    easyTotal: number | null
    mediumCorrect: number | null
    mediumTotal: number | null
    hardCorrect: number | null
    hardTotal: number | null
    accuracy: number | null
    speedScore: number | null
    consistencyScore: number | null
    difficultyScore: number | null
    percentile: number | null
    rank: number | null
    improvement: number | null
  }

  export type ExamScoreMinAggregateOutputType = {
    id: string | null
    attemptId: string | null
    examId: string | null
    userId: string | null
    totalMarks: number | null
    maxMarks: number | null
    percentage: number | null
    grade: string | null
    correctAnswers: number | null
    wrongAnswers: number | null
    unanswered: number | null
    totalQuestions: number | null
    totalTimeSpent: number | null
    averageTimePerQuestion: number | null
    timeEfficiency: number | null
    easyCorrect: number | null
    easyTotal: number | null
    mediumCorrect: number | null
    mediumTotal: number | null
    hardCorrect: number | null
    hardTotal: number | null
    accuracy: number | null
    speedScore: number | null
    consistencyScore: number | null
    difficultyScore: number | null
    percentile: number | null
    rank: number | null
    improvement: number | null
    calculatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamScoreMaxAggregateOutputType = {
    id: string | null
    attemptId: string | null
    examId: string | null
    userId: string | null
    totalMarks: number | null
    maxMarks: number | null
    percentage: number | null
    grade: string | null
    correctAnswers: number | null
    wrongAnswers: number | null
    unanswered: number | null
    totalQuestions: number | null
    totalTimeSpent: number | null
    averageTimePerQuestion: number | null
    timeEfficiency: number | null
    easyCorrect: number | null
    easyTotal: number | null
    mediumCorrect: number | null
    mediumTotal: number | null
    hardCorrect: number | null
    hardTotal: number | null
    accuracy: number | null
    speedScore: number | null
    consistencyScore: number | null
    difficultyScore: number | null
    percentile: number | null
    rank: number | null
    improvement: number | null
    calculatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamScoreCountAggregateOutputType = {
    id: number
    attemptId: number
    examId: number
    userId: number
    totalMarks: number
    maxMarks: number
    percentage: number
    grade: number
    correctAnswers: number
    wrongAnswers: number
    unanswered: number
    totalQuestions: number
    totalTimeSpent: number
    averageTimePerQuestion: number
    timeEfficiency: number
    easyCorrect: number
    easyTotal: number
    mediumCorrect: number
    mediumTotal: number
    hardCorrect: number
    hardTotal: number
    accuracy: number
    speedScore: number
    consistencyScore: number
    difficultyScore: number
    percentile: number
    rank: number
    improvement: number
    calculatedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExamScoreAvgAggregateInputType = {
    totalMarks?: true
    maxMarks?: true
    percentage?: true
    correctAnswers?: true
    wrongAnswers?: true
    unanswered?: true
    totalQuestions?: true
    totalTimeSpent?: true
    averageTimePerQuestion?: true
    timeEfficiency?: true
    easyCorrect?: true
    easyTotal?: true
    mediumCorrect?: true
    mediumTotal?: true
    hardCorrect?: true
    hardTotal?: true
    accuracy?: true
    speedScore?: true
    consistencyScore?: true
    difficultyScore?: true
    percentile?: true
    rank?: true
    improvement?: true
  }

  export type ExamScoreSumAggregateInputType = {
    totalMarks?: true
    maxMarks?: true
    percentage?: true
    correctAnswers?: true
    wrongAnswers?: true
    unanswered?: true
    totalQuestions?: true
    totalTimeSpent?: true
    averageTimePerQuestion?: true
    timeEfficiency?: true
    easyCorrect?: true
    easyTotal?: true
    mediumCorrect?: true
    mediumTotal?: true
    hardCorrect?: true
    hardTotal?: true
    accuracy?: true
    speedScore?: true
    consistencyScore?: true
    difficultyScore?: true
    percentile?: true
    rank?: true
    improvement?: true
  }

  export type ExamScoreMinAggregateInputType = {
    id?: true
    attemptId?: true
    examId?: true
    userId?: true
    totalMarks?: true
    maxMarks?: true
    percentage?: true
    grade?: true
    correctAnswers?: true
    wrongAnswers?: true
    unanswered?: true
    totalQuestions?: true
    totalTimeSpent?: true
    averageTimePerQuestion?: true
    timeEfficiency?: true
    easyCorrect?: true
    easyTotal?: true
    mediumCorrect?: true
    mediumTotal?: true
    hardCorrect?: true
    hardTotal?: true
    accuracy?: true
    speedScore?: true
    consistencyScore?: true
    difficultyScore?: true
    percentile?: true
    rank?: true
    improvement?: true
    calculatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamScoreMaxAggregateInputType = {
    id?: true
    attemptId?: true
    examId?: true
    userId?: true
    totalMarks?: true
    maxMarks?: true
    percentage?: true
    grade?: true
    correctAnswers?: true
    wrongAnswers?: true
    unanswered?: true
    totalQuestions?: true
    totalTimeSpent?: true
    averageTimePerQuestion?: true
    timeEfficiency?: true
    easyCorrect?: true
    easyTotal?: true
    mediumCorrect?: true
    mediumTotal?: true
    hardCorrect?: true
    hardTotal?: true
    accuracy?: true
    speedScore?: true
    consistencyScore?: true
    difficultyScore?: true
    percentile?: true
    rank?: true
    improvement?: true
    calculatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamScoreCountAggregateInputType = {
    id?: true
    attemptId?: true
    examId?: true
    userId?: true
    totalMarks?: true
    maxMarks?: true
    percentage?: true
    grade?: true
    correctAnswers?: true
    wrongAnswers?: true
    unanswered?: true
    totalQuestions?: true
    totalTimeSpent?: true
    averageTimePerQuestion?: true
    timeEfficiency?: true
    easyCorrect?: true
    easyTotal?: true
    mediumCorrect?: true
    mediumTotal?: true
    hardCorrect?: true
    hardTotal?: true
    accuracy?: true
    speedScore?: true
    consistencyScore?: true
    difficultyScore?: true
    percentile?: true
    rank?: true
    improvement?: true
    calculatedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExamScoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamScore to aggregate.
     */
    where?: ExamScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamScores to fetch.
     */
    orderBy?: ExamScoreOrderByWithRelationInput | ExamScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExamScores
    **/
    _count?: true | ExamScoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamScoreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamScoreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamScoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamScoreMaxAggregateInputType
  }

  export type GetExamScoreAggregateType<T extends ExamScoreAggregateArgs> = {
        [P in keyof T & keyof AggregateExamScore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamScore[P]>
      : GetScalarType<T[P], AggregateExamScore[P]>
  }




  export type ExamScoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamScoreWhereInput
    orderBy?: ExamScoreOrderByWithAggregationInput | ExamScoreOrderByWithAggregationInput[]
    by: ExamScoreScalarFieldEnum[] | ExamScoreScalarFieldEnum
    having?: ExamScoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamScoreCountAggregateInputType | true
    _avg?: ExamScoreAvgAggregateInputType
    _sum?: ExamScoreSumAggregateInputType
    _min?: ExamScoreMinAggregateInputType
    _max?: ExamScoreMaxAggregateInputType
  }

  export type ExamScoreGroupByOutputType = {
    id: string
    attemptId: string
    examId: string
    userId: string
    totalMarks: number
    maxMarks: number
    percentage: number
    grade: string | null
    correctAnswers: number
    wrongAnswers: number
    unanswered: number
    totalQuestions: number
    totalTimeSpent: number
    averageTimePerQuestion: number
    timeEfficiency: number
    easyCorrect: number
    easyTotal: number
    mediumCorrect: number
    mediumTotal: number
    hardCorrect: number
    hardTotal: number
    accuracy: number
    speedScore: number
    consistencyScore: number
    difficultyScore: number
    percentile: number | null
    rank: number | null
    improvement: number | null
    calculatedAt: Date
    createdAt: Date
    updatedAt: Date
    _count: ExamScoreCountAggregateOutputType | null
    _avg: ExamScoreAvgAggregateOutputType | null
    _sum: ExamScoreSumAggregateOutputType | null
    _min: ExamScoreMinAggregateOutputType | null
    _max: ExamScoreMaxAggregateOutputType | null
  }

  type GetExamScoreGroupByPayload<T extends ExamScoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamScoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamScoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamScoreGroupByOutputType[P]>
            : GetScalarType<T[P], ExamScoreGroupByOutputType[P]>
        }
      >
    >


  export type ExamScoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attemptId?: boolean
    examId?: boolean
    userId?: boolean
    totalMarks?: boolean
    maxMarks?: boolean
    percentage?: boolean
    grade?: boolean
    correctAnswers?: boolean
    wrongAnswers?: boolean
    unanswered?: boolean
    totalQuestions?: boolean
    totalTimeSpent?: boolean
    averageTimePerQuestion?: boolean
    timeEfficiency?: boolean
    easyCorrect?: boolean
    easyTotal?: boolean
    mediumCorrect?: boolean
    mediumTotal?: boolean
    hardCorrect?: boolean
    hardTotal?: boolean
    accuracy?: boolean
    speedScore?: boolean
    consistencyScore?: boolean
    difficultyScore?: boolean
    percentile?: boolean
    rank?: boolean
    improvement?: boolean
    calculatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    attempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examScore"]>

  export type ExamScoreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attemptId?: boolean
    examId?: boolean
    userId?: boolean
    totalMarks?: boolean
    maxMarks?: boolean
    percentage?: boolean
    grade?: boolean
    correctAnswers?: boolean
    wrongAnswers?: boolean
    unanswered?: boolean
    totalQuestions?: boolean
    totalTimeSpent?: boolean
    averageTimePerQuestion?: boolean
    timeEfficiency?: boolean
    easyCorrect?: boolean
    easyTotal?: boolean
    mediumCorrect?: boolean
    mediumTotal?: boolean
    hardCorrect?: boolean
    hardTotal?: boolean
    accuracy?: boolean
    speedScore?: boolean
    consistencyScore?: boolean
    difficultyScore?: boolean
    percentile?: boolean
    rank?: boolean
    improvement?: boolean
    calculatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    attempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examScore"]>

  export type ExamScoreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attemptId?: boolean
    examId?: boolean
    userId?: boolean
    totalMarks?: boolean
    maxMarks?: boolean
    percentage?: boolean
    grade?: boolean
    correctAnswers?: boolean
    wrongAnswers?: boolean
    unanswered?: boolean
    totalQuestions?: boolean
    totalTimeSpent?: boolean
    averageTimePerQuestion?: boolean
    timeEfficiency?: boolean
    easyCorrect?: boolean
    easyTotal?: boolean
    mediumCorrect?: boolean
    mediumTotal?: boolean
    hardCorrect?: boolean
    hardTotal?: boolean
    accuracy?: boolean
    speedScore?: boolean
    consistencyScore?: boolean
    difficultyScore?: boolean
    percentile?: boolean
    rank?: boolean
    improvement?: boolean
    calculatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    attempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examScore"]>

  export type ExamScoreSelectScalar = {
    id?: boolean
    attemptId?: boolean
    examId?: boolean
    userId?: boolean
    totalMarks?: boolean
    maxMarks?: boolean
    percentage?: boolean
    grade?: boolean
    correctAnswers?: boolean
    wrongAnswers?: boolean
    unanswered?: boolean
    totalQuestions?: boolean
    totalTimeSpent?: boolean
    averageTimePerQuestion?: boolean
    timeEfficiency?: boolean
    easyCorrect?: boolean
    easyTotal?: boolean
    mediumCorrect?: boolean
    mediumTotal?: boolean
    hardCorrect?: boolean
    hardTotal?: boolean
    accuracy?: boolean
    speedScore?: boolean
    consistencyScore?: boolean
    difficultyScore?: boolean
    percentile?: boolean
    rank?: boolean
    improvement?: boolean
    calculatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExamScoreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "attemptId" | "examId" | "userId" | "totalMarks" | "maxMarks" | "percentage" | "grade" | "correctAnswers" | "wrongAnswers" | "unanswered" | "totalQuestions" | "totalTimeSpent" | "averageTimePerQuestion" | "timeEfficiency" | "easyCorrect" | "easyTotal" | "mediumCorrect" | "mediumTotal" | "hardCorrect" | "hardTotal" | "accuracy" | "speedScore" | "consistencyScore" | "difficultyScore" | "percentile" | "rank" | "improvement" | "calculatedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["examScore"]>
  export type ExamScoreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ExamScoreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ExamScoreIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ExamScorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExamScore"
    objects: {
      attempt: Prisma.$ExamAttemptPayload<ExtArgs>
      exam: Prisma.$ExamPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      attemptId: string
      examId: string
      userId: string
      totalMarks: number
      maxMarks: number
      percentage: number
      grade: string | null
      correctAnswers: number
      wrongAnswers: number
      unanswered: number
      totalQuestions: number
      totalTimeSpent: number
      averageTimePerQuestion: number
      timeEfficiency: number
      easyCorrect: number
      easyTotal: number
      mediumCorrect: number
      mediumTotal: number
      hardCorrect: number
      hardTotal: number
      accuracy: number
      speedScore: number
      consistencyScore: number
      difficultyScore: number
      percentile: number | null
      rank: number | null
      improvement: number | null
      calculatedAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["examScore"]>
    composites: {}
  }

  type ExamScoreGetPayload<S extends boolean | null | undefined | ExamScoreDefaultArgs> = $Result.GetResult<Prisma.$ExamScorePayload, S>

  type ExamScoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExamScoreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExamScoreCountAggregateInputType | true
    }

  export interface ExamScoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExamScore'], meta: { name: 'ExamScore' } }
    /**
     * Find zero or one ExamScore that matches the filter.
     * @param {ExamScoreFindUniqueArgs} args - Arguments to find a ExamScore
     * @example
     * // Get one ExamScore
     * const examScore = await prisma.examScore.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamScoreFindUniqueArgs>(args: SelectSubset<T, ExamScoreFindUniqueArgs<ExtArgs>>): Prisma__ExamScoreClient<$Result.GetResult<Prisma.$ExamScorePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExamScore that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExamScoreFindUniqueOrThrowArgs} args - Arguments to find a ExamScore
     * @example
     * // Get one ExamScore
     * const examScore = await prisma.examScore.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamScoreFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamScoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamScoreClient<$Result.GetResult<Prisma.$ExamScorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExamScore that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamScoreFindFirstArgs} args - Arguments to find a ExamScore
     * @example
     * // Get one ExamScore
     * const examScore = await prisma.examScore.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamScoreFindFirstArgs>(args?: SelectSubset<T, ExamScoreFindFirstArgs<ExtArgs>>): Prisma__ExamScoreClient<$Result.GetResult<Prisma.$ExamScorePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExamScore that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamScoreFindFirstOrThrowArgs} args - Arguments to find a ExamScore
     * @example
     * // Get one ExamScore
     * const examScore = await prisma.examScore.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamScoreFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamScoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamScoreClient<$Result.GetResult<Prisma.$ExamScorePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExamScores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamScoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExamScores
     * const examScores = await prisma.examScore.findMany()
     * 
     * // Get first 10 ExamScores
     * const examScores = await prisma.examScore.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examScoreWithIdOnly = await prisma.examScore.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamScoreFindManyArgs>(args?: SelectSubset<T, ExamScoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamScorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExamScore.
     * @param {ExamScoreCreateArgs} args - Arguments to create a ExamScore.
     * @example
     * // Create one ExamScore
     * const ExamScore = await prisma.examScore.create({
     *   data: {
     *     // ... data to create a ExamScore
     *   }
     * })
     * 
     */
    create<T extends ExamScoreCreateArgs>(args: SelectSubset<T, ExamScoreCreateArgs<ExtArgs>>): Prisma__ExamScoreClient<$Result.GetResult<Prisma.$ExamScorePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExamScores.
     * @param {ExamScoreCreateManyArgs} args - Arguments to create many ExamScores.
     * @example
     * // Create many ExamScores
     * const examScore = await prisma.examScore.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamScoreCreateManyArgs>(args?: SelectSubset<T, ExamScoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExamScores and returns the data saved in the database.
     * @param {ExamScoreCreateManyAndReturnArgs} args - Arguments to create many ExamScores.
     * @example
     * // Create many ExamScores
     * const examScore = await prisma.examScore.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExamScores and only return the `id`
     * const examScoreWithIdOnly = await prisma.examScore.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExamScoreCreateManyAndReturnArgs>(args?: SelectSubset<T, ExamScoreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamScorePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExamScore.
     * @param {ExamScoreDeleteArgs} args - Arguments to delete one ExamScore.
     * @example
     * // Delete one ExamScore
     * const ExamScore = await prisma.examScore.delete({
     *   where: {
     *     // ... filter to delete one ExamScore
     *   }
     * })
     * 
     */
    delete<T extends ExamScoreDeleteArgs>(args: SelectSubset<T, ExamScoreDeleteArgs<ExtArgs>>): Prisma__ExamScoreClient<$Result.GetResult<Prisma.$ExamScorePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExamScore.
     * @param {ExamScoreUpdateArgs} args - Arguments to update one ExamScore.
     * @example
     * // Update one ExamScore
     * const examScore = await prisma.examScore.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamScoreUpdateArgs>(args: SelectSubset<T, ExamScoreUpdateArgs<ExtArgs>>): Prisma__ExamScoreClient<$Result.GetResult<Prisma.$ExamScorePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExamScores.
     * @param {ExamScoreDeleteManyArgs} args - Arguments to filter ExamScores to delete.
     * @example
     * // Delete a few ExamScores
     * const { count } = await prisma.examScore.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamScoreDeleteManyArgs>(args?: SelectSubset<T, ExamScoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamScores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamScoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExamScores
     * const examScore = await prisma.examScore.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamScoreUpdateManyArgs>(args: SelectSubset<T, ExamScoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamScores and returns the data updated in the database.
     * @param {ExamScoreUpdateManyAndReturnArgs} args - Arguments to update many ExamScores.
     * @example
     * // Update many ExamScores
     * const examScore = await prisma.examScore.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExamScores and only return the `id`
     * const examScoreWithIdOnly = await prisma.examScore.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExamScoreUpdateManyAndReturnArgs>(args: SelectSubset<T, ExamScoreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamScorePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExamScore.
     * @param {ExamScoreUpsertArgs} args - Arguments to update or create a ExamScore.
     * @example
     * // Update or create a ExamScore
     * const examScore = await prisma.examScore.upsert({
     *   create: {
     *     // ... data to create a ExamScore
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExamScore we want to update
     *   }
     * })
     */
    upsert<T extends ExamScoreUpsertArgs>(args: SelectSubset<T, ExamScoreUpsertArgs<ExtArgs>>): Prisma__ExamScoreClient<$Result.GetResult<Prisma.$ExamScorePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExamScores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamScoreCountArgs} args - Arguments to filter ExamScores to count.
     * @example
     * // Count the number of ExamScores
     * const count = await prisma.examScore.count({
     *   where: {
     *     // ... the filter for the ExamScores we want to count
     *   }
     * })
    **/
    count<T extends ExamScoreCountArgs>(
      args?: Subset<T, ExamScoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamScoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExamScore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamScoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamScoreAggregateArgs>(args: Subset<T, ExamScoreAggregateArgs>): Prisma.PrismaPromise<GetExamScoreAggregateType<T>>

    /**
     * Group by ExamScore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamScoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamScoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamScoreGroupByArgs['orderBy'] }
        : { orderBy?: ExamScoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamScoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamScoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExamScore model
   */
  readonly fields: ExamScoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExamScore.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamScoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attempt<T extends ExamAttemptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamAttemptDefaultArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    exam<T extends ExamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamDefaultArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExamScore model
   */
  interface ExamScoreFieldRefs {
    readonly id: FieldRef<"ExamScore", 'String'>
    readonly attemptId: FieldRef<"ExamScore", 'String'>
    readonly examId: FieldRef<"ExamScore", 'String'>
    readonly userId: FieldRef<"ExamScore", 'String'>
    readonly totalMarks: FieldRef<"ExamScore", 'Float'>
    readonly maxMarks: FieldRef<"ExamScore", 'Float'>
    readonly percentage: FieldRef<"ExamScore", 'Float'>
    readonly grade: FieldRef<"ExamScore", 'String'>
    readonly correctAnswers: FieldRef<"ExamScore", 'Int'>
    readonly wrongAnswers: FieldRef<"ExamScore", 'Int'>
    readonly unanswered: FieldRef<"ExamScore", 'Int'>
    readonly totalQuestions: FieldRef<"ExamScore", 'Int'>
    readonly totalTimeSpent: FieldRef<"ExamScore", 'Int'>
    readonly averageTimePerQuestion: FieldRef<"ExamScore", 'Float'>
    readonly timeEfficiency: FieldRef<"ExamScore", 'Float'>
    readonly easyCorrect: FieldRef<"ExamScore", 'Int'>
    readonly easyTotal: FieldRef<"ExamScore", 'Int'>
    readonly mediumCorrect: FieldRef<"ExamScore", 'Int'>
    readonly mediumTotal: FieldRef<"ExamScore", 'Int'>
    readonly hardCorrect: FieldRef<"ExamScore", 'Int'>
    readonly hardTotal: FieldRef<"ExamScore", 'Int'>
    readonly accuracy: FieldRef<"ExamScore", 'Float'>
    readonly speedScore: FieldRef<"ExamScore", 'Float'>
    readonly consistencyScore: FieldRef<"ExamScore", 'Float'>
    readonly difficultyScore: FieldRef<"ExamScore", 'Float'>
    readonly percentile: FieldRef<"ExamScore", 'Float'>
    readonly rank: FieldRef<"ExamScore", 'Int'>
    readonly improvement: FieldRef<"ExamScore", 'Float'>
    readonly calculatedAt: FieldRef<"ExamScore", 'DateTime'>
    readonly createdAt: FieldRef<"ExamScore", 'DateTime'>
    readonly updatedAt: FieldRef<"ExamScore", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExamScore findUnique
   */
  export type ExamScoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamScore
     */
    select?: ExamScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamScore
     */
    omit?: ExamScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScoreInclude<ExtArgs> | null
    /**
     * Filter, which ExamScore to fetch.
     */
    where: ExamScoreWhereUniqueInput
  }

  /**
   * ExamScore findUniqueOrThrow
   */
  export type ExamScoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamScore
     */
    select?: ExamScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamScore
     */
    omit?: ExamScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScoreInclude<ExtArgs> | null
    /**
     * Filter, which ExamScore to fetch.
     */
    where: ExamScoreWhereUniqueInput
  }

  /**
   * ExamScore findFirst
   */
  export type ExamScoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamScore
     */
    select?: ExamScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamScore
     */
    omit?: ExamScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScoreInclude<ExtArgs> | null
    /**
     * Filter, which ExamScore to fetch.
     */
    where?: ExamScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamScores to fetch.
     */
    orderBy?: ExamScoreOrderByWithRelationInput | ExamScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamScores.
     */
    cursor?: ExamScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamScores.
     */
    distinct?: ExamScoreScalarFieldEnum | ExamScoreScalarFieldEnum[]
  }

  /**
   * ExamScore findFirstOrThrow
   */
  export type ExamScoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamScore
     */
    select?: ExamScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamScore
     */
    omit?: ExamScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScoreInclude<ExtArgs> | null
    /**
     * Filter, which ExamScore to fetch.
     */
    where?: ExamScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamScores to fetch.
     */
    orderBy?: ExamScoreOrderByWithRelationInput | ExamScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamScores.
     */
    cursor?: ExamScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamScores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamScores.
     */
    distinct?: ExamScoreScalarFieldEnum | ExamScoreScalarFieldEnum[]
  }

  /**
   * ExamScore findMany
   */
  export type ExamScoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamScore
     */
    select?: ExamScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamScore
     */
    omit?: ExamScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScoreInclude<ExtArgs> | null
    /**
     * Filter, which ExamScores to fetch.
     */
    where?: ExamScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamScores to fetch.
     */
    orderBy?: ExamScoreOrderByWithRelationInput | ExamScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExamScores.
     */
    cursor?: ExamScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamScores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamScores.
     */
    skip?: number
    distinct?: ExamScoreScalarFieldEnum | ExamScoreScalarFieldEnum[]
  }

  /**
   * ExamScore create
   */
  export type ExamScoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamScore
     */
    select?: ExamScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamScore
     */
    omit?: ExamScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScoreInclude<ExtArgs> | null
    /**
     * The data needed to create a ExamScore.
     */
    data: XOR<ExamScoreCreateInput, ExamScoreUncheckedCreateInput>
  }

  /**
   * ExamScore createMany
   */
  export type ExamScoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExamScores.
     */
    data: ExamScoreCreateManyInput | ExamScoreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExamScore createManyAndReturn
   */
  export type ExamScoreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamScore
     */
    select?: ExamScoreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExamScore
     */
    omit?: ExamScoreOmit<ExtArgs> | null
    /**
     * The data used to create many ExamScores.
     */
    data: ExamScoreCreateManyInput | ExamScoreCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScoreIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExamScore update
   */
  export type ExamScoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamScore
     */
    select?: ExamScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamScore
     */
    omit?: ExamScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScoreInclude<ExtArgs> | null
    /**
     * The data needed to update a ExamScore.
     */
    data: XOR<ExamScoreUpdateInput, ExamScoreUncheckedUpdateInput>
    /**
     * Choose, which ExamScore to update.
     */
    where: ExamScoreWhereUniqueInput
  }

  /**
   * ExamScore updateMany
   */
  export type ExamScoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExamScores.
     */
    data: XOR<ExamScoreUpdateManyMutationInput, ExamScoreUncheckedUpdateManyInput>
    /**
     * Filter which ExamScores to update
     */
    where?: ExamScoreWhereInput
    /**
     * Limit how many ExamScores to update.
     */
    limit?: number
  }

  /**
   * ExamScore updateManyAndReturn
   */
  export type ExamScoreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamScore
     */
    select?: ExamScoreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExamScore
     */
    omit?: ExamScoreOmit<ExtArgs> | null
    /**
     * The data used to update ExamScores.
     */
    data: XOR<ExamScoreUpdateManyMutationInput, ExamScoreUncheckedUpdateManyInput>
    /**
     * Filter which ExamScores to update
     */
    where?: ExamScoreWhereInput
    /**
     * Limit how many ExamScores to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScoreIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExamScore upsert
   */
  export type ExamScoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamScore
     */
    select?: ExamScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamScore
     */
    omit?: ExamScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScoreInclude<ExtArgs> | null
    /**
     * The filter to search for the ExamScore to update in case it exists.
     */
    where: ExamScoreWhereUniqueInput
    /**
     * In case the ExamScore found by the `where` argument doesn't exist, create a new ExamScore with this data.
     */
    create: XOR<ExamScoreCreateInput, ExamScoreUncheckedCreateInput>
    /**
     * In case the ExamScore was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamScoreUpdateInput, ExamScoreUncheckedUpdateInput>
  }

  /**
   * ExamScore delete
   */
  export type ExamScoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamScore
     */
    select?: ExamScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamScore
     */
    omit?: ExamScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScoreInclude<ExtArgs> | null
    /**
     * Filter which ExamScore to delete.
     */
    where: ExamScoreWhereUniqueInput
  }

  /**
   * ExamScore deleteMany
   */
  export type ExamScoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamScores to delete
     */
    where?: ExamScoreWhereInput
    /**
     * Limit how many ExamScores to delete.
     */
    limit?: number
  }

  /**
   * ExamScore without action
   */
  export type ExamScoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamScore
     */
    select?: ExamScoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamScore
     */
    omit?: ExamScoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamScoreInclude<ExtArgs> | null
  }


  /**
   * Model UserPerformance
   */

  export type AggregateUserPerformance = {
    _count: UserPerformanceCountAggregateOutputType | null
    _avg: UserPerformanceAvgAggregateOutputType | null
    _sum: UserPerformanceSumAggregateOutputType | null
    _min: UserPerformanceMinAggregateOutputType | null
    _max: UserPerformanceMaxAggregateOutputType | null
  }

  export type UserPerformanceAvgAggregateOutputType = {
    totalAttempts: number | null
    totalPassed: number | null
    totalFailed: number | null
    passRate: number | null
    averageScore: number | null
    highestScore: number | null
    lowestScore: number | null
    totalMarks: number | null
    totalTimeSpent: number | null
    averageTimePerExam: number | null
    easyAccuracy: number | null
    mediumAccuracy: number | null
    hardAccuracy: number | null
    improvementRate: number | null
    consistencyScore: number | null
    learningCurve: number | null
  }

  export type UserPerformanceSumAggregateOutputType = {
    totalAttempts: number | null
    totalPassed: number | null
    totalFailed: number | null
    passRate: number | null
    averageScore: number | null
    highestScore: number | null
    lowestScore: number | null
    totalMarks: number | null
    totalTimeSpent: number | null
    averageTimePerExam: number | null
    easyAccuracy: number | null
    mediumAccuracy: number | null
    hardAccuracy: number | null
    improvementRate: number | null
    consistencyScore: number | null
    learningCurve: number | null
  }

  export type UserPerformanceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    examCategoryId: string | null
    totalAttempts: number | null
    totalPassed: number | null
    totalFailed: number | null
    passRate: number | null
    averageScore: number | null
    highestScore: number | null
    lowestScore: number | null
    totalMarks: number | null
    totalTimeSpent: number | null
    averageTimePerExam: number | null
    easyAccuracy: number | null
    mediumAccuracy: number | null
    hardAccuracy: number | null
    improvementRate: number | null
    consistencyScore: number | null
    learningCurve: number | null
    lastAttemptAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPerformanceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    examCategoryId: string | null
    totalAttempts: number | null
    totalPassed: number | null
    totalFailed: number | null
    passRate: number | null
    averageScore: number | null
    highestScore: number | null
    lowestScore: number | null
    totalMarks: number | null
    totalTimeSpent: number | null
    averageTimePerExam: number | null
    easyAccuracy: number | null
    mediumAccuracy: number | null
    hardAccuracy: number | null
    improvementRate: number | null
    consistencyScore: number | null
    learningCurve: number | null
    lastAttemptAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPerformanceCountAggregateOutputType = {
    id: number
    userId: number
    examCategoryId: number
    totalAttempts: number
    totalPassed: number
    totalFailed: number
    passRate: number
    averageScore: number
    highestScore: number
    lowestScore: number
    totalMarks: number
    totalTimeSpent: number
    averageTimePerExam: number
    easyAccuracy: number
    mediumAccuracy: number
    hardAccuracy: number
    improvementRate: number
    consistencyScore: number
    learningCurve: number
    lastAttemptAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserPerformanceAvgAggregateInputType = {
    totalAttempts?: true
    totalPassed?: true
    totalFailed?: true
    passRate?: true
    averageScore?: true
    highestScore?: true
    lowestScore?: true
    totalMarks?: true
    totalTimeSpent?: true
    averageTimePerExam?: true
    easyAccuracy?: true
    mediumAccuracy?: true
    hardAccuracy?: true
    improvementRate?: true
    consistencyScore?: true
    learningCurve?: true
  }

  export type UserPerformanceSumAggregateInputType = {
    totalAttempts?: true
    totalPassed?: true
    totalFailed?: true
    passRate?: true
    averageScore?: true
    highestScore?: true
    lowestScore?: true
    totalMarks?: true
    totalTimeSpent?: true
    averageTimePerExam?: true
    easyAccuracy?: true
    mediumAccuracy?: true
    hardAccuracy?: true
    improvementRate?: true
    consistencyScore?: true
    learningCurve?: true
  }

  export type UserPerformanceMinAggregateInputType = {
    id?: true
    userId?: true
    examCategoryId?: true
    totalAttempts?: true
    totalPassed?: true
    totalFailed?: true
    passRate?: true
    averageScore?: true
    highestScore?: true
    lowestScore?: true
    totalMarks?: true
    totalTimeSpent?: true
    averageTimePerExam?: true
    easyAccuracy?: true
    mediumAccuracy?: true
    hardAccuracy?: true
    improvementRate?: true
    consistencyScore?: true
    learningCurve?: true
    lastAttemptAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPerformanceMaxAggregateInputType = {
    id?: true
    userId?: true
    examCategoryId?: true
    totalAttempts?: true
    totalPassed?: true
    totalFailed?: true
    passRate?: true
    averageScore?: true
    highestScore?: true
    lowestScore?: true
    totalMarks?: true
    totalTimeSpent?: true
    averageTimePerExam?: true
    easyAccuracy?: true
    mediumAccuracy?: true
    hardAccuracy?: true
    improvementRate?: true
    consistencyScore?: true
    learningCurve?: true
    lastAttemptAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPerformanceCountAggregateInputType = {
    id?: true
    userId?: true
    examCategoryId?: true
    totalAttempts?: true
    totalPassed?: true
    totalFailed?: true
    passRate?: true
    averageScore?: true
    highestScore?: true
    lowestScore?: true
    totalMarks?: true
    totalTimeSpent?: true
    averageTimePerExam?: true
    easyAccuracy?: true
    mediumAccuracy?: true
    hardAccuracy?: true
    improvementRate?: true
    consistencyScore?: true
    learningCurve?: true
    lastAttemptAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserPerformanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPerformance to aggregate.
     */
    where?: UserPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPerformances to fetch.
     */
    orderBy?: UserPerformanceOrderByWithRelationInput | UserPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPerformances
    **/
    _count?: true | UserPerformanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserPerformanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserPerformanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPerformanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPerformanceMaxAggregateInputType
  }

  export type GetUserPerformanceAggregateType<T extends UserPerformanceAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPerformance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPerformance[P]>
      : GetScalarType<T[P], AggregateUserPerformance[P]>
  }




  export type UserPerformanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPerformanceWhereInput
    orderBy?: UserPerformanceOrderByWithAggregationInput | UserPerformanceOrderByWithAggregationInput[]
    by: UserPerformanceScalarFieldEnum[] | UserPerformanceScalarFieldEnum
    having?: UserPerformanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPerformanceCountAggregateInputType | true
    _avg?: UserPerformanceAvgAggregateInputType
    _sum?: UserPerformanceSumAggregateInputType
    _min?: UserPerformanceMinAggregateInputType
    _max?: UserPerformanceMaxAggregateInputType
  }

  export type UserPerformanceGroupByOutputType = {
    id: string
    userId: string
    examCategoryId: string | null
    totalAttempts: number
    totalPassed: number
    totalFailed: number
    passRate: number
    averageScore: number
    highestScore: number
    lowestScore: number
    totalMarks: number
    totalTimeSpent: number
    averageTimePerExam: number
    easyAccuracy: number
    mediumAccuracy: number
    hardAccuracy: number
    improvementRate: number
    consistencyScore: number
    learningCurve: number
    lastAttemptAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserPerformanceCountAggregateOutputType | null
    _avg: UserPerformanceAvgAggregateOutputType | null
    _sum: UserPerformanceSumAggregateOutputType | null
    _min: UserPerformanceMinAggregateOutputType | null
    _max: UserPerformanceMaxAggregateOutputType | null
  }

  type GetUserPerformanceGroupByPayload<T extends UserPerformanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPerformanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPerformanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPerformanceGroupByOutputType[P]>
            : GetScalarType<T[P], UserPerformanceGroupByOutputType[P]>
        }
      >
    >


  export type UserPerformanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    examCategoryId?: boolean
    totalAttempts?: boolean
    totalPassed?: boolean
    totalFailed?: boolean
    passRate?: boolean
    averageScore?: boolean
    highestScore?: boolean
    lowestScore?: boolean
    totalMarks?: boolean
    totalTimeSpent?: boolean
    averageTimePerExam?: boolean
    easyAccuracy?: boolean
    mediumAccuracy?: boolean
    hardAccuracy?: boolean
    improvementRate?: boolean
    consistencyScore?: boolean
    learningCurve?: boolean
    lastAttemptAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    examCategory?: boolean | UserPerformance$examCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["userPerformance"]>

  export type UserPerformanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    examCategoryId?: boolean
    totalAttempts?: boolean
    totalPassed?: boolean
    totalFailed?: boolean
    passRate?: boolean
    averageScore?: boolean
    highestScore?: boolean
    lowestScore?: boolean
    totalMarks?: boolean
    totalTimeSpent?: boolean
    averageTimePerExam?: boolean
    easyAccuracy?: boolean
    mediumAccuracy?: boolean
    hardAccuracy?: boolean
    improvementRate?: boolean
    consistencyScore?: boolean
    learningCurve?: boolean
    lastAttemptAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    examCategory?: boolean | UserPerformance$examCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["userPerformance"]>

  export type UserPerformanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    examCategoryId?: boolean
    totalAttempts?: boolean
    totalPassed?: boolean
    totalFailed?: boolean
    passRate?: boolean
    averageScore?: boolean
    highestScore?: boolean
    lowestScore?: boolean
    totalMarks?: boolean
    totalTimeSpent?: boolean
    averageTimePerExam?: boolean
    easyAccuracy?: boolean
    mediumAccuracy?: boolean
    hardAccuracy?: boolean
    improvementRate?: boolean
    consistencyScore?: boolean
    learningCurve?: boolean
    lastAttemptAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    examCategory?: boolean | UserPerformance$examCategoryArgs<ExtArgs>
  }, ExtArgs["result"]["userPerformance"]>

  export type UserPerformanceSelectScalar = {
    id?: boolean
    userId?: boolean
    examCategoryId?: boolean
    totalAttempts?: boolean
    totalPassed?: boolean
    totalFailed?: boolean
    passRate?: boolean
    averageScore?: boolean
    highestScore?: boolean
    lowestScore?: boolean
    totalMarks?: boolean
    totalTimeSpent?: boolean
    averageTimePerExam?: boolean
    easyAccuracy?: boolean
    mediumAccuracy?: boolean
    hardAccuracy?: boolean
    improvementRate?: boolean
    consistencyScore?: boolean
    learningCurve?: boolean
    lastAttemptAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserPerformanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "examCategoryId" | "totalAttempts" | "totalPassed" | "totalFailed" | "passRate" | "averageScore" | "highestScore" | "lowestScore" | "totalMarks" | "totalTimeSpent" | "averageTimePerExam" | "easyAccuracy" | "mediumAccuracy" | "hardAccuracy" | "improvementRate" | "consistencyScore" | "learningCurve" | "lastAttemptAt" | "createdAt" | "updatedAt", ExtArgs["result"]["userPerformance"]>
  export type UserPerformanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    examCategory?: boolean | UserPerformance$examCategoryArgs<ExtArgs>
  }
  export type UserPerformanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    examCategory?: boolean | UserPerformance$examCategoryArgs<ExtArgs>
  }
  export type UserPerformanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    examCategory?: boolean | UserPerformance$examCategoryArgs<ExtArgs>
  }

  export type $UserPerformancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPerformance"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      examCategory: Prisma.$ExamCategoryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      examCategoryId: string | null
      totalAttempts: number
      totalPassed: number
      totalFailed: number
      passRate: number
      averageScore: number
      highestScore: number
      lowestScore: number
      totalMarks: number
      totalTimeSpent: number
      averageTimePerExam: number
      easyAccuracy: number
      mediumAccuracy: number
      hardAccuracy: number
      improvementRate: number
      consistencyScore: number
      learningCurve: number
      lastAttemptAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userPerformance"]>
    composites: {}
  }

  type UserPerformanceGetPayload<S extends boolean | null | undefined | UserPerformanceDefaultArgs> = $Result.GetResult<Prisma.$UserPerformancePayload, S>

  type UserPerformanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPerformanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPerformanceCountAggregateInputType | true
    }

  export interface UserPerformanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPerformance'], meta: { name: 'UserPerformance' } }
    /**
     * Find zero or one UserPerformance that matches the filter.
     * @param {UserPerformanceFindUniqueArgs} args - Arguments to find a UserPerformance
     * @example
     * // Get one UserPerformance
     * const userPerformance = await prisma.userPerformance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPerformanceFindUniqueArgs>(args: SelectSubset<T, UserPerformanceFindUniqueArgs<ExtArgs>>): Prisma__UserPerformanceClient<$Result.GetResult<Prisma.$UserPerformancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPerformance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPerformanceFindUniqueOrThrowArgs} args - Arguments to find a UserPerformance
     * @example
     * // Get one UserPerformance
     * const userPerformance = await prisma.userPerformance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPerformanceFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPerformanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPerformanceClient<$Result.GetResult<Prisma.$UserPerformancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPerformance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPerformanceFindFirstArgs} args - Arguments to find a UserPerformance
     * @example
     * // Get one UserPerformance
     * const userPerformance = await prisma.userPerformance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPerformanceFindFirstArgs>(args?: SelectSubset<T, UserPerformanceFindFirstArgs<ExtArgs>>): Prisma__UserPerformanceClient<$Result.GetResult<Prisma.$UserPerformancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPerformance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPerformanceFindFirstOrThrowArgs} args - Arguments to find a UserPerformance
     * @example
     * // Get one UserPerformance
     * const userPerformance = await prisma.userPerformance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPerformanceFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPerformanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPerformanceClient<$Result.GetResult<Prisma.$UserPerformancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPerformances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPerformanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPerformances
     * const userPerformances = await prisma.userPerformance.findMany()
     * 
     * // Get first 10 UserPerformances
     * const userPerformances = await prisma.userPerformance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPerformanceWithIdOnly = await prisma.userPerformance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPerformanceFindManyArgs>(args?: SelectSubset<T, UserPerformanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPerformancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPerformance.
     * @param {UserPerformanceCreateArgs} args - Arguments to create a UserPerformance.
     * @example
     * // Create one UserPerformance
     * const UserPerformance = await prisma.userPerformance.create({
     *   data: {
     *     // ... data to create a UserPerformance
     *   }
     * })
     * 
     */
    create<T extends UserPerformanceCreateArgs>(args: SelectSubset<T, UserPerformanceCreateArgs<ExtArgs>>): Prisma__UserPerformanceClient<$Result.GetResult<Prisma.$UserPerformancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPerformances.
     * @param {UserPerformanceCreateManyArgs} args - Arguments to create many UserPerformances.
     * @example
     * // Create many UserPerformances
     * const userPerformance = await prisma.userPerformance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPerformanceCreateManyArgs>(args?: SelectSubset<T, UserPerformanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPerformances and returns the data saved in the database.
     * @param {UserPerformanceCreateManyAndReturnArgs} args - Arguments to create many UserPerformances.
     * @example
     * // Create many UserPerformances
     * const userPerformance = await prisma.userPerformance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPerformances and only return the `id`
     * const userPerformanceWithIdOnly = await prisma.userPerformance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPerformanceCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPerformanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPerformancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserPerformance.
     * @param {UserPerformanceDeleteArgs} args - Arguments to delete one UserPerformance.
     * @example
     * // Delete one UserPerformance
     * const UserPerformance = await prisma.userPerformance.delete({
     *   where: {
     *     // ... filter to delete one UserPerformance
     *   }
     * })
     * 
     */
    delete<T extends UserPerformanceDeleteArgs>(args: SelectSubset<T, UserPerformanceDeleteArgs<ExtArgs>>): Prisma__UserPerformanceClient<$Result.GetResult<Prisma.$UserPerformancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPerformance.
     * @param {UserPerformanceUpdateArgs} args - Arguments to update one UserPerformance.
     * @example
     * // Update one UserPerformance
     * const userPerformance = await prisma.userPerformance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPerformanceUpdateArgs>(args: SelectSubset<T, UserPerformanceUpdateArgs<ExtArgs>>): Prisma__UserPerformanceClient<$Result.GetResult<Prisma.$UserPerformancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPerformances.
     * @param {UserPerformanceDeleteManyArgs} args - Arguments to filter UserPerformances to delete.
     * @example
     * // Delete a few UserPerformances
     * const { count } = await prisma.userPerformance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPerformanceDeleteManyArgs>(args?: SelectSubset<T, UserPerformanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPerformances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPerformanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPerformances
     * const userPerformance = await prisma.userPerformance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPerformanceUpdateManyArgs>(args: SelectSubset<T, UserPerformanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPerformances and returns the data updated in the database.
     * @param {UserPerformanceUpdateManyAndReturnArgs} args - Arguments to update many UserPerformances.
     * @example
     * // Update many UserPerformances
     * const userPerformance = await prisma.userPerformance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserPerformances and only return the `id`
     * const userPerformanceWithIdOnly = await prisma.userPerformance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserPerformanceUpdateManyAndReturnArgs>(args: SelectSubset<T, UserPerformanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPerformancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserPerformance.
     * @param {UserPerformanceUpsertArgs} args - Arguments to update or create a UserPerformance.
     * @example
     * // Update or create a UserPerformance
     * const userPerformance = await prisma.userPerformance.upsert({
     *   create: {
     *     // ... data to create a UserPerformance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPerformance we want to update
     *   }
     * })
     */
    upsert<T extends UserPerformanceUpsertArgs>(args: SelectSubset<T, UserPerformanceUpsertArgs<ExtArgs>>): Prisma__UserPerformanceClient<$Result.GetResult<Prisma.$UserPerformancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPerformances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPerformanceCountArgs} args - Arguments to filter UserPerformances to count.
     * @example
     * // Count the number of UserPerformances
     * const count = await prisma.userPerformance.count({
     *   where: {
     *     // ... the filter for the UserPerformances we want to count
     *   }
     * })
    **/
    count<T extends UserPerformanceCountArgs>(
      args?: Subset<T, UserPerformanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPerformanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPerformance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPerformanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPerformanceAggregateArgs>(args: Subset<T, UserPerformanceAggregateArgs>): Prisma.PrismaPromise<GetUserPerformanceAggregateType<T>>

    /**
     * Group by UserPerformance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPerformanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPerformanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPerformanceGroupByArgs['orderBy'] }
        : { orderBy?: UserPerformanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPerformanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPerformanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPerformance model
   */
  readonly fields: UserPerformanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPerformance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPerformanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    examCategory<T extends UserPerformance$examCategoryArgs<ExtArgs> = {}>(args?: Subset<T, UserPerformance$examCategoryArgs<ExtArgs>>): Prisma__ExamCategoryClient<$Result.GetResult<Prisma.$ExamCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPerformance model
   */
  interface UserPerformanceFieldRefs {
    readonly id: FieldRef<"UserPerformance", 'String'>
    readonly userId: FieldRef<"UserPerformance", 'String'>
    readonly examCategoryId: FieldRef<"UserPerformance", 'String'>
    readonly totalAttempts: FieldRef<"UserPerformance", 'Int'>
    readonly totalPassed: FieldRef<"UserPerformance", 'Int'>
    readonly totalFailed: FieldRef<"UserPerformance", 'Int'>
    readonly passRate: FieldRef<"UserPerformance", 'Float'>
    readonly averageScore: FieldRef<"UserPerformance", 'Float'>
    readonly highestScore: FieldRef<"UserPerformance", 'Float'>
    readonly lowestScore: FieldRef<"UserPerformance", 'Float'>
    readonly totalMarks: FieldRef<"UserPerformance", 'Float'>
    readonly totalTimeSpent: FieldRef<"UserPerformance", 'Int'>
    readonly averageTimePerExam: FieldRef<"UserPerformance", 'Float'>
    readonly easyAccuracy: FieldRef<"UserPerformance", 'Float'>
    readonly mediumAccuracy: FieldRef<"UserPerformance", 'Float'>
    readonly hardAccuracy: FieldRef<"UserPerformance", 'Float'>
    readonly improvementRate: FieldRef<"UserPerformance", 'Float'>
    readonly consistencyScore: FieldRef<"UserPerformance", 'Float'>
    readonly learningCurve: FieldRef<"UserPerformance", 'Float'>
    readonly lastAttemptAt: FieldRef<"UserPerformance", 'DateTime'>
    readonly createdAt: FieldRef<"UserPerformance", 'DateTime'>
    readonly updatedAt: FieldRef<"UserPerformance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserPerformance findUnique
   */
  export type UserPerformanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPerformance
     */
    select?: UserPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPerformance
     */
    omit?: UserPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which UserPerformance to fetch.
     */
    where: UserPerformanceWhereUniqueInput
  }

  /**
   * UserPerformance findUniqueOrThrow
   */
  export type UserPerformanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPerformance
     */
    select?: UserPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPerformance
     */
    omit?: UserPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which UserPerformance to fetch.
     */
    where: UserPerformanceWhereUniqueInput
  }

  /**
   * UserPerformance findFirst
   */
  export type UserPerformanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPerformance
     */
    select?: UserPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPerformance
     */
    omit?: UserPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which UserPerformance to fetch.
     */
    where?: UserPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPerformances to fetch.
     */
    orderBy?: UserPerformanceOrderByWithRelationInput | UserPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPerformances.
     */
    cursor?: UserPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPerformances.
     */
    distinct?: UserPerformanceScalarFieldEnum | UserPerformanceScalarFieldEnum[]
  }

  /**
   * UserPerformance findFirstOrThrow
   */
  export type UserPerformanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPerformance
     */
    select?: UserPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPerformance
     */
    omit?: UserPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which UserPerformance to fetch.
     */
    where?: UserPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPerformances to fetch.
     */
    orderBy?: UserPerformanceOrderByWithRelationInput | UserPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPerformances.
     */
    cursor?: UserPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPerformances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPerformances.
     */
    distinct?: UserPerformanceScalarFieldEnum | UserPerformanceScalarFieldEnum[]
  }

  /**
   * UserPerformance findMany
   */
  export type UserPerformanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPerformance
     */
    select?: UserPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPerformance
     */
    omit?: UserPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPerformanceInclude<ExtArgs> | null
    /**
     * Filter, which UserPerformances to fetch.
     */
    where?: UserPerformanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPerformances to fetch.
     */
    orderBy?: UserPerformanceOrderByWithRelationInput | UserPerformanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPerformances.
     */
    cursor?: UserPerformanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPerformances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPerformances.
     */
    skip?: number
    distinct?: UserPerformanceScalarFieldEnum | UserPerformanceScalarFieldEnum[]
  }

  /**
   * UserPerformance create
   */
  export type UserPerformanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPerformance
     */
    select?: UserPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPerformance
     */
    omit?: UserPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPerformanceInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPerformance.
     */
    data: XOR<UserPerformanceCreateInput, UserPerformanceUncheckedCreateInput>
  }

  /**
   * UserPerformance createMany
   */
  export type UserPerformanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPerformances.
     */
    data: UserPerformanceCreateManyInput | UserPerformanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPerformance createManyAndReturn
   */
  export type UserPerformanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPerformance
     */
    select?: UserPerformanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPerformance
     */
    omit?: UserPerformanceOmit<ExtArgs> | null
    /**
     * The data used to create many UserPerformances.
     */
    data: UserPerformanceCreateManyInput | UserPerformanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPerformanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPerformance update
   */
  export type UserPerformanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPerformance
     */
    select?: UserPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPerformance
     */
    omit?: UserPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPerformanceInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPerformance.
     */
    data: XOR<UserPerformanceUpdateInput, UserPerformanceUncheckedUpdateInput>
    /**
     * Choose, which UserPerformance to update.
     */
    where: UserPerformanceWhereUniqueInput
  }

  /**
   * UserPerformance updateMany
   */
  export type UserPerformanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPerformances.
     */
    data: XOR<UserPerformanceUpdateManyMutationInput, UserPerformanceUncheckedUpdateManyInput>
    /**
     * Filter which UserPerformances to update
     */
    where?: UserPerformanceWhereInput
    /**
     * Limit how many UserPerformances to update.
     */
    limit?: number
  }

  /**
   * UserPerformance updateManyAndReturn
   */
  export type UserPerformanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPerformance
     */
    select?: UserPerformanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPerformance
     */
    omit?: UserPerformanceOmit<ExtArgs> | null
    /**
     * The data used to update UserPerformances.
     */
    data: XOR<UserPerformanceUpdateManyMutationInput, UserPerformanceUncheckedUpdateManyInput>
    /**
     * Filter which UserPerformances to update
     */
    where?: UserPerformanceWhereInput
    /**
     * Limit how many UserPerformances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPerformanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPerformance upsert
   */
  export type UserPerformanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPerformance
     */
    select?: UserPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPerformance
     */
    omit?: UserPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPerformanceInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPerformance to update in case it exists.
     */
    where: UserPerformanceWhereUniqueInput
    /**
     * In case the UserPerformance found by the `where` argument doesn't exist, create a new UserPerformance with this data.
     */
    create: XOR<UserPerformanceCreateInput, UserPerformanceUncheckedCreateInput>
    /**
     * In case the UserPerformance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPerformanceUpdateInput, UserPerformanceUncheckedUpdateInput>
  }

  /**
   * UserPerformance delete
   */
  export type UserPerformanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPerformance
     */
    select?: UserPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPerformance
     */
    omit?: UserPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPerformanceInclude<ExtArgs> | null
    /**
     * Filter which UserPerformance to delete.
     */
    where: UserPerformanceWhereUniqueInput
  }

  /**
   * UserPerformance deleteMany
   */
  export type UserPerformanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPerformances to delete
     */
    where?: UserPerformanceWhereInput
    /**
     * Limit how many UserPerformances to delete.
     */
    limit?: number
  }

  /**
   * UserPerformance.examCategory
   */
  export type UserPerformance$examCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamCategory
     */
    select?: ExamCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamCategory
     */
    omit?: ExamCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamCategoryInclude<ExtArgs> | null
    where?: ExamCategoryWhereInput
  }

  /**
   * UserPerformance without action
   */
  export type UserPerformanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPerformance
     */
    select?: UserPerformanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPerformance
     */
    omit?: UserPerformanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPerformanceInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    bookingId: string | null
    amount: Decimal | null
    currency: string | null
    status: $Enums.PaymentStatus | null
    paymentMethod: $Enums.PaymentMethod | null
    stripePaymentId: string | null
    stripeRefundId: string | null
    description: string | null
    refundedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    bookingId: string | null
    amount: Decimal | null
    currency: string | null
    status: $Enums.PaymentStatus | null
    paymentMethod: $Enums.PaymentMethod | null
    stripePaymentId: string | null
    stripeRefundId: string | null
    description: string | null
    refundedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    userId: number
    bookingId: number
    amount: number
    currency: number
    status: number
    paymentMethod: number
    stripePaymentId: number
    stripeRefundId: number
    description: number
    metadata: number
    refundedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    userId?: true
    bookingId?: true
    amount?: true
    currency?: true
    status?: true
    paymentMethod?: true
    stripePaymentId?: true
    stripeRefundId?: true
    description?: true
    refundedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    userId?: true
    bookingId?: true
    amount?: true
    currency?: true
    status?: true
    paymentMethod?: true
    stripePaymentId?: true
    stripeRefundId?: true
    description?: true
    refundedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    userId?: true
    bookingId?: true
    amount?: true
    currency?: true
    status?: true
    paymentMethod?: true
    stripePaymentId?: true
    stripeRefundId?: true
    description?: true
    metadata?: true
    refundedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    userId: string
    bookingId: string | null
    amount: Decimal
    currency: string
    status: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    stripePaymentId: string | null
    stripeRefundId: string | null
    description: string | null
    metadata: JsonValue | null
    refundedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bookingId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    paymentMethod?: boolean
    stripePaymentId?: boolean
    stripeRefundId?: boolean
    description?: boolean
    metadata?: boolean
    refundedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    booking?: boolean | Payment$bookingArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bookingId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    paymentMethod?: boolean
    stripePaymentId?: boolean
    stripeRefundId?: boolean
    description?: boolean
    metadata?: boolean
    refundedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    booking?: boolean | Payment$bookingArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    bookingId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    paymentMethod?: boolean
    stripePaymentId?: boolean
    stripeRefundId?: boolean
    description?: boolean
    metadata?: boolean
    refundedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    booking?: boolean | Payment$bookingArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    userId?: boolean
    bookingId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    paymentMethod?: boolean
    stripePaymentId?: boolean
    stripeRefundId?: boolean
    description?: boolean
    metadata?: boolean
    refundedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "bookingId" | "amount" | "currency" | "status" | "paymentMethod" | "stripePaymentId" | "stripeRefundId" | "description" | "metadata" | "refundedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    booking?: boolean | Payment$bookingArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    booking?: boolean | Payment$bookingArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    booking?: boolean | Payment$bookingArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      booking: Prisma.$ExamBookingPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      bookingId: string | null
      amount: Prisma.Decimal
      currency: string
      status: $Enums.PaymentStatus
      paymentMethod: $Enums.PaymentMethod
      stripePaymentId: string | null
      stripeRefundId: string | null
      description: string | null
      metadata: Prisma.JsonValue | null
      refundedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    booking<T extends Payment$bookingArgs<ExtArgs> = {}>(args?: Subset<T, Payment$bookingArgs<ExtArgs>>): Prisma__ExamBookingClient<$Result.GetResult<Prisma.$ExamBookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly userId: FieldRef<"Payment", 'String'>
    readonly bookingId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly paymentMethod: FieldRef<"Payment", 'PaymentMethod'>
    readonly stripePaymentId: FieldRef<"Payment", 'String'>
    readonly stripeRefundId: FieldRef<"Payment", 'String'>
    readonly description: FieldRef<"Payment", 'String'>
    readonly metadata: FieldRef<"Payment", 'Json'>
    readonly refundedAt: FieldRef<"Payment", 'DateTime'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment.booking
   */
  export type Payment$bookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamBooking
     */
    select?: ExamBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamBooking
     */
    omit?: ExamBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamBookingInclude<ExtArgs> | null
    where?: ExamBookingWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Certificate
   */

  export type AggregateCertificate = {
    _count: CertificateCountAggregateOutputType | null
    _min: CertificateMinAggregateOutputType | null
    _max: CertificateMaxAggregateOutputType | null
  }

  export type CertificateMinAggregateOutputType = {
    id: string | null
    userId: string | null
    examId: string | null
    attemptId: string | null
    certificateNumber: string | null
    issuedAt: Date | null
    expiresAt: Date | null
    isRevoked: boolean | null
    revokedAt: Date | null
    revokedBy: string | null
    revokedReason: string | null
    pdfUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CertificateMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    examId: string | null
    attemptId: string | null
    certificateNumber: string | null
    issuedAt: Date | null
    expiresAt: Date | null
    isRevoked: boolean | null
    revokedAt: Date | null
    revokedBy: string | null
    revokedReason: string | null
    pdfUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CertificateCountAggregateOutputType = {
    id: number
    userId: number
    examId: number
    attemptId: number
    certificateNumber: number
    issuedAt: number
    expiresAt: number
    isRevoked: number
    revokedAt: number
    revokedBy: number
    revokedReason: number
    pdfUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CertificateMinAggregateInputType = {
    id?: true
    userId?: true
    examId?: true
    attemptId?: true
    certificateNumber?: true
    issuedAt?: true
    expiresAt?: true
    isRevoked?: true
    revokedAt?: true
    revokedBy?: true
    revokedReason?: true
    pdfUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CertificateMaxAggregateInputType = {
    id?: true
    userId?: true
    examId?: true
    attemptId?: true
    certificateNumber?: true
    issuedAt?: true
    expiresAt?: true
    isRevoked?: true
    revokedAt?: true
    revokedBy?: true
    revokedReason?: true
    pdfUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CertificateCountAggregateInputType = {
    id?: true
    userId?: true
    examId?: true
    attemptId?: true
    certificateNumber?: true
    issuedAt?: true
    expiresAt?: true
    isRevoked?: true
    revokedAt?: true
    revokedBy?: true
    revokedReason?: true
    pdfUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CertificateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certificate to aggregate.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Certificates
    **/
    _count?: true | CertificateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CertificateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CertificateMaxAggregateInputType
  }

  export type GetCertificateAggregateType<T extends CertificateAggregateArgs> = {
        [P in keyof T & keyof AggregateCertificate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertificate[P]>
      : GetScalarType<T[P], AggregateCertificate[P]>
  }




  export type CertificateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithAggregationInput | CertificateOrderByWithAggregationInput[]
    by: CertificateScalarFieldEnum[] | CertificateScalarFieldEnum
    having?: CertificateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CertificateCountAggregateInputType | true
    _min?: CertificateMinAggregateInputType
    _max?: CertificateMaxAggregateInputType
  }

  export type CertificateGroupByOutputType = {
    id: string
    userId: string
    examId: string
    attemptId: string
    certificateNumber: string
    issuedAt: Date
    expiresAt: Date | null
    isRevoked: boolean
    revokedAt: Date | null
    revokedBy: string | null
    revokedReason: string | null
    pdfUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: CertificateCountAggregateOutputType | null
    _min: CertificateMinAggregateOutputType | null
    _max: CertificateMaxAggregateOutputType | null
  }

  type GetCertificateGroupByPayload<T extends CertificateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CertificateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CertificateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CertificateGroupByOutputType[P]>
            : GetScalarType<T[P], CertificateGroupByOutputType[P]>
        }
      >
    >


  export type CertificateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    examId?: boolean
    attemptId?: boolean
    certificateNumber?: boolean
    issuedAt?: boolean
    expiresAt?: boolean
    isRevoked?: boolean
    revokedAt?: boolean
    revokedBy?: boolean
    revokedReason?: boolean
    pdfUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    attempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
    revoker?: boolean | Certificate$revokerArgs<ExtArgs>
  }, ExtArgs["result"]["certificate"]>

  export type CertificateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    examId?: boolean
    attemptId?: boolean
    certificateNumber?: boolean
    issuedAt?: boolean
    expiresAt?: boolean
    isRevoked?: boolean
    revokedAt?: boolean
    revokedBy?: boolean
    revokedReason?: boolean
    pdfUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    attempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
    revoker?: boolean | Certificate$revokerArgs<ExtArgs>
  }, ExtArgs["result"]["certificate"]>

  export type CertificateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    examId?: boolean
    attemptId?: boolean
    certificateNumber?: boolean
    issuedAt?: boolean
    expiresAt?: boolean
    isRevoked?: boolean
    revokedAt?: boolean
    revokedBy?: boolean
    revokedReason?: boolean
    pdfUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    attempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
    revoker?: boolean | Certificate$revokerArgs<ExtArgs>
  }, ExtArgs["result"]["certificate"]>

  export type CertificateSelectScalar = {
    id?: boolean
    userId?: boolean
    examId?: boolean
    attemptId?: boolean
    certificateNumber?: boolean
    issuedAt?: boolean
    expiresAt?: boolean
    isRevoked?: boolean
    revokedAt?: boolean
    revokedBy?: boolean
    revokedReason?: boolean
    pdfUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CertificateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "examId" | "attemptId" | "certificateNumber" | "issuedAt" | "expiresAt" | "isRevoked" | "revokedAt" | "revokedBy" | "revokedReason" | "pdfUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["certificate"]>
  export type CertificateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    attempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
    revoker?: boolean | Certificate$revokerArgs<ExtArgs>
  }
  export type CertificateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    attempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
    revoker?: boolean | Certificate$revokerArgs<ExtArgs>
  }
  export type CertificateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    exam?: boolean | ExamDefaultArgs<ExtArgs>
    attempt?: boolean | ExamAttemptDefaultArgs<ExtArgs>
    revoker?: boolean | Certificate$revokerArgs<ExtArgs>
  }

  export type $CertificatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Certificate"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      exam: Prisma.$ExamPayload<ExtArgs>
      attempt: Prisma.$ExamAttemptPayload<ExtArgs>
      revoker: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      examId: string
      attemptId: string
      certificateNumber: string
      issuedAt: Date
      expiresAt: Date | null
      isRevoked: boolean
      revokedAt: Date | null
      revokedBy: string | null
      revokedReason: string | null
      pdfUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["certificate"]>
    composites: {}
  }

  type CertificateGetPayload<S extends boolean | null | undefined | CertificateDefaultArgs> = $Result.GetResult<Prisma.$CertificatePayload, S>

  type CertificateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CertificateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CertificateCountAggregateInputType | true
    }

  export interface CertificateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Certificate'], meta: { name: 'Certificate' } }
    /**
     * Find zero or one Certificate that matches the filter.
     * @param {CertificateFindUniqueArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CertificateFindUniqueArgs>(args: SelectSubset<T, CertificateFindUniqueArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Certificate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CertificateFindUniqueOrThrowArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CertificateFindUniqueOrThrowArgs>(args: SelectSubset<T, CertificateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Certificate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindFirstArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CertificateFindFirstArgs>(args?: SelectSubset<T, CertificateFindFirstArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Certificate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindFirstOrThrowArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CertificateFindFirstOrThrowArgs>(args?: SelectSubset<T, CertificateFindFirstOrThrowArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Certificates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Certificates
     * const certificates = await prisma.certificate.findMany()
     * 
     * // Get first 10 Certificates
     * const certificates = await prisma.certificate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const certificateWithIdOnly = await prisma.certificate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CertificateFindManyArgs>(args?: SelectSubset<T, CertificateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Certificate.
     * @param {CertificateCreateArgs} args - Arguments to create a Certificate.
     * @example
     * // Create one Certificate
     * const Certificate = await prisma.certificate.create({
     *   data: {
     *     // ... data to create a Certificate
     *   }
     * })
     * 
     */
    create<T extends CertificateCreateArgs>(args: SelectSubset<T, CertificateCreateArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Certificates.
     * @param {CertificateCreateManyArgs} args - Arguments to create many Certificates.
     * @example
     * // Create many Certificates
     * const certificate = await prisma.certificate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CertificateCreateManyArgs>(args?: SelectSubset<T, CertificateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Certificates and returns the data saved in the database.
     * @param {CertificateCreateManyAndReturnArgs} args - Arguments to create many Certificates.
     * @example
     * // Create many Certificates
     * const certificate = await prisma.certificate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Certificates and only return the `id`
     * const certificateWithIdOnly = await prisma.certificate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CertificateCreateManyAndReturnArgs>(args?: SelectSubset<T, CertificateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Certificate.
     * @param {CertificateDeleteArgs} args - Arguments to delete one Certificate.
     * @example
     * // Delete one Certificate
     * const Certificate = await prisma.certificate.delete({
     *   where: {
     *     // ... filter to delete one Certificate
     *   }
     * })
     * 
     */
    delete<T extends CertificateDeleteArgs>(args: SelectSubset<T, CertificateDeleteArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Certificate.
     * @param {CertificateUpdateArgs} args - Arguments to update one Certificate.
     * @example
     * // Update one Certificate
     * const certificate = await prisma.certificate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CertificateUpdateArgs>(args: SelectSubset<T, CertificateUpdateArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Certificates.
     * @param {CertificateDeleteManyArgs} args - Arguments to filter Certificates to delete.
     * @example
     * // Delete a few Certificates
     * const { count } = await prisma.certificate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CertificateDeleteManyArgs>(args?: SelectSubset<T, CertificateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Certificates
     * const certificate = await prisma.certificate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CertificateUpdateManyArgs>(args: SelectSubset<T, CertificateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certificates and returns the data updated in the database.
     * @param {CertificateUpdateManyAndReturnArgs} args - Arguments to update many Certificates.
     * @example
     * // Update many Certificates
     * const certificate = await prisma.certificate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Certificates and only return the `id`
     * const certificateWithIdOnly = await prisma.certificate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CertificateUpdateManyAndReturnArgs>(args: SelectSubset<T, CertificateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Certificate.
     * @param {CertificateUpsertArgs} args - Arguments to update or create a Certificate.
     * @example
     * // Update or create a Certificate
     * const certificate = await prisma.certificate.upsert({
     *   create: {
     *     // ... data to create a Certificate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Certificate we want to update
     *   }
     * })
     */
    upsert<T extends CertificateUpsertArgs>(args: SelectSubset<T, CertificateUpsertArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateCountArgs} args - Arguments to filter Certificates to count.
     * @example
     * // Count the number of Certificates
     * const count = await prisma.certificate.count({
     *   where: {
     *     // ... the filter for the Certificates we want to count
     *   }
     * })
    **/
    count<T extends CertificateCountArgs>(
      args?: Subset<T, CertificateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CertificateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Certificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CertificateAggregateArgs>(args: Subset<T, CertificateAggregateArgs>): Prisma.PrismaPromise<GetCertificateAggregateType<T>>

    /**
     * Group by Certificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CertificateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CertificateGroupByArgs['orderBy'] }
        : { orderBy?: CertificateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CertificateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertificateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Certificate model
   */
  readonly fields: CertificateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Certificate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CertificateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    exam<T extends ExamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamDefaultArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attempt<T extends ExamAttemptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamAttemptDefaultArgs<ExtArgs>>): Prisma__ExamAttemptClient<$Result.GetResult<Prisma.$ExamAttemptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    revoker<T extends Certificate$revokerArgs<ExtArgs> = {}>(args?: Subset<T, Certificate$revokerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Certificate model
   */
  interface CertificateFieldRefs {
    readonly id: FieldRef<"Certificate", 'String'>
    readonly userId: FieldRef<"Certificate", 'String'>
    readonly examId: FieldRef<"Certificate", 'String'>
    readonly attemptId: FieldRef<"Certificate", 'String'>
    readonly certificateNumber: FieldRef<"Certificate", 'String'>
    readonly issuedAt: FieldRef<"Certificate", 'DateTime'>
    readonly expiresAt: FieldRef<"Certificate", 'DateTime'>
    readonly isRevoked: FieldRef<"Certificate", 'Boolean'>
    readonly revokedAt: FieldRef<"Certificate", 'DateTime'>
    readonly revokedBy: FieldRef<"Certificate", 'String'>
    readonly revokedReason: FieldRef<"Certificate", 'String'>
    readonly pdfUrl: FieldRef<"Certificate", 'String'>
    readonly createdAt: FieldRef<"Certificate", 'DateTime'>
    readonly updatedAt: FieldRef<"Certificate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Certificate findUnique
   */
  export type CertificateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate findUniqueOrThrow
   */
  export type CertificateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate findFirst
   */
  export type CertificateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certificates.
     */
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate findFirstOrThrow
   */
  export type CertificateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certificates.
     */
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate findMany
   */
  export type CertificateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificates to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate create
   */
  export type CertificateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The data needed to create a Certificate.
     */
    data: XOR<CertificateCreateInput, CertificateUncheckedCreateInput>
  }

  /**
   * Certificate createMany
   */
  export type CertificateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Certificates.
     */
    data: CertificateCreateManyInput | CertificateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Certificate createManyAndReturn
   */
  export type CertificateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * The data used to create many Certificates.
     */
    data: CertificateCreateManyInput | CertificateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Certificate update
   */
  export type CertificateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The data needed to update a Certificate.
     */
    data: XOR<CertificateUpdateInput, CertificateUncheckedUpdateInput>
    /**
     * Choose, which Certificate to update.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate updateMany
   */
  export type CertificateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Certificates.
     */
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyInput>
    /**
     * Filter which Certificates to update
     */
    where?: CertificateWhereInput
    /**
     * Limit how many Certificates to update.
     */
    limit?: number
  }

  /**
   * Certificate updateManyAndReturn
   */
  export type CertificateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * The data used to update Certificates.
     */
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyInput>
    /**
     * Filter which Certificates to update
     */
    where?: CertificateWhereInput
    /**
     * Limit how many Certificates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Certificate upsert
   */
  export type CertificateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The filter to search for the Certificate to update in case it exists.
     */
    where: CertificateWhereUniqueInput
    /**
     * In case the Certificate found by the `where` argument doesn't exist, create a new Certificate with this data.
     */
    create: XOR<CertificateCreateInput, CertificateUncheckedCreateInput>
    /**
     * In case the Certificate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CertificateUpdateInput, CertificateUncheckedUpdateInput>
  }

  /**
   * Certificate delete
   */
  export type CertificateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter which Certificate to delete.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate deleteMany
   */
  export type CertificateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certificates to delete
     */
    where?: CertificateWhereInput
    /**
     * Limit how many Certificates to delete.
     */
    limit?: number
  }

  /**
   * Certificate.revoker
   */
  export type Certificate$revokerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Certificate without action
   */
  export type CertificateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Certificate
     */
    omit?: CertificateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    isRead: boolean | null
    readAt: Date | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    isRead: boolean | null
    readAt: Date | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    message: number
    isRead: number
    readAt: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    readAt?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    readAt?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    readAt?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead: boolean
    readAt: Date | null
    metadata: JsonValue | null
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    readAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    readAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    readAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    readAt?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "title" | "message" | "isRead" | "readAt" | "metadata" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.NotificationType
      title: string
      message: string
      isRead: boolean
      readAt: Date | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
    readonly metadata: FieldRef<"Notification", 'Json'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model StudyGroup
   */

  export type AggregateStudyGroup = {
    _count: StudyGroupCountAggregateOutputType | null
    _avg: StudyGroupAvgAggregateOutputType | null
    _sum: StudyGroupSumAggregateOutputType | null
    _min: StudyGroupMinAggregateOutputType | null
    _max: StudyGroupMaxAggregateOutputType | null
  }

  export type StudyGroupAvgAggregateOutputType = {
    maxMembers: number | null
  }

  export type StudyGroupSumAggregateOutputType = {
    maxMembers: number | null
  }

  export type StudyGroupMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isPrivate: boolean | null
    maxMembers: number | null
    createdBy: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudyGroupMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isPrivate: boolean | null
    maxMembers: number | null
    createdBy: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudyGroupCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isPrivate: number
    maxMembers: number
    createdBy: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudyGroupAvgAggregateInputType = {
    maxMembers?: true
  }

  export type StudyGroupSumAggregateInputType = {
    maxMembers?: true
  }

  export type StudyGroupMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isPrivate?: true
    maxMembers?: true
    createdBy?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudyGroupMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isPrivate?: true
    maxMembers?: true
    createdBy?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudyGroupCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isPrivate?: true
    maxMembers?: true
    createdBy?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudyGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudyGroup to aggregate.
     */
    where?: StudyGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudyGroups to fetch.
     */
    orderBy?: StudyGroupOrderByWithRelationInput | StudyGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudyGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudyGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudyGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudyGroups
    **/
    _count?: true | StudyGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudyGroupAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudyGroupSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudyGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudyGroupMaxAggregateInputType
  }

  export type GetStudyGroupAggregateType<T extends StudyGroupAggregateArgs> = {
        [P in keyof T & keyof AggregateStudyGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudyGroup[P]>
      : GetScalarType<T[P], AggregateStudyGroup[P]>
  }




  export type StudyGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudyGroupWhereInput
    orderBy?: StudyGroupOrderByWithAggregationInput | StudyGroupOrderByWithAggregationInput[]
    by: StudyGroupScalarFieldEnum[] | StudyGroupScalarFieldEnum
    having?: StudyGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudyGroupCountAggregateInputType | true
    _avg?: StudyGroupAvgAggregateInputType
    _sum?: StudyGroupSumAggregateInputType
    _min?: StudyGroupMinAggregateInputType
    _max?: StudyGroupMaxAggregateInputType
  }

  export type StudyGroupGroupByOutputType = {
    id: string
    name: string
    description: string | null
    isPrivate: boolean
    maxMembers: number
    createdBy: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: StudyGroupCountAggregateOutputType | null
    _avg: StudyGroupAvgAggregateOutputType | null
    _sum: StudyGroupSumAggregateOutputType | null
    _min: StudyGroupMinAggregateOutputType | null
    _max: StudyGroupMaxAggregateOutputType | null
  }

  type GetStudyGroupGroupByPayload<T extends StudyGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudyGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudyGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudyGroupGroupByOutputType[P]>
            : GetScalarType<T[P], StudyGroupGroupByOutputType[P]>
        }
      >
    >


  export type StudyGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isPrivate?: boolean
    maxMembers?: boolean
    createdBy?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | StudyGroup$membersArgs<ExtArgs>
    _count?: boolean | StudyGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studyGroup"]>

  export type StudyGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isPrivate?: boolean
    maxMembers?: boolean
    createdBy?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studyGroup"]>

  export type StudyGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isPrivate?: boolean
    maxMembers?: boolean
    createdBy?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studyGroup"]>

  export type StudyGroupSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isPrivate?: boolean
    maxMembers?: boolean
    createdBy?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudyGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "isPrivate" | "maxMembers" | "createdBy" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["studyGroup"]>
  export type StudyGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | StudyGroup$membersArgs<ExtArgs>
    _count?: boolean | StudyGroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudyGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StudyGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $StudyGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudyGroup"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      members: Prisma.$StudyGroupMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      isPrivate: boolean
      maxMembers: number
      createdBy: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["studyGroup"]>
    composites: {}
  }

  type StudyGroupGetPayload<S extends boolean | null | undefined | StudyGroupDefaultArgs> = $Result.GetResult<Prisma.$StudyGroupPayload, S>

  type StudyGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudyGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudyGroupCountAggregateInputType | true
    }

  export interface StudyGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudyGroup'], meta: { name: 'StudyGroup' } }
    /**
     * Find zero or one StudyGroup that matches the filter.
     * @param {StudyGroupFindUniqueArgs} args - Arguments to find a StudyGroup
     * @example
     * // Get one StudyGroup
     * const studyGroup = await prisma.studyGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudyGroupFindUniqueArgs>(args: SelectSubset<T, StudyGroupFindUniqueArgs<ExtArgs>>): Prisma__StudyGroupClient<$Result.GetResult<Prisma.$StudyGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudyGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudyGroupFindUniqueOrThrowArgs} args - Arguments to find a StudyGroup
     * @example
     * // Get one StudyGroup
     * const studyGroup = await prisma.studyGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudyGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, StudyGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudyGroupClient<$Result.GetResult<Prisma.$StudyGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudyGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyGroupFindFirstArgs} args - Arguments to find a StudyGroup
     * @example
     * // Get one StudyGroup
     * const studyGroup = await prisma.studyGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudyGroupFindFirstArgs>(args?: SelectSubset<T, StudyGroupFindFirstArgs<ExtArgs>>): Prisma__StudyGroupClient<$Result.GetResult<Prisma.$StudyGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudyGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyGroupFindFirstOrThrowArgs} args - Arguments to find a StudyGroup
     * @example
     * // Get one StudyGroup
     * const studyGroup = await prisma.studyGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudyGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, StudyGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudyGroupClient<$Result.GetResult<Prisma.$StudyGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudyGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudyGroups
     * const studyGroups = await prisma.studyGroup.findMany()
     * 
     * // Get first 10 StudyGroups
     * const studyGroups = await prisma.studyGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studyGroupWithIdOnly = await prisma.studyGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudyGroupFindManyArgs>(args?: SelectSubset<T, StudyGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudyGroup.
     * @param {StudyGroupCreateArgs} args - Arguments to create a StudyGroup.
     * @example
     * // Create one StudyGroup
     * const StudyGroup = await prisma.studyGroup.create({
     *   data: {
     *     // ... data to create a StudyGroup
     *   }
     * })
     * 
     */
    create<T extends StudyGroupCreateArgs>(args: SelectSubset<T, StudyGroupCreateArgs<ExtArgs>>): Prisma__StudyGroupClient<$Result.GetResult<Prisma.$StudyGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudyGroups.
     * @param {StudyGroupCreateManyArgs} args - Arguments to create many StudyGroups.
     * @example
     * // Create many StudyGroups
     * const studyGroup = await prisma.studyGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudyGroupCreateManyArgs>(args?: SelectSubset<T, StudyGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudyGroups and returns the data saved in the database.
     * @param {StudyGroupCreateManyAndReturnArgs} args - Arguments to create many StudyGroups.
     * @example
     * // Create many StudyGroups
     * const studyGroup = await prisma.studyGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudyGroups and only return the `id`
     * const studyGroupWithIdOnly = await prisma.studyGroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudyGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, StudyGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyGroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudyGroup.
     * @param {StudyGroupDeleteArgs} args - Arguments to delete one StudyGroup.
     * @example
     * // Delete one StudyGroup
     * const StudyGroup = await prisma.studyGroup.delete({
     *   where: {
     *     // ... filter to delete one StudyGroup
     *   }
     * })
     * 
     */
    delete<T extends StudyGroupDeleteArgs>(args: SelectSubset<T, StudyGroupDeleteArgs<ExtArgs>>): Prisma__StudyGroupClient<$Result.GetResult<Prisma.$StudyGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudyGroup.
     * @param {StudyGroupUpdateArgs} args - Arguments to update one StudyGroup.
     * @example
     * // Update one StudyGroup
     * const studyGroup = await prisma.studyGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudyGroupUpdateArgs>(args: SelectSubset<T, StudyGroupUpdateArgs<ExtArgs>>): Prisma__StudyGroupClient<$Result.GetResult<Prisma.$StudyGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudyGroups.
     * @param {StudyGroupDeleteManyArgs} args - Arguments to filter StudyGroups to delete.
     * @example
     * // Delete a few StudyGroups
     * const { count } = await prisma.studyGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudyGroupDeleteManyArgs>(args?: SelectSubset<T, StudyGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudyGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudyGroups
     * const studyGroup = await prisma.studyGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudyGroupUpdateManyArgs>(args: SelectSubset<T, StudyGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudyGroups and returns the data updated in the database.
     * @param {StudyGroupUpdateManyAndReturnArgs} args - Arguments to update many StudyGroups.
     * @example
     * // Update many StudyGroups
     * const studyGroup = await prisma.studyGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudyGroups and only return the `id`
     * const studyGroupWithIdOnly = await prisma.studyGroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudyGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, StudyGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyGroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudyGroup.
     * @param {StudyGroupUpsertArgs} args - Arguments to update or create a StudyGroup.
     * @example
     * // Update or create a StudyGroup
     * const studyGroup = await prisma.studyGroup.upsert({
     *   create: {
     *     // ... data to create a StudyGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudyGroup we want to update
     *   }
     * })
     */
    upsert<T extends StudyGroupUpsertArgs>(args: SelectSubset<T, StudyGroupUpsertArgs<ExtArgs>>): Prisma__StudyGroupClient<$Result.GetResult<Prisma.$StudyGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudyGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyGroupCountArgs} args - Arguments to filter StudyGroups to count.
     * @example
     * // Count the number of StudyGroups
     * const count = await prisma.studyGroup.count({
     *   where: {
     *     // ... the filter for the StudyGroups we want to count
     *   }
     * })
    **/
    count<T extends StudyGroupCountArgs>(
      args?: Subset<T, StudyGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudyGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudyGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudyGroupAggregateArgs>(args: Subset<T, StudyGroupAggregateArgs>): Prisma.PrismaPromise<GetStudyGroupAggregateType<T>>

    /**
     * Group by StudyGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudyGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudyGroupGroupByArgs['orderBy'] }
        : { orderBy?: StudyGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudyGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudyGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudyGroup model
   */
  readonly fields: StudyGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudyGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudyGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    members<T extends StudyGroup$membersArgs<ExtArgs> = {}>(args?: Subset<T, StudyGroup$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyGroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudyGroup model
   */
  interface StudyGroupFieldRefs {
    readonly id: FieldRef<"StudyGroup", 'String'>
    readonly name: FieldRef<"StudyGroup", 'String'>
    readonly description: FieldRef<"StudyGroup", 'String'>
    readonly isPrivate: FieldRef<"StudyGroup", 'Boolean'>
    readonly maxMembers: FieldRef<"StudyGroup", 'Int'>
    readonly createdBy: FieldRef<"StudyGroup", 'String'>
    readonly isActive: FieldRef<"StudyGroup", 'Boolean'>
    readonly createdAt: FieldRef<"StudyGroup", 'DateTime'>
    readonly updatedAt: FieldRef<"StudyGroup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudyGroup findUnique
   */
  export type StudyGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyGroup
     */
    select?: StudyGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyGroup
     */
    omit?: StudyGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyGroupInclude<ExtArgs> | null
    /**
     * Filter, which StudyGroup to fetch.
     */
    where: StudyGroupWhereUniqueInput
  }

  /**
   * StudyGroup findUniqueOrThrow
   */
  export type StudyGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyGroup
     */
    select?: StudyGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyGroup
     */
    omit?: StudyGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyGroupInclude<ExtArgs> | null
    /**
     * Filter, which StudyGroup to fetch.
     */
    where: StudyGroupWhereUniqueInput
  }

  /**
   * StudyGroup findFirst
   */
  export type StudyGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyGroup
     */
    select?: StudyGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyGroup
     */
    omit?: StudyGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyGroupInclude<ExtArgs> | null
    /**
     * Filter, which StudyGroup to fetch.
     */
    where?: StudyGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudyGroups to fetch.
     */
    orderBy?: StudyGroupOrderByWithRelationInput | StudyGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudyGroups.
     */
    cursor?: StudyGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudyGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudyGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudyGroups.
     */
    distinct?: StudyGroupScalarFieldEnum | StudyGroupScalarFieldEnum[]
  }

  /**
   * StudyGroup findFirstOrThrow
   */
  export type StudyGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyGroup
     */
    select?: StudyGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyGroup
     */
    omit?: StudyGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyGroupInclude<ExtArgs> | null
    /**
     * Filter, which StudyGroup to fetch.
     */
    where?: StudyGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudyGroups to fetch.
     */
    orderBy?: StudyGroupOrderByWithRelationInput | StudyGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudyGroups.
     */
    cursor?: StudyGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudyGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudyGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudyGroups.
     */
    distinct?: StudyGroupScalarFieldEnum | StudyGroupScalarFieldEnum[]
  }

  /**
   * StudyGroup findMany
   */
  export type StudyGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyGroup
     */
    select?: StudyGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyGroup
     */
    omit?: StudyGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyGroupInclude<ExtArgs> | null
    /**
     * Filter, which StudyGroups to fetch.
     */
    where?: StudyGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudyGroups to fetch.
     */
    orderBy?: StudyGroupOrderByWithRelationInput | StudyGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudyGroups.
     */
    cursor?: StudyGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudyGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudyGroups.
     */
    skip?: number
    distinct?: StudyGroupScalarFieldEnum | StudyGroupScalarFieldEnum[]
  }

  /**
   * StudyGroup create
   */
  export type StudyGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyGroup
     */
    select?: StudyGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyGroup
     */
    omit?: StudyGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a StudyGroup.
     */
    data: XOR<StudyGroupCreateInput, StudyGroupUncheckedCreateInput>
  }

  /**
   * StudyGroup createMany
   */
  export type StudyGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudyGroups.
     */
    data: StudyGroupCreateManyInput | StudyGroupCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudyGroup createManyAndReturn
   */
  export type StudyGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyGroup
     */
    select?: StudyGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudyGroup
     */
    omit?: StudyGroupOmit<ExtArgs> | null
    /**
     * The data used to create many StudyGroups.
     */
    data: StudyGroupCreateManyInput | StudyGroupCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyGroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudyGroup update
   */
  export type StudyGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyGroup
     */
    select?: StudyGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyGroup
     */
    omit?: StudyGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a StudyGroup.
     */
    data: XOR<StudyGroupUpdateInput, StudyGroupUncheckedUpdateInput>
    /**
     * Choose, which StudyGroup to update.
     */
    where: StudyGroupWhereUniqueInput
  }

  /**
   * StudyGroup updateMany
   */
  export type StudyGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudyGroups.
     */
    data: XOR<StudyGroupUpdateManyMutationInput, StudyGroupUncheckedUpdateManyInput>
    /**
     * Filter which StudyGroups to update
     */
    where?: StudyGroupWhereInput
    /**
     * Limit how many StudyGroups to update.
     */
    limit?: number
  }

  /**
   * StudyGroup updateManyAndReturn
   */
  export type StudyGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyGroup
     */
    select?: StudyGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudyGroup
     */
    omit?: StudyGroupOmit<ExtArgs> | null
    /**
     * The data used to update StudyGroups.
     */
    data: XOR<StudyGroupUpdateManyMutationInput, StudyGroupUncheckedUpdateManyInput>
    /**
     * Filter which StudyGroups to update
     */
    where?: StudyGroupWhereInput
    /**
     * Limit how many StudyGroups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyGroupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudyGroup upsert
   */
  export type StudyGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyGroup
     */
    select?: StudyGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyGroup
     */
    omit?: StudyGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the StudyGroup to update in case it exists.
     */
    where: StudyGroupWhereUniqueInput
    /**
     * In case the StudyGroup found by the `where` argument doesn't exist, create a new StudyGroup with this data.
     */
    create: XOR<StudyGroupCreateInput, StudyGroupUncheckedCreateInput>
    /**
     * In case the StudyGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudyGroupUpdateInput, StudyGroupUncheckedUpdateInput>
  }

  /**
   * StudyGroup delete
   */
  export type StudyGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyGroup
     */
    select?: StudyGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyGroup
     */
    omit?: StudyGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyGroupInclude<ExtArgs> | null
    /**
     * Filter which StudyGroup to delete.
     */
    where: StudyGroupWhereUniqueInput
  }

  /**
   * StudyGroup deleteMany
   */
  export type StudyGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudyGroups to delete
     */
    where?: StudyGroupWhereInput
    /**
     * Limit how many StudyGroups to delete.
     */
    limit?: number
  }

  /**
   * StudyGroup.members
   */
  export type StudyGroup$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyGroupMember
     */
    select?: StudyGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyGroupMember
     */
    omit?: StudyGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyGroupMemberInclude<ExtArgs> | null
    where?: StudyGroupMemberWhereInput
    orderBy?: StudyGroupMemberOrderByWithRelationInput | StudyGroupMemberOrderByWithRelationInput[]
    cursor?: StudyGroupMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudyGroupMemberScalarFieldEnum | StudyGroupMemberScalarFieldEnum[]
  }

  /**
   * StudyGroup without action
   */
  export type StudyGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyGroup
     */
    select?: StudyGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyGroup
     */
    omit?: StudyGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyGroupInclude<ExtArgs> | null
  }


  /**
   * Model StudyGroupMember
   */

  export type AggregateStudyGroupMember = {
    _count: StudyGroupMemberCountAggregateOutputType | null
    _min: StudyGroupMemberMinAggregateOutputType | null
    _max: StudyGroupMemberMaxAggregateOutputType | null
  }

  export type StudyGroupMemberMinAggregateOutputType = {
    id: string | null
    groupId: string | null
    userId: string | null
    role: $Enums.GroupRole | null
    joinedAt: Date | null
    isActive: boolean | null
  }

  export type StudyGroupMemberMaxAggregateOutputType = {
    id: string | null
    groupId: string | null
    userId: string | null
    role: $Enums.GroupRole | null
    joinedAt: Date | null
    isActive: boolean | null
  }

  export type StudyGroupMemberCountAggregateOutputType = {
    id: number
    groupId: number
    userId: number
    role: number
    joinedAt: number
    isActive: number
    _all: number
  }


  export type StudyGroupMemberMinAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    role?: true
    joinedAt?: true
    isActive?: true
  }

  export type StudyGroupMemberMaxAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    role?: true
    joinedAt?: true
    isActive?: true
  }

  export type StudyGroupMemberCountAggregateInputType = {
    id?: true
    groupId?: true
    userId?: true
    role?: true
    joinedAt?: true
    isActive?: true
    _all?: true
  }

  export type StudyGroupMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudyGroupMember to aggregate.
     */
    where?: StudyGroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudyGroupMembers to fetch.
     */
    orderBy?: StudyGroupMemberOrderByWithRelationInput | StudyGroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudyGroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudyGroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudyGroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudyGroupMembers
    **/
    _count?: true | StudyGroupMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudyGroupMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudyGroupMemberMaxAggregateInputType
  }

  export type GetStudyGroupMemberAggregateType<T extends StudyGroupMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateStudyGroupMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudyGroupMember[P]>
      : GetScalarType<T[P], AggregateStudyGroupMember[P]>
  }




  export type StudyGroupMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudyGroupMemberWhereInput
    orderBy?: StudyGroupMemberOrderByWithAggregationInput | StudyGroupMemberOrderByWithAggregationInput[]
    by: StudyGroupMemberScalarFieldEnum[] | StudyGroupMemberScalarFieldEnum
    having?: StudyGroupMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudyGroupMemberCountAggregateInputType | true
    _min?: StudyGroupMemberMinAggregateInputType
    _max?: StudyGroupMemberMaxAggregateInputType
  }

  export type StudyGroupMemberGroupByOutputType = {
    id: string
    groupId: string
    userId: string
    role: $Enums.GroupRole
    joinedAt: Date
    isActive: boolean
    _count: StudyGroupMemberCountAggregateOutputType | null
    _min: StudyGroupMemberMinAggregateOutputType | null
    _max: StudyGroupMemberMaxAggregateOutputType | null
  }

  type GetStudyGroupMemberGroupByPayload<T extends StudyGroupMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudyGroupMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudyGroupMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudyGroupMemberGroupByOutputType[P]>
            : GetScalarType<T[P], StudyGroupMemberGroupByOutputType[P]>
        }
      >
    >


  export type StudyGroupMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    isActive?: boolean
    group?: boolean | StudyGroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studyGroupMember"]>

  export type StudyGroupMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    isActive?: boolean
    group?: boolean | StudyGroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studyGroupMember"]>

  export type StudyGroupMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    groupId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    isActive?: boolean
    group?: boolean | StudyGroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studyGroupMember"]>

  export type StudyGroupMemberSelectScalar = {
    id?: boolean
    groupId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    isActive?: boolean
  }

  export type StudyGroupMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "groupId" | "userId" | "role" | "joinedAt" | "isActive", ExtArgs["result"]["studyGroupMember"]>
  export type StudyGroupMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | StudyGroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StudyGroupMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | StudyGroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StudyGroupMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    group?: boolean | StudyGroupDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $StudyGroupMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudyGroupMember"
    objects: {
      group: Prisma.$StudyGroupPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      groupId: string
      userId: string
      role: $Enums.GroupRole
      joinedAt: Date
      isActive: boolean
    }, ExtArgs["result"]["studyGroupMember"]>
    composites: {}
  }

  type StudyGroupMemberGetPayload<S extends boolean | null | undefined | StudyGroupMemberDefaultArgs> = $Result.GetResult<Prisma.$StudyGroupMemberPayload, S>

  type StudyGroupMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudyGroupMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudyGroupMemberCountAggregateInputType | true
    }

  export interface StudyGroupMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudyGroupMember'], meta: { name: 'StudyGroupMember' } }
    /**
     * Find zero or one StudyGroupMember that matches the filter.
     * @param {StudyGroupMemberFindUniqueArgs} args - Arguments to find a StudyGroupMember
     * @example
     * // Get one StudyGroupMember
     * const studyGroupMember = await prisma.studyGroupMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudyGroupMemberFindUniqueArgs>(args: SelectSubset<T, StudyGroupMemberFindUniqueArgs<ExtArgs>>): Prisma__StudyGroupMemberClient<$Result.GetResult<Prisma.$StudyGroupMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudyGroupMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudyGroupMemberFindUniqueOrThrowArgs} args - Arguments to find a StudyGroupMember
     * @example
     * // Get one StudyGroupMember
     * const studyGroupMember = await prisma.studyGroupMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudyGroupMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, StudyGroupMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudyGroupMemberClient<$Result.GetResult<Prisma.$StudyGroupMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudyGroupMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyGroupMemberFindFirstArgs} args - Arguments to find a StudyGroupMember
     * @example
     * // Get one StudyGroupMember
     * const studyGroupMember = await prisma.studyGroupMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudyGroupMemberFindFirstArgs>(args?: SelectSubset<T, StudyGroupMemberFindFirstArgs<ExtArgs>>): Prisma__StudyGroupMemberClient<$Result.GetResult<Prisma.$StudyGroupMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudyGroupMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyGroupMemberFindFirstOrThrowArgs} args - Arguments to find a StudyGroupMember
     * @example
     * // Get one StudyGroupMember
     * const studyGroupMember = await prisma.studyGroupMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudyGroupMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, StudyGroupMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudyGroupMemberClient<$Result.GetResult<Prisma.$StudyGroupMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudyGroupMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyGroupMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudyGroupMembers
     * const studyGroupMembers = await prisma.studyGroupMember.findMany()
     * 
     * // Get first 10 StudyGroupMembers
     * const studyGroupMembers = await prisma.studyGroupMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studyGroupMemberWithIdOnly = await prisma.studyGroupMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudyGroupMemberFindManyArgs>(args?: SelectSubset<T, StudyGroupMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyGroupMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudyGroupMember.
     * @param {StudyGroupMemberCreateArgs} args - Arguments to create a StudyGroupMember.
     * @example
     * // Create one StudyGroupMember
     * const StudyGroupMember = await prisma.studyGroupMember.create({
     *   data: {
     *     // ... data to create a StudyGroupMember
     *   }
     * })
     * 
     */
    create<T extends StudyGroupMemberCreateArgs>(args: SelectSubset<T, StudyGroupMemberCreateArgs<ExtArgs>>): Prisma__StudyGroupMemberClient<$Result.GetResult<Prisma.$StudyGroupMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudyGroupMembers.
     * @param {StudyGroupMemberCreateManyArgs} args - Arguments to create many StudyGroupMembers.
     * @example
     * // Create many StudyGroupMembers
     * const studyGroupMember = await prisma.studyGroupMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudyGroupMemberCreateManyArgs>(args?: SelectSubset<T, StudyGroupMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudyGroupMembers and returns the data saved in the database.
     * @param {StudyGroupMemberCreateManyAndReturnArgs} args - Arguments to create many StudyGroupMembers.
     * @example
     * // Create many StudyGroupMembers
     * const studyGroupMember = await prisma.studyGroupMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudyGroupMembers and only return the `id`
     * const studyGroupMemberWithIdOnly = await prisma.studyGroupMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudyGroupMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, StudyGroupMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyGroupMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudyGroupMember.
     * @param {StudyGroupMemberDeleteArgs} args - Arguments to delete one StudyGroupMember.
     * @example
     * // Delete one StudyGroupMember
     * const StudyGroupMember = await prisma.studyGroupMember.delete({
     *   where: {
     *     // ... filter to delete one StudyGroupMember
     *   }
     * })
     * 
     */
    delete<T extends StudyGroupMemberDeleteArgs>(args: SelectSubset<T, StudyGroupMemberDeleteArgs<ExtArgs>>): Prisma__StudyGroupMemberClient<$Result.GetResult<Prisma.$StudyGroupMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudyGroupMember.
     * @param {StudyGroupMemberUpdateArgs} args - Arguments to update one StudyGroupMember.
     * @example
     * // Update one StudyGroupMember
     * const studyGroupMember = await prisma.studyGroupMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudyGroupMemberUpdateArgs>(args: SelectSubset<T, StudyGroupMemberUpdateArgs<ExtArgs>>): Prisma__StudyGroupMemberClient<$Result.GetResult<Prisma.$StudyGroupMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudyGroupMembers.
     * @param {StudyGroupMemberDeleteManyArgs} args - Arguments to filter StudyGroupMembers to delete.
     * @example
     * // Delete a few StudyGroupMembers
     * const { count } = await prisma.studyGroupMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudyGroupMemberDeleteManyArgs>(args?: SelectSubset<T, StudyGroupMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudyGroupMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyGroupMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudyGroupMembers
     * const studyGroupMember = await prisma.studyGroupMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudyGroupMemberUpdateManyArgs>(args: SelectSubset<T, StudyGroupMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudyGroupMembers and returns the data updated in the database.
     * @param {StudyGroupMemberUpdateManyAndReturnArgs} args - Arguments to update many StudyGroupMembers.
     * @example
     * // Update many StudyGroupMembers
     * const studyGroupMember = await prisma.studyGroupMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudyGroupMembers and only return the `id`
     * const studyGroupMemberWithIdOnly = await prisma.studyGroupMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudyGroupMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, StudyGroupMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudyGroupMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudyGroupMember.
     * @param {StudyGroupMemberUpsertArgs} args - Arguments to update or create a StudyGroupMember.
     * @example
     * // Update or create a StudyGroupMember
     * const studyGroupMember = await prisma.studyGroupMember.upsert({
     *   create: {
     *     // ... data to create a StudyGroupMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudyGroupMember we want to update
     *   }
     * })
     */
    upsert<T extends StudyGroupMemberUpsertArgs>(args: SelectSubset<T, StudyGroupMemberUpsertArgs<ExtArgs>>): Prisma__StudyGroupMemberClient<$Result.GetResult<Prisma.$StudyGroupMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudyGroupMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyGroupMemberCountArgs} args - Arguments to filter StudyGroupMembers to count.
     * @example
     * // Count the number of StudyGroupMembers
     * const count = await prisma.studyGroupMember.count({
     *   where: {
     *     // ... the filter for the StudyGroupMembers we want to count
     *   }
     * })
    **/
    count<T extends StudyGroupMemberCountArgs>(
      args?: Subset<T, StudyGroupMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudyGroupMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudyGroupMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyGroupMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudyGroupMemberAggregateArgs>(args: Subset<T, StudyGroupMemberAggregateArgs>): Prisma.PrismaPromise<GetStudyGroupMemberAggregateType<T>>

    /**
     * Group by StudyGroupMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudyGroupMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudyGroupMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudyGroupMemberGroupByArgs['orderBy'] }
        : { orderBy?: StudyGroupMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudyGroupMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudyGroupMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudyGroupMember model
   */
  readonly fields: StudyGroupMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudyGroupMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudyGroupMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    group<T extends StudyGroupDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudyGroupDefaultArgs<ExtArgs>>): Prisma__StudyGroupClient<$Result.GetResult<Prisma.$StudyGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudyGroupMember model
   */
  interface StudyGroupMemberFieldRefs {
    readonly id: FieldRef<"StudyGroupMember", 'String'>
    readonly groupId: FieldRef<"StudyGroupMember", 'String'>
    readonly userId: FieldRef<"StudyGroupMember", 'String'>
    readonly role: FieldRef<"StudyGroupMember", 'GroupRole'>
    readonly joinedAt: FieldRef<"StudyGroupMember", 'DateTime'>
    readonly isActive: FieldRef<"StudyGroupMember", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * StudyGroupMember findUnique
   */
  export type StudyGroupMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyGroupMember
     */
    select?: StudyGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyGroupMember
     */
    omit?: StudyGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which StudyGroupMember to fetch.
     */
    where: StudyGroupMemberWhereUniqueInput
  }

  /**
   * StudyGroupMember findUniqueOrThrow
   */
  export type StudyGroupMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyGroupMember
     */
    select?: StudyGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyGroupMember
     */
    omit?: StudyGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which StudyGroupMember to fetch.
     */
    where: StudyGroupMemberWhereUniqueInput
  }

  /**
   * StudyGroupMember findFirst
   */
  export type StudyGroupMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyGroupMember
     */
    select?: StudyGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyGroupMember
     */
    omit?: StudyGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which StudyGroupMember to fetch.
     */
    where?: StudyGroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudyGroupMembers to fetch.
     */
    orderBy?: StudyGroupMemberOrderByWithRelationInput | StudyGroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudyGroupMembers.
     */
    cursor?: StudyGroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudyGroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudyGroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudyGroupMembers.
     */
    distinct?: StudyGroupMemberScalarFieldEnum | StudyGroupMemberScalarFieldEnum[]
  }

  /**
   * StudyGroupMember findFirstOrThrow
   */
  export type StudyGroupMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyGroupMember
     */
    select?: StudyGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyGroupMember
     */
    omit?: StudyGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which StudyGroupMember to fetch.
     */
    where?: StudyGroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudyGroupMembers to fetch.
     */
    orderBy?: StudyGroupMemberOrderByWithRelationInput | StudyGroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudyGroupMembers.
     */
    cursor?: StudyGroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudyGroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudyGroupMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudyGroupMembers.
     */
    distinct?: StudyGroupMemberScalarFieldEnum | StudyGroupMemberScalarFieldEnum[]
  }

  /**
   * StudyGroupMember findMany
   */
  export type StudyGroupMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyGroupMember
     */
    select?: StudyGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyGroupMember
     */
    omit?: StudyGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyGroupMemberInclude<ExtArgs> | null
    /**
     * Filter, which StudyGroupMembers to fetch.
     */
    where?: StudyGroupMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudyGroupMembers to fetch.
     */
    orderBy?: StudyGroupMemberOrderByWithRelationInput | StudyGroupMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudyGroupMembers.
     */
    cursor?: StudyGroupMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudyGroupMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudyGroupMembers.
     */
    skip?: number
    distinct?: StudyGroupMemberScalarFieldEnum | StudyGroupMemberScalarFieldEnum[]
  }

  /**
   * StudyGroupMember create
   */
  export type StudyGroupMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyGroupMember
     */
    select?: StudyGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyGroupMember
     */
    omit?: StudyGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyGroupMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a StudyGroupMember.
     */
    data: XOR<StudyGroupMemberCreateInput, StudyGroupMemberUncheckedCreateInput>
  }

  /**
   * StudyGroupMember createMany
   */
  export type StudyGroupMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudyGroupMembers.
     */
    data: StudyGroupMemberCreateManyInput | StudyGroupMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudyGroupMember createManyAndReturn
   */
  export type StudyGroupMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyGroupMember
     */
    select?: StudyGroupMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudyGroupMember
     */
    omit?: StudyGroupMemberOmit<ExtArgs> | null
    /**
     * The data used to create many StudyGroupMembers.
     */
    data: StudyGroupMemberCreateManyInput | StudyGroupMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyGroupMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudyGroupMember update
   */
  export type StudyGroupMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyGroupMember
     */
    select?: StudyGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyGroupMember
     */
    omit?: StudyGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyGroupMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a StudyGroupMember.
     */
    data: XOR<StudyGroupMemberUpdateInput, StudyGroupMemberUncheckedUpdateInput>
    /**
     * Choose, which StudyGroupMember to update.
     */
    where: StudyGroupMemberWhereUniqueInput
  }

  /**
   * StudyGroupMember updateMany
   */
  export type StudyGroupMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudyGroupMembers.
     */
    data: XOR<StudyGroupMemberUpdateManyMutationInput, StudyGroupMemberUncheckedUpdateManyInput>
    /**
     * Filter which StudyGroupMembers to update
     */
    where?: StudyGroupMemberWhereInput
    /**
     * Limit how many StudyGroupMembers to update.
     */
    limit?: number
  }

  /**
   * StudyGroupMember updateManyAndReturn
   */
  export type StudyGroupMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyGroupMember
     */
    select?: StudyGroupMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudyGroupMember
     */
    omit?: StudyGroupMemberOmit<ExtArgs> | null
    /**
     * The data used to update StudyGroupMembers.
     */
    data: XOR<StudyGroupMemberUpdateManyMutationInput, StudyGroupMemberUncheckedUpdateManyInput>
    /**
     * Filter which StudyGroupMembers to update
     */
    where?: StudyGroupMemberWhereInput
    /**
     * Limit how many StudyGroupMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyGroupMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudyGroupMember upsert
   */
  export type StudyGroupMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyGroupMember
     */
    select?: StudyGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyGroupMember
     */
    omit?: StudyGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyGroupMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the StudyGroupMember to update in case it exists.
     */
    where: StudyGroupMemberWhereUniqueInput
    /**
     * In case the StudyGroupMember found by the `where` argument doesn't exist, create a new StudyGroupMember with this data.
     */
    create: XOR<StudyGroupMemberCreateInput, StudyGroupMemberUncheckedCreateInput>
    /**
     * In case the StudyGroupMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudyGroupMemberUpdateInput, StudyGroupMemberUncheckedUpdateInput>
  }

  /**
   * StudyGroupMember delete
   */
  export type StudyGroupMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyGroupMember
     */
    select?: StudyGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyGroupMember
     */
    omit?: StudyGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyGroupMemberInclude<ExtArgs> | null
    /**
     * Filter which StudyGroupMember to delete.
     */
    where: StudyGroupMemberWhereUniqueInput
  }

  /**
   * StudyGroupMember deleteMany
   */
  export type StudyGroupMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudyGroupMembers to delete
     */
    where?: StudyGroupMemberWhereInput
    /**
     * Limit how many StudyGroupMembers to delete.
     */
    limit?: number
  }

  /**
   * StudyGroupMember without action
   */
  export type StudyGroupMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudyGroupMember
     */
    select?: StudyGroupMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudyGroupMember
     */
    omit?: StudyGroupMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudyGroupMemberInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    resource: number
    resourceId: number
    details: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string | null
    action: string
    resource: string
    resourceId: string | null
    details: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "resource" | "resourceId" | "details" | "ipAddress" | "userAgent" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      action: string
      resource: string
      resourceId: string | null
      details: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly resource: FieldRef<"AuditLog", 'String'>
    readonly resourceId: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model ExamCategoryUser
   */

  export type AggregateExamCategoryUser = {
    _count: ExamCategoryUserCountAggregateOutputType | null
    _min: ExamCategoryUserMinAggregateOutputType | null
    _max: ExamCategoryUserMaxAggregateOutputType | null
  }

  export type ExamCategoryUserMinAggregateOutputType = {
    id: string | null
    examCategoryId: string | null
    userId: string | null
    accessLevel: $Enums.AccessLevel | null
    grantedAt: Date | null
    grantedBy: string | null
  }

  export type ExamCategoryUserMaxAggregateOutputType = {
    id: string | null
    examCategoryId: string | null
    userId: string | null
    accessLevel: $Enums.AccessLevel | null
    grantedAt: Date | null
    grantedBy: string | null
  }

  export type ExamCategoryUserCountAggregateOutputType = {
    id: number
    examCategoryId: number
    userId: number
    accessLevel: number
    grantedAt: number
    grantedBy: number
    _all: number
  }


  export type ExamCategoryUserMinAggregateInputType = {
    id?: true
    examCategoryId?: true
    userId?: true
    accessLevel?: true
    grantedAt?: true
    grantedBy?: true
  }

  export type ExamCategoryUserMaxAggregateInputType = {
    id?: true
    examCategoryId?: true
    userId?: true
    accessLevel?: true
    grantedAt?: true
    grantedBy?: true
  }

  export type ExamCategoryUserCountAggregateInputType = {
    id?: true
    examCategoryId?: true
    userId?: true
    accessLevel?: true
    grantedAt?: true
    grantedBy?: true
    _all?: true
  }

  export type ExamCategoryUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamCategoryUser to aggregate.
     */
    where?: ExamCategoryUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamCategoryUsers to fetch.
     */
    orderBy?: ExamCategoryUserOrderByWithRelationInput | ExamCategoryUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamCategoryUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamCategoryUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamCategoryUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExamCategoryUsers
    **/
    _count?: true | ExamCategoryUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamCategoryUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamCategoryUserMaxAggregateInputType
  }

  export type GetExamCategoryUserAggregateType<T extends ExamCategoryUserAggregateArgs> = {
        [P in keyof T & keyof AggregateExamCategoryUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamCategoryUser[P]>
      : GetScalarType<T[P], AggregateExamCategoryUser[P]>
  }




  export type ExamCategoryUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamCategoryUserWhereInput
    orderBy?: ExamCategoryUserOrderByWithAggregationInput | ExamCategoryUserOrderByWithAggregationInput[]
    by: ExamCategoryUserScalarFieldEnum[] | ExamCategoryUserScalarFieldEnum
    having?: ExamCategoryUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamCategoryUserCountAggregateInputType | true
    _min?: ExamCategoryUserMinAggregateInputType
    _max?: ExamCategoryUserMaxAggregateInputType
  }

  export type ExamCategoryUserGroupByOutputType = {
    id: string
    examCategoryId: string
    userId: string
    accessLevel: $Enums.AccessLevel
    grantedAt: Date
    grantedBy: string
    _count: ExamCategoryUserCountAggregateOutputType | null
    _min: ExamCategoryUserMinAggregateOutputType | null
    _max: ExamCategoryUserMaxAggregateOutputType | null
  }

  type GetExamCategoryUserGroupByPayload<T extends ExamCategoryUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamCategoryUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamCategoryUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamCategoryUserGroupByOutputType[P]>
            : GetScalarType<T[P], ExamCategoryUserGroupByOutputType[P]>
        }
      >
    >


  export type ExamCategoryUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    examCategoryId?: boolean
    userId?: boolean
    accessLevel?: boolean
    grantedAt?: boolean
    grantedBy?: boolean
    examCategory?: boolean | ExamCategoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    granter?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examCategoryUser"]>

  export type ExamCategoryUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    examCategoryId?: boolean
    userId?: boolean
    accessLevel?: boolean
    grantedAt?: boolean
    grantedBy?: boolean
    examCategory?: boolean | ExamCategoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    granter?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examCategoryUser"]>

  export type ExamCategoryUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    examCategoryId?: boolean
    userId?: boolean
    accessLevel?: boolean
    grantedAt?: boolean
    grantedBy?: boolean
    examCategory?: boolean | ExamCategoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    granter?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examCategoryUser"]>

  export type ExamCategoryUserSelectScalar = {
    id?: boolean
    examCategoryId?: boolean
    userId?: boolean
    accessLevel?: boolean
    grantedAt?: boolean
    grantedBy?: boolean
  }

  export type ExamCategoryUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "examCategoryId" | "userId" | "accessLevel" | "grantedAt" | "grantedBy", ExtArgs["result"]["examCategoryUser"]>
  export type ExamCategoryUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examCategory?: boolean | ExamCategoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    granter?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ExamCategoryUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examCategory?: boolean | ExamCategoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    granter?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ExamCategoryUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    examCategory?: boolean | ExamCategoryDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    granter?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ExamCategoryUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExamCategoryUser"
    objects: {
      examCategory: Prisma.$ExamCategoryPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      granter: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      examCategoryId: string
      userId: string
      accessLevel: $Enums.AccessLevel
      grantedAt: Date
      grantedBy: string
    }, ExtArgs["result"]["examCategoryUser"]>
    composites: {}
  }

  type ExamCategoryUserGetPayload<S extends boolean | null | undefined | ExamCategoryUserDefaultArgs> = $Result.GetResult<Prisma.$ExamCategoryUserPayload, S>

  type ExamCategoryUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExamCategoryUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExamCategoryUserCountAggregateInputType | true
    }

  export interface ExamCategoryUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExamCategoryUser'], meta: { name: 'ExamCategoryUser' } }
    /**
     * Find zero or one ExamCategoryUser that matches the filter.
     * @param {ExamCategoryUserFindUniqueArgs} args - Arguments to find a ExamCategoryUser
     * @example
     * // Get one ExamCategoryUser
     * const examCategoryUser = await prisma.examCategoryUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamCategoryUserFindUniqueArgs>(args: SelectSubset<T, ExamCategoryUserFindUniqueArgs<ExtArgs>>): Prisma__ExamCategoryUserClient<$Result.GetResult<Prisma.$ExamCategoryUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExamCategoryUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExamCategoryUserFindUniqueOrThrowArgs} args - Arguments to find a ExamCategoryUser
     * @example
     * // Get one ExamCategoryUser
     * const examCategoryUser = await prisma.examCategoryUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamCategoryUserFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamCategoryUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamCategoryUserClient<$Result.GetResult<Prisma.$ExamCategoryUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExamCategoryUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamCategoryUserFindFirstArgs} args - Arguments to find a ExamCategoryUser
     * @example
     * // Get one ExamCategoryUser
     * const examCategoryUser = await prisma.examCategoryUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamCategoryUserFindFirstArgs>(args?: SelectSubset<T, ExamCategoryUserFindFirstArgs<ExtArgs>>): Prisma__ExamCategoryUserClient<$Result.GetResult<Prisma.$ExamCategoryUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExamCategoryUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamCategoryUserFindFirstOrThrowArgs} args - Arguments to find a ExamCategoryUser
     * @example
     * // Get one ExamCategoryUser
     * const examCategoryUser = await prisma.examCategoryUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamCategoryUserFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamCategoryUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamCategoryUserClient<$Result.GetResult<Prisma.$ExamCategoryUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExamCategoryUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamCategoryUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExamCategoryUsers
     * const examCategoryUsers = await prisma.examCategoryUser.findMany()
     * 
     * // Get first 10 ExamCategoryUsers
     * const examCategoryUsers = await prisma.examCategoryUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examCategoryUserWithIdOnly = await prisma.examCategoryUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamCategoryUserFindManyArgs>(args?: SelectSubset<T, ExamCategoryUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamCategoryUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExamCategoryUser.
     * @param {ExamCategoryUserCreateArgs} args - Arguments to create a ExamCategoryUser.
     * @example
     * // Create one ExamCategoryUser
     * const ExamCategoryUser = await prisma.examCategoryUser.create({
     *   data: {
     *     // ... data to create a ExamCategoryUser
     *   }
     * })
     * 
     */
    create<T extends ExamCategoryUserCreateArgs>(args: SelectSubset<T, ExamCategoryUserCreateArgs<ExtArgs>>): Prisma__ExamCategoryUserClient<$Result.GetResult<Prisma.$ExamCategoryUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExamCategoryUsers.
     * @param {ExamCategoryUserCreateManyArgs} args - Arguments to create many ExamCategoryUsers.
     * @example
     * // Create many ExamCategoryUsers
     * const examCategoryUser = await prisma.examCategoryUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamCategoryUserCreateManyArgs>(args?: SelectSubset<T, ExamCategoryUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExamCategoryUsers and returns the data saved in the database.
     * @param {ExamCategoryUserCreateManyAndReturnArgs} args - Arguments to create many ExamCategoryUsers.
     * @example
     * // Create many ExamCategoryUsers
     * const examCategoryUser = await prisma.examCategoryUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExamCategoryUsers and only return the `id`
     * const examCategoryUserWithIdOnly = await prisma.examCategoryUser.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExamCategoryUserCreateManyAndReturnArgs>(args?: SelectSubset<T, ExamCategoryUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamCategoryUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExamCategoryUser.
     * @param {ExamCategoryUserDeleteArgs} args - Arguments to delete one ExamCategoryUser.
     * @example
     * // Delete one ExamCategoryUser
     * const ExamCategoryUser = await prisma.examCategoryUser.delete({
     *   where: {
     *     // ... filter to delete one ExamCategoryUser
     *   }
     * })
     * 
     */
    delete<T extends ExamCategoryUserDeleteArgs>(args: SelectSubset<T, ExamCategoryUserDeleteArgs<ExtArgs>>): Prisma__ExamCategoryUserClient<$Result.GetResult<Prisma.$ExamCategoryUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExamCategoryUser.
     * @param {ExamCategoryUserUpdateArgs} args - Arguments to update one ExamCategoryUser.
     * @example
     * // Update one ExamCategoryUser
     * const examCategoryUser = await prisma.examCategoryUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamCategoryUserUpdateArgs>(args: SelectSubset<T, ExamCategoryUserUpdateArgs<ExtArgs>>): Prisma__ExamCategoryUserClient<$Result.GetResult<Prisma.$ExamCategoryUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExamCategoryUsers.
     * @param {ExamCategoryUserDeleteManyArgs} args - Arguments to filter ExamCategoryUsers to delete.
     * @example
     * // Delete a few ExamCategoryUsers
     * const { count } = await prisma.examCategoryUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamCategoryUserDeleteManyArgs>(args?: SelectSubset<T, ExamCategoryUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamCategoryUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamCategoryUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExamCategoryUsers
     * const examCategoryUser = await prisma.examCategoryUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamCategoryUserUpdateManyArgs>(args: SelectSubset<T, ExamCategoryUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamCategoryUsers and returns the data updated in the database.
     * @param {ExamCategoryUserUpdateManyAndReturnArgs} args - Arguments to update many ExamCategoryUsers.
     * @example
     * // Update many ExamCategoryUsers
     * const examCategoryUser = await prisma.examCategoryUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExamCategoryUsers and only return the `id`
     * const examCategoryUserWithIdOnly = await prisma.examCategoryUser.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExamCategoryUserUpdateManyAndReturnArgs>(args: SelectSubset<T, ExamCategoryUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamCategoryUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExamCategoryUser.
     * @param {ExamCategoryUserUpsertArgs} args - Arguments to update or create a ExamCategoryUser.
     * @example
     * // Update or create a ExamCategoryUser
     * const examCategoryUser = await prisma.examCategoryUser.upsert({
     *   create: {
     *     // ... data to create a ExamCategoryUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExamCategoryUser we want to update
     *   }
     * })
     */
    upsert<T extends ExamCategoryUserUpsertArgs>(args: SelectSubset<T, ExamCategoryUserUpsertArgs<ExtArgs>>): Prisma__ExamCategoryUserClient<$Result.GetResult<Prisma.$ExamCategoryUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExamCategoryUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamCategoryUserCountArgs} args - Arguments to filter ExamCategoryUsers to count.
     * @example
     * // Count the number of ExamCategoryUsers
     * const count = await prisma.examCategoryUser.count({
     *   where: {
     *     // ... the filter for the ExamCategoryUsers we want to count
     *   }
     * })
    **/
    count<T extends ExamCategoryUserCountArgs>(
      args?: Subset<T, ExamCategoryUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamCategoryUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExamCategoryUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamCategoryUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamCategoryUserAggregateArgs>(args: Subset<T, ExamCategoryUserAggregateArgs>): Prisma.PrismaPromise<GetExamCategoryUserAggregateType<T>>

    /**
     * Group by ExamCategoryUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamCategoryUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamCategoryUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamCategoryUserGroupByArgs['orderBy'] }
        : { orderBy?: ExamCategoryUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamCategoryUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamCategoryUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExamCategoryUser model
   */
  readonly fields: ExamCategoryUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExamCategoryUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamCategoryUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    examCategory<T extends ExamCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ExamCategoryDefaultArgs<ExtArgs>>): Prisma__ExamCategoryClient<$Result.GetResult<Prisma.$ExamCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    granter<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExamCategoryUser model
   */
  interface ExamCategoryUserFieldRefs {
    readonly id: FieldRef<"ExamCategoryUser", 'String'>
    readonly examCategoryId: FieldRef<"ExamCategoryUser", 'String'>
    readonly userId: FieldRef<"ExamCategoryUser", 'String'>
    readonly accessLevel: FieldRef<"ExamCategoryUser", 'AccessLevel'>
    readonly grantedAt: FieldRef<"ExamCategoryUser", 'DateTime'>
    readonly grantedBy: FieldRef<"ExamCategoryUser", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ExamCategoryUser findUnique
   */
  export type ExamCategoryUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamCategoryUser
     */
    select?: ExamCategoryUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamCategoryUser
     */
    omit?: ExamCategoryUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamCategoryUserInclude<ExtArgs> | null
    /**
     * Filter, which ExamCategoryUser to fetch.
     */
    where: ExamCategoryUserWhereUniqueInput
  }

  /**
   * ExamCategoryUser findUniqueOrThrow
   */
  export type ExamCategoryUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamCategoryUser
     */
    select?: ExamCategoryUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamCategoryUser
     */
    omit?: ExamCategoryUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamCategoryUserInclude<ExtArgs> | null
    /**
     * Filter, which ExamCategoryUser to fetch.
     */
    where: ExamCategoryUserWhereUniqueInput
  }

  /**
   * ExamCategoryUser findFirst
   */
  export type ExamCategoryUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamCategoryUser
     */
    select?: ExamCategoryUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamCategoryUser
     */
    omit?: ExamCategoryUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamCategoryUserInclude<ExtArgs> | null
    /**
     * Filter, which ExamCategoryUser to fetch.
     */
    where?: ExamCategoryUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamCategoryUsers to fetch.
     */
    orderBy?: ExamCategoryUserOrderByWithRelationInput | ExamCategoryUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamCategoryUsers.
     */
    cursor?: ExamCategoryUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamCategoryUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamCategoryUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamCategoryUsers.
     */
    distinct?: ExamCategoryUserScalarFieldEnum | ExamCategoryUserScalarFieldEnum[]
  }

  /**
   * ExamCategoryUser findFirstOrThrow
   */
  export type ExamCategoryUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamCategoryUser
     */
    select?: ExamCategoryUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamCategoryUser
     */
    omit?: ExamCategoryUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamCategoryUserInclude<ExtArgs> | null
    /**
     * Filter, which ExamCategoryUser to fetch.
     */
    where?: ExamCategoryUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamCategoryUsers to fetch.
     */
    orderBy?: ExamCategoryUserOrderByWithRelationInput | ExamCategoryUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamCategoryUsers.
     */
    cursor?: ExamCategoryUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamCategoryUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamCategoryUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamCategoryUsers.
     */
    distinct?: ExamCategoryUserScalarFieldEnum | ExamCategoryUserScalarFieldEnum[]
  }

  /**
   * ExamCategoryUser findMany
   */
  export type ExamCategoryUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamCategoryUser
     */
    select?: ExamCategoryUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamCategoryUser
     */
    omit?: ExamCategoryUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamCategoryUserInclude<ExtArgs> | null
    /**
     * Filter, which ExamCategoryUsers to fetch.
     */
    where?: ExamCategoryUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamCategoryUsers to fetch.
     */
    orderBy?: ExamCategoryUserOrderByWithRelationInput | ExamCategoryUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExamCategoryUsers.
     */
    cursor?: ExamCategoryUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamCategoryUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamCategoryUsers.
     */
    skip?: number
    distinct?: ExamCategoryUserScalarFieldEnum | ExamCategoryUserScalarFieldEnum[]
  }

  /**
   * ExamCategoryUser create
   */
  export type ExamCategoryUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamCategoryUser
     */
    select?: ExamCategoryUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamCategoryUser
     */
    omit?: ExamCategoryUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamCategoryUserInclude<ExtArgs> | null
    /**
     * The data needed to create a ExamCategoryUser.
     */
    data: XOR<ExamCategoryUserCreateInput, ExamCategoryUserUncheckedCreateInput>
  }

  /**
   * ExamCategoryUser createMany
   */
  export type ExamCategoryUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExamCategoryUsers.
     */
    data: ExamCategoryUserCreateManyInput | ExamCategoryUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExamCategoryUser createManyAndReturn
   */
  export type ExamCategoryUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamCategoryUser
     */
    select?: ExamCategoryUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExamCategoryUser
     */
    omit?: ExamCategoryUserOmit<ExtArgs> | null
    /**
     * The data used to create many ExamCategoryUsers.
     */
    data: ExamCategoryUserCreateManyInput | ExamCategoryUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamCategoryUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExamCategoryUser update
   */
  export type ExamCategoryUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamCategoryUser
     */
    select?: ExamCategoryUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamCategoryUser
     */
    omit?: ExamCategoryUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamCategoryUserInclude<ExtArgs> | null
    /**
     * The data needed to update a ExamCategoryUser.
     */
    data: XOR<ExamCategoryUserUpdateInput, ExamCategoryUserUncheckedUpdateInput>
    /**
     * Choose, which ExamCategoryUser to update.
     */
    where: ExamCategoryUserWhereUniqueInput
  }

  /**
   * ExamCategoryUser updateMany
   */
  export type ExamCategoryUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExamCategoryUsers.
     */
    data: XOR<ExamCategoryUserUpdateManyMutationInput, ExamCategoryUserUncheckedUpdateManyInput>
    /**
     * Filter which ExamCategoryUsers to update
     */
    where?: ExamCategoryUserWhereInput
    /**
     * Limit how many ExamCategoryUsers to update.
     */
    limit?: number
  }

  /**
   * ExamCategoryUser updateManyAndReturn
   */
  export type ExamCategoryUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamCategoryUser
     */
    select?: ExamCategoryUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExamCategoryUser
     */
    omit?: ExamCategoryUserOmit<ExtArgs> | null
    /**
     * The data used to update ExamCategoryUsers.
     */
    data: XOR<ExamCategoryUserUpdateManyMutationInput, ExamCategoryUserUncheckedUpdateManyInput>
    /**
     * Filter which ExamCategoryUsers to update
     */
    where?: ExamCategoryUserWhereInput
    /**
     * Limit how many ExamCategoryUsers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamCategoryUserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExamCategoryUser upsert
   */
  export type ExamCategoryUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamCategoryUser
     */
    select?: ExamCategoryUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamCategoryUser
     */
    omit?: ExamCategoryUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamCategoryUserInclude<ExtArgs> | null
    /**
     * The filter to search for the ExamCategoryUser to update in case it exists.
     */
    where: ExamCategoryUserWhereUniqueInput
    /**
     * In case the ExamCategoryUser found by the `where` argument doesn't exist, create a new ExamCategoryUser with this data.
     */
    create: XOR<ExamCategoryUserCreateInput, ExamCategoryUserUncheckedCreateInput>
    /**
     * In case the ExamCategoryUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamCategoryUserUpdateInput, ExamCategoryUserUncheckedUpdateInput>
  }

  /**
   * ExamCategoryUser delete
   */
  export type ExamCategoryUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamCategoryUser
     */
    select?: ExamCategoryUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamCategoryUser
     */
    omit?: ExamCategoryUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamCategoryUserInclude<ExtArgs> | null
    /**
     * Filter which ExamCategoryUser to delete.
     */
    where: ExamCategoryUserWhereUniqueInput
  }

  /**
   * ExamCategoryUser deleteMany
   */
  export type ExamCategoryUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamCategoryUsers to delete
     */
    where?: ExamCategoryUserWhereInput
    /**
     * Limit how many ExamCategoryUsers to delete.
     */
    limit?: number
  }

  /**
   * ExamCategoryUser without action
   */
  export type ExamCategoryUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamCategoryUser
     */
    select?: ExamCategoryUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamCategoryUser
     */
    omit?: ExamCategoryUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamCategoryUserInclude<ExtArgs> | null
  }


  /**
   * Model ExamStatisticsView
   */

  export type AggregateExamStatisticsView = {
    _count: ExamStatisticsViewCountAggregateOutputType | null
    _avg: ExamStatisticsViewAvgAggregateOutputType | null
    _sum: ExamStatisticsViewSumAggregateOutputType | null
    _min: ExamStatisticsViewMinAggregateOutputType | null
    _max: ExamStatisticsViewMaxAggregateOutputType | null
  }

  export type ExamStatisticsViewAvgAggregateOutputType = {
    totalAttempts: number | null
    totalBookings: number | null
    totalRevenue: Decimal | null
    averageScore: number | null
    passRate: number | null
    averageTime: number | null
  }

  export type ExamStatisticsViewSumAggregateOutputType = {
    totalAttempts: number | null
    totalBookings: number | null
    totalRevenue: Decimal | null
    averageScore: number | null
    passRate: number | null
    averageTime: number | null
  }

  export type ExamStatisticsViewMinAggregateOutputType = {
    examId: string | null
    examTitle: string | null
    totalAttempts: number | null
    totalBookings: number | null
    totalRevenue: Decimal | null
    averageScore: number | null
    passRate: number | null
    averageTime: number | null
    lastAttemptDate: Date | null
  }

  export type ExamStatisticsViewMaxAggregateOutputType = {
    examId: string | null
    examTitle: string | null
    totalAttempts: number | null
    totalBookings: number | null
    totalRevenue: Decimal | null
    averageScore: number | null
    passRate: number | null
    averageTime: number | null
    lastAttemptDate: Date | null
  }

  export type ExamStatisticsViewCountAggregateOutputType = {
    examId: number
    examTitle: number
    totalAttempts: number
    totalBookings: number
    totalRevenue: number
    averageScore: number
    passRate: number
    averageTime: number
    lastAttemptDate: number
    _all: number
  }


  export type ExamStatisticsViewAvgAggregateInputType = {
    totalAttempts?: true
    totalBookings?: true
    totalRevenue?: true
    averageScore?: true
    passRate?: true
    averageTime?: true
  }

  export type ExamStatisticsViewSumAggregateInputType = {
    totalAttempts?: true
    totalBookings?: true
    totalRevenue?: true
    averageScore?: true
    passRate?: true
    averageTime?: true
  }

  export type ExamStatisticsViewMinAggregateInputType = {
    examId?: true
    examTitle?: true
    totalAttempts?: true
    totalBookings?: true
    totalRevenue?: true
    averageScore?: true
    passRate?: true
    averageTime?: true
    lastAttemptDate?: true
  }

  export type ExamStatisticsViewMaxAggregateInputType = {
    examId?: true
    examTitle?: true
    totalAttempts?: true
    totalBookings?: true
    totalRevenue?: true
    averageScore?: true
    passRate?: true
    averageTime?: true
    lastAttemptDate?: true
  }

  export type ExamStatisticsViewCountAggregateInputType = {
    examId?: true
    examTitle?: true
    totalAttempts?: true
    totalBookings?: true
    totalRevenue?: true
    averageScore?: true
    passRate?: true
    averageTime?: true
    lastAttemptDate?: true
    _all?: true
  }

  export type ExamStatisticsViewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamStatisticsView to aggregate.
     */
    where?: ExamStatisticsViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamStatisticsViews to fetch.
     */
    orderBy?: ExamStatisticsViewOrderByWithRelationInput | ExamStatisticsViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamStatisticsViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamStatisticsViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamStatisticsViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExamStatisticsViews
    **/
    _count?: true | ExamStatisticsViewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamStatisticsViewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamStatisticsViewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamStatisticsViewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamStatisticsViewMaxAggregateInputType
  }

  export type GetExamStatisticsViewAggregateType<T extends ExamStatisticsViewAggregateArgs> = {
        [P in keyof T & keyof AggregateExamStatisticsView]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamStatisticsView[P]>
      : GetScalarType<T[P], AggregateExamStatisticsView[P]>
  }




  export type ExamStatisticsViewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamStatisticsViewWhereInput
    orderBy?: ExamStatisticsViewOrderByWithAggregationInput | ExamStatisticsViewOrderByWithAggregationInput[]
    by: ExamStatisticsViewScalarFieldEnum[] | ExamStatisticsViewScalarFieldEnum
    having?: ExamStatisticsViewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamStatisticsViewCountAggregateInputType | true
    _avg?: ExamStatisticsViewAvgAggregateInputType
    _sum?: ExamStatisticsViewSumAggregateInputType
    _min?: ExamStatisticsViewMinAggregateInputType
    _max?: ExamStatisticsViewMaxAggregateInputType
  }

  export type ExamStatisticsViewGroupByOutputType = {
    examId: string
    examTitle: string
    totalAttempts: number
    totalBookings: number
    totalRevenue: Decimal
    averageScore: number
    passRate: number
    averageTime: number
    lastAttemptDate: Date | null
    _count: ExamStatisticsViewCountAggregateOutputType | null
    _avg: ExamStatisticsViewAvgAggregateOutputType | null
    _sum: ExamStatisticsViewSumAggregateOutputType | null
    _min: ExamStatisticsViewMinAggregateOutputType | null
    _max: ExamStatisticsViewMaxAggregateOutputType | null
  }

  type GetExamStatisticsViewGroupByPayload<T extends ExamStatisticsViewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamStatisticsViewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamStatisticsViewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamStatisticsViewGroupByOutputType[P]>
            : GetScalarType<T[P], ExamStatisticsViewGroupByOutputType[P]>
        }
      >
    >


  export type ExamStatisticsViewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    examId?: boolean
    examTitle?: boolean
    totalAttempts?: boolean
    totalBookings?: boolean
    totalRevenue?: boolean
    averageScore?: boolean
    passRate?: boolean
    averageTime?: boolean
    lastAttemptDate?: boolean
  }, ExtArgs["result"]["examStatisticsView"]>

  export type ExamStatisticsViewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    examId?: boolean
    examTitle?: boolean
    totalAttempts?: boolean
    totalBookings?: boolean
    totalRevenue?: boolean
    averageScore?: boolean
    passRate?: boolean
    averageTime?: boolean
    lastAttemptDate?: boolean
  }, ExtArgs["result"]["examStatisticsView"]>

  export type ExamStatisticsViewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    examId?: boolean
    examTitle?: boolean
    totalAttempts?: boolean
    totalBookings?: boolean
    totalRevenue?: boolean
    averageScore?: boolean
    passRate?: boolean
    averageTime?: boolean
    lastAttemptDate?: boolean
  }, ExtArgs["result"]["examStatisticsView"]>

  export type ExamStatisticsViewSelectScalar = {
    examId?: boolean
    examTitle?: boolean
    totalAttempts?: boolean
    totalBookings?: boolean
    totalRevenue?: boolean
    averageScore?: boolean
    passRate?: boolean
    averageTime?: boolean
    lastAttemptDate?: boolean
  }

  export type ExamStatisticsViewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"examId" | "examTitle" | "totalAttempts" | "totalBookings" | "totalRevenue" | "averageScore" | "passRate" | "averageTime" | "lastAttemptDate", ExtArgs["result"]["examStatisticsView"]>

  export type $ExamStatisticsViewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExamStatisticsView"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      examId: string
      examTitle: string
      totalAttempts: number
      totalBookings: number
      totalRevenue: Prisma.Decimal
      averageScore: number
      passRate: number
      averageTime: number
      lastAttemptDate: Date | null
    }, ExtArgs["result"]["examStatisticsView"]>
    composites: {}
  }

  type ExamStatisticsViewGetPayload<S extends boolean | null | undefined | ExamStatisticsViewDefaultArgs> = $Result.GetResult<Prisma.$ExamStatisticsViewPayload, S>

  type ExamStatisticsViewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExamStatisticsViewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExamStatisticsViewCountAggregateInputType | true
    }

  export interface ExamStatisticsViewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExamStatisticsView'], meta: { name: 'ExamStatisticsView' } }
    /**
     * Find zero or one ExamStatisticsView that matches the filter.
     * @param {ExamStatisticsViewFindUniqueArgs} args - Arguments to find a ExamStatisticsView
     * @example
     * // Get one ExamStatisticsView
     * const examStatisticsView = await prisma.examStatisticsView.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamStatisticsViewFindUniqueArgs>(args: SelectSubset<T, ExamStatisticsViewFindUniqueArgs<ExtArgs>>): Prisma__ExamStatisticsViewClient<$Result.GetResult<Prisma.$ExamStatisticsViewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExamStatisticsView that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExamStatisticsViewFindUniqueOrThrowArgs} args - Arguments to find a ExamStatisticsView
     * @example
     * // Get one ExamStatisticsView
     * const examStatisticsView = await prisma.examStatisticsView.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamStatisticsViewFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamStatisticsViewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamStatisticsViewClient<$Result.GetResult<Prisma.$ExamStatisticsViewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExamStatisticsView that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamStatisticsViewFindFirstArgs} args - Arguments to find a ExamStatisticsView
     * @example
     * // Get one ExamStatisticsView
     * const examStatisticsView = await prisma.examStatisticsView.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamStatisticsViewFindFirstArgs>(args?: SelectSubset<T, ExamStatisticsViewFindFirstArgs<ExtArgs>>): Prisma__ExamStatisticsViewClient<$Result.GetResult<Prisma.$ExamStatisticsViewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExamStatisticsView that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamStatisticsViewFindFirstOrThrowArgs} args - Arguments to find a ExamStatisticsView
     * @example
     * // Get one ExamStatisticsView
     * const examStatisticsView = await prisma.examStatisticsView.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamStatisticsViewFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamStatisticsViewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamStatisticsViewClient<$Result.GetResult<Prisma.$ExamStatisticsViewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExamStatisticsViews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamStatisticsViewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExamStatisticsViews
     * const examStatisticsViews = await prisma.examStatisticsView.findMany()
     * 
     * // Get first 10 ExamStatisticsViews
     * const examStatisticsViews = await prisma.examStatisticsView.findMany({ take: 10 })
     * 
     * // Only select the `examId`
     * const examStatisticsViewWithExamIdOnly = await prisma.examStatisticsView.findMany({ select: { examId: true } })
     * 
     */
    findMany<T extends ExamStatisticsViewFindManyArgs>(args?: SelectSubset<T, ExamStatisticsViewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamStatisticsViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExamStatisticsView.
     * @param {ExamStatisticsViewCreateArgs} args - Arguments to create a ExamStatisticsView.
     * @example
     * // Create one ExamStatisticsView
     * const ExamStatisticsView = await prisma.examStatisticsView.create({
     *   data: {
     *     // ... data to create a ExamStatisticsView
     *   }
     * })
     * 
     */
    create<T extends ExamStatisticsViewCreateArgs>(args: SelectSubset<T, ExamStatisticsViewCreateArgs<ExtArgs>>): Prisma__ExamStatisticsViewClient<$Result.GetResult<Prisma.$ExamStatisticsViewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExamStatisticsViews.
     * @param {ExamStatisticsViewCreateManyArgs} args - Arguments to create many ExamStatisticsViews.
     * @example
     * // Create many ExamStatisticsViews
     * const examStatisticsView = await prisma.examStatisticsView.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamStatisticsViewCreateManyArgs>(args?: SelectSubset<T, ExamStatisticsViewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExamStatisticsViews and returns the data saved in the database.
     * @param {ExamStatisticsViewCreateManyAndReturnArgs} args - Arguments to create many ExamStatisticsViews.
     * @example
     * // Create many ExamStatisticsViews
     * const examStatisticsView = await prisma.examStatisticsView.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExamStatisticsViews and only return the `examId`
     * const examStatisticsViewWithExamIdOnly = await prisma.examStatisticsView.createManyAndReturn({
     *   select: { examId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExamStatisticsViewCreateManyAndReturnArgs>(args?: SelectSubset<T, ExamStatisticsViewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamStatisticsViewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExamStatisticsView.
     * @param {ExamStatisticsViewDeleteArgs} args - Arguments to delete one ExamStatisticsView.
     * @example
     * // Delete one ExamStatisticsView
     * const ExamStatisticsView = await prisma.examStatisticsView.delete({
     *   where: {
     *     // ... filter to delete one ExamStatisticsView
     *   }
     * })
     * 
     */
    delete<T extends ExamStatisticsViewDeleteArgs>(args: SelectSubset<T, ExamStatisticsViewDeleteArgs<ExtArgs>>): Prisma__ExamStatisticsViewClient<$Result.GetResult<Prisma.$ExamStatisticsViewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExamStatisticsView.
     * @param {ExamStatisticsViewUpdateArgs} args - Arguments to update one ExamStatisticsView.
     * @example
     * // Update one ExamStatisticsView
     * const examStatisticsView = await prisma.examStatisticsView.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamStatisticsViewUpdateArgs>(args: SelectSubset<T, ExamStatisticsViewUpdateArgs<ExtArgs>>): Prisma__ExamStatisticsViewClient<$Result.GetResult<Prisma.$ExamStatisticsViewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExamStatisticsViews.
     * @param {ExamStatisticsViewDeleteManyArgs} args - Arguments to filter ExamStatisticsViews to delete.
     * @example
     * // Delete a few ExamStatisticsViews
     * const { count } = await prisma.examStatisticsView.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamStatisticsViewDeleteManyArgs>(args?: SelectSubset<T, ExamStatisticsViewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamStatisticsViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamStatisticsViewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExamStatisticsViews
     * const examStatisticsView = await prisma.examStatisticsView.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamStatisticsViewUpdateManyArgs>(args: SelectSubset<T, ExamStatisticsViewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamStatisticsViews and returns the data updated in the database.
     * @param {ExamStatisticsViewUpdateManyAndReturnArgs} args - Arguments to update many ExamStatisticsViews.
     * @example
     * // Update many ExamStatisticsViews
     * const examStatisticsView = await prisma.examStatisticsView.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExamStatisticsViews and only return the `examId`
     * const examStatisticsViewWithExamIdOnly = await prisma.examStatisticsView.updateManyAndReturn({
     *   select: { examId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExamStatisticsViewUpdateManyAndReturnArgs>(args: SelectSubset<T, ExamStatisticsViewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamStatisticsViewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExamStatisticsView.
     * @param {ExamStatisticsViewUpsertArgs} args - Arguments to update or create a ExamStatisticsView.
     * @example
     * // Update or create a ExamStatisticsView
     * const examStatisticsView = await prisma.examStatisticsView.upsert({
     *   create: {
     *     // ... data to create a ExamStatisticsView
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExamStatisticsView we want to update
     *   }
     * })
     */
    upsert<T extends ExamStatisticsViewUpsertArgs>(args: SelectSubset<T, ExamStatisticsViewUpsertArgs<ExtArgs>>): Prisma__ExamStatisticsViewClient<$Result.GetResult<Prisma.$ExamStatisticsViewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExamStatisticsViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamStatisticsViewCountArgs} args - Arguments to filter ExamStatisticsViews to count.
     * @example
     * // Count the number of ExamStatisticsViews
     * const count = await prisma.examStatisticsView.count({
     *   where: {
     *     // ... the filter for the ExamStatisticsViews we want to count
     *   }
     * })
    **/
    count<T extends ExamStatisticsViewCountArgs>(
      args?: Subset<T, ExamStatisticsViewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamStatisticsViewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExamStatisticsView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamStatisticsViewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamStatisticsViewAggregateArgs>(args: Subset<T, ExamStatisticsViewAggregateArgs>): Prisma.PrismaPromise<GetExamStatisticsViewAggregateType<T>>

    /**
     * Group by ExamStatisticsView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamStatisticsViewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamStatisticsViewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamStatisticsViewGroupByArgs['orderBy'] }
        : { orderBy?: ExamStatisticsViewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamStatisticsViewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamStatisticsViewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExamStatisticsView model
   */
  readonly fields: ExamStatisticsViewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExamStatisticsView.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamStatisticsViewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExamStatisticsView model
   */
  interface ExamStatisticsViewFieldRefs {
    readonly examId: FieldRef<"ExamStatisticsView", 'String'>
    readonly examTitle: FieldRef<"ExamStatisticsView", 'String'>
    readonly totalAttempts: FieldRef<"ExamStatisticsView", 'Int'>
    readonly totalBookings: FieldRef<"ExamStatisticsView", 'Int'>
    readonly totalRevenue: FieldRef<"ExamStatisticsView", 'Decimal'>
    readonly averageScore: FieldRef<"ExamStatisticsView", 'Float'>
    readonly passRate: FieldRef<"ExamStatisticsView", 'Float'>
    readonly averageTime: FieldRef<"ExamStatisticsView", 'Int'>
    readonly lastAttemptDate: FieldRef<"ExamStatisticsView", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExamStatisticsView findUnique
   */
  export type ExamStatisticsViewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamStatisticsView
     */
    select?: ExamStatisticsViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamStatisticsView
     */
    omit?: ExamStatisticsViewOmit<ExtArgs> | null
    /**
     * Filter, which ExamStatisticsView to fetch.
     */
    where: ExamStatisticsViewWhereUniqueInput
  }

  /**
   * ExamStatisticsView findUniqueOrThrow
   */
  export type ExamStatisticsViewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamStatisticsView
     */
    select?: ExamStatisticsViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamStatisticsView
     */
    omit?: ExamStatisticsViewOmit<ExtArgs> | null
    /**
     * Filter, which ExamStatisticsView to fetch.
     */
    where: ExamStatisticsViewWhereUniqueInput
  }

  /**
   * ExamStatisticsView findFirst
   */
  export type ExamStatisticsViewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamStatisticsView
     */
    select?: ExamStatisticsViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamStatisticsView
     */
    omit?: ExamStatisticsViewOmit<ExtArgs> | null
    /**
     * Filter, which ExamStatisticsView to fetch.
     */
    where?: ExamStatisticsViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamStatisticsViews to fetch.
     */
    orderBy?: ExamStatisticsViewOrderByWithRelationInput | ExamStatisticsViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamStatisticsViews.
     */
    cursor?: ExamStatisticsViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamStatisticsViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamStatisticsViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamStatisticsViews.
     */
    distinct?: ExamStatisticsViewScalarFieldEnum | ExamStatisticsViewScalarFieldEnum[]
  }

  /**
   * ExamStatisticsView findFirstOrThrow
   */
  export type ExamStatisticsViewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamStatisticsView
     */
    select?: ExamStatisticsViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamStatisticsView
     */
    omit?: ExamStatisticsViewOmit<ExtArgs> | null
    /**
     * Filter, which ExamStatisticsView to fetch.
     */
    where?: ExamStatisticsViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamStatisticsViews to fetch.
     */
    orderBy?: ExamStatisticsViewOrderByWithRelationInput | ExamStatisticsViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamStatisticsViews.
     */
    cursor?: ExamStatisticsViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamStatisticsViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamStatisticsViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamStatisticsViews.
     */
    distinct?: ExamStatisticsViewScalarFieldEnum | ExamStatisticsViewScalarFieldEnum[]
  }

  /**
   * ExamStatisticsView findMany
   */
  export type ExamStatisticsViewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamStatisticsView
     */
    select?: ExamStatisticsViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamStatisticsView
     */
    omit?: ExamStatisticsViewOmit<ExtArgs> | null
    /**
     * Filter, which ExamStatisticsViews to fetch.
     */
    where?: ExamStatisticsViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamStatisticsViews to fetch.
     */
    orderBy?: ExamStatisticsViewOrderByWithRelationInput | ExamStatisticsViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExamStatisticsViews.
     */
    cursor?: ExamStatisticsViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamStatisticsViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamStatisticsViews.
     */
    skip?: number
    distinct?: ExamStatisticsViewScalarFieldEnum | ExamStatisticsViewScalarFieldEnum[]
  }

  /**
   * ExamStatisticsView create
   */
  export type ExamStatisticsViewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamStatisticsView
     */
    select?: ExamStatisticsViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamStatisticsView
     */
    omit?: ExamStatisticsViewOmit<ExtArgs> | null
    /**
     * The data needed to create a ExamStatisticsView.
     */
    data: XOR<ExamStatisticsViewCreateInput, ExamStatisticsViewUncheckedCreateInput>
  }

  /**
   * ExamStatisticsView createMany
   */
  export type ExamStatisticsViewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExamStatisticsViews.
     */
    data: ExamStatisticsViewCreateManyInput | ExamStatisticsViewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExamStatisticsView createManyAndReturn
   */
  export type ExamStatisticsViewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamStatisticsView
     */
    select?: ExamStatisticsViewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExamStatisticsView
     */
    omit?: ExamStatisticsViewOmit<ExtArgs> | null
    /**
     * The data used to create many ExamStatisticsViews.
     */
    data: ExamStatisticsViewCreateManyInput | ExamStatisticsViewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExamStatisticsView update
   */
  export type ExamStatisticsViewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamStatisticsView
     */
    select?: ExamStatisticsViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamStatisticsView
     */
    omit?: ExamStatisticsViewOmit<ExtArgs> | null
    /**
     * The data needed to update a ExamStatisticsView.
     */
    data: XOR<ExamStatisticsViewUpdateInput, ExamStatisticsViewUncheckedUpdateInput>
    /**
     * Choose, which ExamStatisticsView to update.
     */
    where: ExamStatisticsViewWhereUniqueInput
  }

  /**
   * ExamStatisticsView updateMany
   */
  export type ExamStatisticsViewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExamStatisticsViews.
     */
    data: XOR<ExamStatisticsViewUpdateManyMutationInput, ExamStatisticsViewUncheckedUpdateManyInput>
    /**
     * Filter which ExamStatisticsViews to update
     */
    where?: ExamStatisticsViewWhereInput
    /**
     * Limit how many ExamStatisticsViews to update.
     */
    limit?: number
  }

  /**
   * ExamStatisticsView updateManyAndReturn
   */
  export type ExamStatisticsViewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamStatisticsView
     */
    select?: ExamStatisticsViewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExamStatisticsView
     */
    omit?: ExamStatisticsViewOmit<ExtArgs> | null
    /**
     * The data used to update ExamStatisticsViews.
     */
    data: XOR<ExamStatisticsViewUpdateManyMutationInput, ExamStatisticsViewUncheckedUpdateManyInput>
    /**
     * Filter which ExamStatisticsViews to update
     */
    where?: ExamStatisticsViewWhereInput
    /**
     * Limit how many ExamStatisticsViews to update.
     */
    limit?: number
  }

  /**
   * ExamStatisticsView upsert
   */
  export type ExamStatisticsViewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamStatisticsView
     */
    select?: ExamStatisticsViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamStatisticsView
     */
    omit?: ExamStatisticsViewOmit<ExtArgs> | null
    /**
     * The filter to search for the ExamStatisticsView to update in case it exists.
     */
    where: ExamStatisticsViewWhereUniqueInput
    /**
     * In case the ExamStatisticsView found by the `where` argument doesn't exist, create a new ExamStatisticsView with this data.
     */
    create: XOR<ExamStatisticsViewCreateInput, ExamStatisticsViewUncheckedCreateInput>
    /**
     * In case the ExamStatisticsView was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamStatisticsViewUpdateInput, ExamStatisticsViewUncheckedUpdateInput>
  }

  /**
   * ExamStatisticsView delete
   */
  export type ExamStatisticsViewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamStatisticsView
     */
    select?: ExamStatisticsViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamStatisticsView
     */
    omit?: ExamStatisticsViewOmit<ExtArgs> | null
    /**
     * Filter which ExamStatisticsView to delete.
     */
    where: ExamStatisticsViewWhereUniqueInput
  }

  /**
   * ExamStatisticsView deleteMany
   */
  export type ExamStatisticsViewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamStatisticsViews to delete
     */
    where?: ExamStatisticsViewWhereInput
    /**
     * Limit how many ExamStatisticsViews to delete.
     */
    limit?: number
  }

  /**
   * ExamStatisticsView without action
   */
  export type ExamStatisticsViewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamStatisticsView
     */
    select?: ExamStatisticsViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExamStatisticsView
     */
    omit?: ExamStatisticsViewOmit<ExtArgs> | null
  }


  /**
   * Model UserPerformanceView
   */

  export type AggregateUserPerformanceView = {
    _count: UserPerformanceViewCountAggregateOutputType | null
    _avg: UserPerformanceViewAvgAggregateOutputType | null
    _sum: UserPerformanceViewSumAggregateOutputType | null
    _min: UserPerformanceViewMinAggregateOutputType | null
    _max: UserPerformanceViewMaxAggregateOutputType | null
  }

  export type UserPerformanceViewAvgAggregateOutputType = {
    totalExamsTaken: number | null
    totalExamsPassed: number | null
    averageScore: number | null
    totalTimeSpent: number | null
    certificatesEarned: number | null
  }

  export type UserPerformanceViewSumAggregateOutputType = {
    totalExamsTaken: number | null
    totalExamsPassed: number | null
    averageScore: number | null
    totalTimeSpent: number | null
    certificatesEarned: number | null
  }

  export type UserPerformanceViewMinAggregateOutputType = {
    userId: string | null
    userEmail: string | null
    totalExamsTaken: number | null
    totalExamsPassed: number | null
    averageScore: number | null
    totalTimeSpent: number | null
    certificatesEarned: number | null
    lastExamDate: Date | null
  }

  export type UserPerformanceViewMaxAggregateOutputType = {
    userId: string | null
    userEmail: string | null
    totalExamsTaken: number | null
    totalExamsPassed: number | null
    averageScore: number | null
    totalTimeSpent: number | null
    certificatesEarned: number | null
    lastExamDate: Date | null
  }

  export type UserPerformanceViewCountAggregateOutputType = {
    userId: number
    userEmail: number
    totalExamsTaken: number
    totalExamsPassed: number
    averageScore: number
    totalTimeSpent: number
    certificatesEarned: number
    lastExamDate: number
    _all: number
  }


  export type UserPerformanceViewAvgAggregateInputType = {
    totalExamsTaken?: true
    totalExamsPassed?: true
    averageScore?: true
    totalTimeSpent?: true
    certificatesEarned?: true
  }

  export type UserPerformanceViewSumAggregateInputType = {
    totalExamsTaken?: true
    totalExamsPassed?: true
    averageScore?: true
    totalTimeSpent?: true
    certificatesEarned?: true
  }

  export type UserPerformanceViewMinAggregateInputType = {
    userId?: true
    userEmail?: true
    totalExamsTaken?: true
    totalExamsPassed?: true
    averageScore?: true
    totalTimeSpent?: true
    certificatesEarned?: true
    lastExamDate?: true
  }

  export type UserPerformanceViewMaxAggregateInputType = {
    userId?: true
    userEmail?: true
    totalExamsTaken?: true
    totalExamsPassed?: true
    averageScore?: true
    totalTimeSpent?: true
    certificatesEarned?: true
    lastExamDate?: true
  }

  export type UserPerformanceViewCountAggregateInputType = {
    userId?: true
    userEmail?: true
    totalExamsTaken?: true
    totalExamsPassed?: true
    averageScore?: true
    totalTimeSpent?: true
    certificatesEarned?: true
    lastExamDate?: true
    _all?: true
  }

  export type UserPerformanceViewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPerformanceView to aggregate.
     */
    where?: UserPerformanceViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPerformanceViews to fetch.
     */
    orderBy?: UserPerformanceViewOrderByWithRelationInput | UserPerformanceViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPerformanceViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPerformanceViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPerformanceViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPerformanceViews
    **/
    _count?: true | UserPerformanceViewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserPerformanceViewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserPerformanceViewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPerformanceViewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPerformanceViewMaxAggregateInputType
  }

  export type GetUserPerformanceViewAggregateType<T extends UserPerformanceViewAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPerformanceView]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPerformanceView[P]>
      : GetScalarType<T[P], AggregateUserPerformanceView[P]>
  }




  export type UserPerformanceViewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPerformanceViewWhereInput
    orderBy?: UserPerformanceViewOrderByWithAggregationInput | UserPerformanceViewOrderByWithAggregationInput[]
    by: UserPerformanceViewScalarFieldEnum[] | UserPerformanceViewScalarFieldEnum
    having?: UserPerformanceViewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPerformanceViewCountAggregateInputType | true
    _avg?: UserPerformanceViewAvgAggregateInputType
    _sum?: UserPerformanceViewSumAggregateInputType
    _min?: UserPerformanceViewMinAggregateInputType
    _max?: UserPerformanceViewMaxAggregateInputType
  }

  export type UserPerformanceViewGroupByOutputType = {
    userId: string
    userEmail: string
    totalExamsTaken: number
    totalExamsPassed: number
    averageScore: number
    totalTimeSpent: number
    certificatesEarned: number
    lastExamDate: Date | null
    _count: UserPerformanceViewCountAggregateOutputType | null
    _avg: UserPerformanceViewAvgAggregateOutputType | null
    _sum: UserPerformanceViewSumAggregateOutputType | null
    _min: UserPerformanceViewMinAggregateOutputType | null
    _max: UserPerformanceViewMaxAggregateOutputType | null
  }

  type GetUserPerformanceViewGroupByPayload<T extends UserPerformanceViewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPerformanceViewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPerformanceViewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPerformanceViewGroupByOutputType[P]>
            : GetScalarType<T[P], UserPerformanceViewGroupByOutputType[P]>
        }
      >
    >


  export type UserPerformanceViewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    userEmail?: boolean
    totalExamsTaken?: boolean
    totalExamsPassed?: boolean
    averageScore?: boolean
    totalTimeSpent?: boolean
    certificatesEarned?: boolean
    lastExamDate?: boolean
  }, ExtArgs["result"]["userPerformanceView"]>

  export type UserPerformanceViewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    userEmail?: boolean
    totalExamsTaken?: boolean
    totalExamsPassed?: boolean
    averageScore?: boolean
    totalTimeSpent?: boolean
    certificatesEarned?: boolean
    lastExamDate?: boolean
  }, ExtArgs["result"]["userPerformanceView"]>

  export type UserPerformanceViewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    userEmail?: boolean
    totalExamsTaken?: boolean
    totalExamsPassed?: boolean
    averageScore?: boolean
    totalTimeSpent?: boolean
    certificatesEarned?: boolean
    lastExamDate?: boolean
  }, ExtArgs["result"]["userPerformanceView"]>

  export type UserPerformanceViewSelectScalar = {
    userId?: boolean
    userEmail?: boolean
    totalExamsTaken?: boolean
    totalExamsPassed?: boolean
    averageScore?: boolean
    totalTimeSpent?: boolean
    certificatesEarned?: boolean
    lastExamDate?: boolean
  }

  export type UserPerformanceViewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "userEmail" | "totalExamsTaken" | "totalExamsPassed" | "averageScore" | "totalTimeSpent" | "certificatesEarned" | "lastExamDate", ExtArgs["result"]["userPerformanceView"]>

  export type $UserPerformanceViewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPerformanceView"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      userEmail: string
      totalExamsTaken: number
      totalExamsPassed: number
      averageScore: number
      totalTimeSpent: number
      certificatesEarned: number
      lastExamDate: Date | null
    }, ExtArgs["result"]["userPerformanceView"]>
    composites: {}
  }

  type UserPerformanceViewGetPayload<S extends boolean | null | undefined | UserPerformanceViewDefaultArgs> = $Result.GetResult<Prisma.$UserPerformanceViewPayload, S>

  type UserPerformanceViewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPerformanceViewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPerformanceViewCountAggregateInputType | true
    }

  export interface UserPerformanceViewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPerformanceView'], meta: { name: 'UserPerformanceView' } }
    /**
     * Find zero or one UserPerformanceView that matches the filter.
     * @param {UserPerformanceViewFindUniqueArgs} args - Arguments to find a UserPerformanceView
     * @example
     * // Get one UserPerformanceView
     * const userPerformanceView = await prisma.userPerformanceView.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPerformanceViewFindUniqueArgs>(args: SelectSubset<T, UserPerformanceViewFindUniqueArgs<ExtArgs>>): Prisma__UserPerformanceViewClient<$Result.GetResult<Prisma.$UserPerformanceViewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPerformanceView that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPerformanceViewFindUniqueOrThrowArgs} args - Arguments to find a UserPerformanceView
     * @example
     * // Get one UserPerformanceView
     * const userPerformanceView = await prisma.userPerformanceView.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPerformanceViewFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPerformanceViewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPerformanceViewClient<$Result.GetResult<Prisma.$UserPerformanceViewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPerformanceView that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPerformanceViewFindFirstArgs} args - Arguments to find a UserPerformanceView
     * @example
     * // Get one UserPerformanceView
     * const userPerformanceView = await prisma.userPerformanceView.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPerformanceViewFindFirstArgs>(args?: SelectSubset<T, UserPerformanceViewFindFirstArgs<ExtArgs>>): Prisma__UserPerformanceViewClient<$Result.GetResult<Prisma.$UserPerformanceViewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPerformanceView that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPerformanceViewFindFirstOrThrowArgs} args - Arguments to find a UserPerformanceView
     * @example
     * // Get one UserPerformanceView
     * const userPerformanceView = await prisma.userPerformanceView.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPerformanceViewFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPerformanceViewFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPerformanceViewClient<$Result.GetResult<Prisma.$UserPerformanceViewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPerformanceViews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPerformanceViewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPerformanceViews
     * const userPerformanceViews = await prisma.userPerformanceView.findMany()
     * 
     * // Get first 10 UserPerformanceViews
     * const userPerformanceViews = await prisma.userPerformanceView.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userPerformanceViewWithUserIdOnly = await prisma.userPerformanceView.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserPerformanceViewFindManyArgs>(args?: SelectSubset<T, UserPerformanceViewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPerformanceViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPerformanceView.
     * @param {UserPerformanceViewCreateArgs} args - Arguments to create a UserPerformanceView.
     * @example
     * // Create one UserPerformanceView
     * const UserPerformanceView = await prisma.userPerformanceView.create({
     *   data: {
     *     // ... data to create a UserPerformanceView
     *   }
     * })
     * 
     */
    create<T extends UserPerformanceViewCreateArgs>(args: SelectSubset<T, UserPerformanceViewCreateArgs<ExtArgs>>): Prisma__UserPerformanceViewClient<$Result.GetResult<Prisma.$UserPerformanceViewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPerformanceViews.
     * @param {UserPerformanceViewCreateManyArgs} args - Arguments to create many UserPerformanceViews.
     * @example
     * // Create many UserPerformanceViews
     * const userPerformanceView = await prisma.userPerformanceView.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPerformanceViewCreateManyArgs>(args?: SelectSubset<T, UserPerformanceViewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPerformanceViews and returns the data saved in the database.
     * @param {UserPerformanceViewCreateManyAndReturnArgs} args - Arguments to create many UserPerformanceViews.
     * @example
     * // Create many UserPerformanceViews
     * const userPerformanceView = await prisma.userPerformanceView.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPerformanceViews and only return the `userId`
     * const userPerformanceViewWithUserIdOnly = await prisma.userPerformanceView.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPerformanceViewCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPerformanceViewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPerformanceViewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserPerformanceView.
     * @param {UserPerformanceViewDeleteArgs} args - Arguments to delete one UserPerformanceView.
     * @example
     * // Delete one UserPerformanceView
     * const UserPerformanceView = await prisma.userPerformanceView.delete({
     *   where: {
     *     // ... filter to delete one UserPerformanceView
     *   }
     * })
     * 
     */
    delete<T extends UserPerformanceViewDeleteArgs>(args: SelectSubset<T, UserPerformanceViewDeleteArgs<ExtArgs>>): Prisma__UserPerformanceViewClient<$Result.GetResult<Prisma.$UserPerformanceViewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPerformanceView.
     * @param {UserPerformanceViewUpdateArgs} args - Arguments to update one UserPerformanceView.
     * @example
     * // Update one UserPerformanceView
     * const userPerformanceView = await prisma.userPerformanceView.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPerformanceViewUpdateArgs>(args: SelectSubset<T, UserPerformanceViewUpdateArgs<ExtArgs>>): Prisma__UserPerformanceViewClient<$Result.GetResult<Prisma.$UserPerformanceViewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPerformanceViews.
     * @param {UserPerformanceViewDeleteManyArgs} args - Arguments to filter UserPerformanceViews to delete.
     * @example
     * // Delete a few UserPerformanceViews
     * const { count } = await prisma.userPerformanceView.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPerformanceViewDeleteManyArgs>(args?: SelectSubset<T, UserPerformanceViewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPerformanceViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPerformanceViewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPerformanceViews
     * const userPerformanceView = await prisma.userPerformanceView.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPerformanceViewUpdateManyArgs>(args: SelectSubset<T, UserPerformanceViewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPerformanceViews and returns the data updated in the database.
     * @param {UserPerformanceViewUpdateManyAndReturnArgs} args - Arguments to update many UserPerformanceViews.
     * @example
     * // Update many UserPerformanceViews
     * const userPerformanceView = await prisma.userPerformanceView.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserPerformanceViews and only return the `userId`
     * const userPerformanceViewWithUserIdOnly = await prisma.userPerformanceView.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserPerformanceViewUpdateManyAndReturnArgs>(args: SelectSubset<T, UserPerformanceViewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPerformanceViewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserPerformanceView.
     * @param {UserPerformanceViewUpsertArgs} args - Arguments to update or create a UserPerformanceView.
     * @example
     * // Update or create a UserPerformanceView
     * const userPerformanceView = await prisma.userPerformanceView.upsert({
     *   create: {
     *     // ... data to create a UserPerformanceView
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPerformanceView we want to update
     *   }
     * })
     */
    upsert<T extends UserPerformanceViewUpsertArgs>(args: SelectSubset<T, UserPerformanceViewUpsertArgs<ExtArgs>>): Prisma__UserPerformanceViewClient<$Result.GetResult<Prisma.$UserPerformanceViewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPerformanceViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPerformanceViewCountArgs} args - Arguments to filter UserPerformanceViews to count.
     * @example
     * // Count the number of UserPerformanceViews
     * const count = await prisma.userPerformanceView.count({
     *   where: {
     *     // ... the filter for the UserPerformanceViews we want to count
     *   }
     * })
    **/
    count<T extends UserPerformanceViewCountArgs>(
      args?: Subset<T, UserPerformanceViewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPerformanceViewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPerformanceView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPerformanceViewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPerformanceViewAggregateArgs>(args: Subset<T, UserPerformanceViewAggregateArgs>): Prisma.PrismaPromise<GetUserPerformanceViewAggregateType<T>>

    /**
     * Group by UserPerformanceView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPerformanceViewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPerformanceViewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPerformanceViewGroupByArgs['orderBy'] }
        : { orderBy?: UserPerformanceViewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPerformanceViewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPerformanceViewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPerformanceView model
   */
  readonly fields: UserPerformanceViewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPerformanceView.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPerformanceViewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPerformanceView model
   */
  interface UserPerformanceViewFieldRefs {
    readonly userId: FieldRef<"UserPerformanceView", 'String'>
    readonly userEmail: FieldRef<"UserPerformanceView", 'String'>
    readonly totalExamsTaken: FieldRef<"UserPerformanceView", 'Int'>
    readonly totalExamsPassed: FieldRef<"UserPerformanceView", 'Int'>
    readonly averageScore: FieldRef<"UserPerformanceView", 'Float'>
    readonly totalTimeSpent: FieldRef<"UserPerformanceView", 'Int'>
    readonly certificatesEarned: FieldRef<"UserPerformanceView", 'Int'>
    readonly lastExamDate: FieldRef<"UserPerformanceView", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserPerformanceView findUnique
   */
  export type UserPerformanceViewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPerformanceView
     */
    select?: UserPerformanceViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPerformanceView
     */
    omit?: UserPerformanceViewOmit<ExtArgs> | null
    /**
     * Filter, which UserPerformanceView to fetch.
     */
    where: UserPerformanceViewWhereUniqueInput
  }

  /**
   * UserPerformanceView findUniqueOrThrow
   */
  export type UserPerformanceViewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPerformanceView
     */
    select?: UserPerformanceViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPerformanceView
     */
    omit?: UserPerformanceViewOmit<ExtArgs> | null
    /**
     * Filter, which UserPerformanceView to fetch.
     */
    where: UserPerformanceViewWhereUniqueInput
  }

  /**
   * UserPerformanceView findFirst
   */
  export type UserPerformanceViewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPerformanceView
     */
    select?: UserPerformanceViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPerformanceView
     */
    omit?: UserPerformanceViewOmit<ExtArgs> | null
    /**
     * Filter, which UserPerformanceView to fetch.
     */
    where?: UserPerformanceViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPerformanceViews to fetch.
     */
    orderBy?: UserPerformanceViewOrderByWithRelationInput | UserPerformanceViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPerformanceViews.
     */
    cursor?: UserPerformanceViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPerformanceViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPerformanceViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPerformanceViews.
     */
    distinct?: UserPerformanceViewScalarFieldEnum | UserPerformanceViewScalarFieldEnum[]
  }

  /**
   * UserPerformanceView findFirstOrThrow
   */
  export type UserPerformanceViewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPerformanceView
     */
    select?: UserPerformanceViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPerformanceView
     */
    omit?: UserPerformanceViewOmit<ExtArgs> | null
    /**
     * Filter, which UserPerformanceView to fetch.
     */
    where?: UserPerformanceViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPerformanceViews to fetch.
     */
    orderBy?: UserPerformanceViewOrderByWithRelationInput | UserPerformanceViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPerformanceViews.
     */
    cursor?: UserPerformanceViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPerformanceViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPerformanceViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPerformanceViews.
     */
    distinct?: UserPerformanceViewScalarFieldEnum | UserPerformanceViewScalarFieldEnum[]
  }

  /**
   * UserPerformanceView findMany
   */
  export type UserPerformanceViewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPerformanceView
     */
    select?: UserPerformanceViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPerformanceView
     */
    omit?: UserPerformanceViewOmit<ExtArgs> | null
    /**
     * Filter, which UserPerformanceViews to fetch.
     */
    where?: UserPerformanceViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPerformanceViews to fetch.
     */
    orderBy?: UserPerformanceViewOrderByWithRelationInput | UserPerformanceViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPerformanceViews.
     */
    cursor?: UserPerformanceViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPerformanceViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPerformanceViews.
     */
    skip?: number
    distinct?: UserPerformanceViewScalarFieldEnum | UserPerformanceViewScalarFieldEnum[]
  }

  /**
   * UserPerformanceView create
   */
  export type UserPerformanceViewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPerformanceView
     */
    select?: UserPerformanceViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPerformanceView
     */
    omit?: UserPerformanceViewOmit<ExtArgs> | null
    /**
     * The data needed to create a UserPerformanceView.
     */
    data: XOR<UserPerformanceViewCreateInput, UserPerformanceViewUncheckedCreateInput>
  }

  /**
   * UserPerformanceView createMany
   */
  export type UserPerformanceViewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPerformanceViews.
     */
    data: UserPerformanceViewCreateManyInput | UserPerformanceViewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPerformanceView createManyAndReturn
   */
  export type UserPerformanceViewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPerformanceView
     */
    select?: UserPerformanceViewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPerformanceView
     */
    omit?: UserPerformanceViewOmit<ExtArgs> | null
    /**
     * The data used to create many UserPerformanceViews.
     */
    data: UserPerformanceViewCreateManyInput | UserPerformanceViewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPerformanceView update
   */
  export type UserPerformanceViewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPerformanceView
     */
    select?: UserPerformanceViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPerformanceView
     */
    omit?: UserPerformanceViewOmit<ExtArgs> | null
    /**
     * The data needed to update a UserPerformanceView.
     */
    data: XOR<UserPerformanceViewUpdateInput, UserPerformanceViewUncheckedUpdateInput>
    /**
     * Choose, which UserPerformanceView to update.
     */
    where: UserPerformanceViewWhereUniqueInput
  }

  /**
   * UserPerformanceView updateMany
   */
  export type UserPerformanceViewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPerformanceViews.
     */
    data: XOR<UserPerformanceViewUpdateManyMutationInput, UserPerformanceViewUncheckedUpdateManyInput>
    /**
     * Filter which UserPerformanceViews to update
     */
    where?: UserPerformanceViewWhereInput
    /**
     * Limit how many UserPerformanceViews to update.
     */
    limit?: number
  }

  /**
   * UserPerformanceView updateManyAndReturn
   */
  export type UserPerformanceViewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPerformanceView
     */
    select?: UserPerformanceViewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPerformanceView
     */
    omit?: UserPerformanceViewOmit<ExtArgs> | null
    /**
     * The data used to update UserPerformanceViews.
     */
    data: XOR<UserPerformanceViewUpdateManyMutationInput, UserPerformanceViewUncheckedUpdateManyInput>
    /**
     * Filter which UserPerformanceViews to update
     */
    where?: UserPerformanceViewWhereInput
    /**
     * Limit how many UserPerformanceViews to update.
     */
    limit?: number
  }

  /**
   * UserPerformanceView upsert
   */
  export type UserPerformanceViewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPerformanceView
     */
    select?: UserPerformanceViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPerformanceView
     */
    omit?: UserPerformanceViewOmit<ExtArgs> | null
    /**
     * The filter to search for the UserPerformanceView to update in case it exists.
     */
    where: UserPerformanceViewWhereUniqueInput
    /**
     * In case the UserPerformanceView found by the `where` argument doesn't exist, create a new UserPerformanceView with this data.
     */
    create: XOR<UserPerformanceViewCreateInput, UserPerformanceViewUncheckedCreateInput>
    /**
     * In case the UserPerformanceView was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPerformanceViewUpdateInput, UserPerformanceViewUncheckedUpdateInput>
  }

  /**
   * UserPerformanceView delete
   */
  export type UserPerformanceViewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPerformanceView
     */
    select?: UserPerformanceViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPerformanceView
     */
    omit?: UserPerformanceViewOmit<ExtArgs> | null
    /**
     * Filter which UserPerformanceView to delete.
     */
    where: UserPerformanceViewWhereUniqueInput
  }

  /**
   * UserPerformanceView deleteMany
   */
  export type UserPerformanceViewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPerformanceViews to delete
     */
    where?: UserPerformanceViewWhereInput
    /**
     * Limit how many UserPerformanceViews to delete.
     */
    limit?: number
  }

  /**
   * UserPerformanceView without action
   */
  export type UserPerformanceViewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPerformanceView
     */
    select?: UserPerformanceViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPerformanceView
     */
    omit?: UserPerformanceViewOmit<ExtArgs> | null
  }


  /**
   * Model QuestionAnalyticsView
   */

  export type AggregateQuestionAnalyticsView = {
    _count: QuestionAnalyticsViewCountAggregateOutputType | null
    _avg: QuestionAnalyticsViewAvgAggregateOutputType | null
    _sum: QuestionAnalyticsViewSumAggregateOutputType | null
    _min: QuestionAnalyticsViewMinAggregateOutputType | null
    _max: QuestionAnalyticsViewMaxAggregateOutputType | null
  }

  export type QuestionAnalyticsViewAvgAggregateOutputType = {
    usageCount: number | null
    correctAnswerRate: number | null
    averageTime: number | null
  }

  export type QuestionAnalyticsViewSumAggregateOutputType = {
    usageCount: number | null
    correctAnswerRate: number | null
    averageTime: number | null
  }

  export type QuestionAnalyticsViewMinAggregateOutputType = {
    questionId: string | null
    questionText: string | null
    usageCount: number | null
    correctAnswerRate: number | null
    averageTime: number | null
    difficulty: $Enums.QuestionDifficulty | null
    examCategoryName: string | null
  }

  export type QuestionAnalyticsViewMaxAggregateOutputType = {
    questionId: string | null
    questionText: string | null
    usageCount: number | null
    correctAnswerRate: number | null
    averageTime: number | null
    difficulty: $Enums.QuestionDifficulty | null
    examCategoryName: string | null
  }

  export type QuestionAnalyticsViewCountAggregateOutputType = {
    questionId: number
    questionText: number
    usageCount: number
    correctAnswerRate: number
    averageTime: number
    difficulty: number
    examCategoryName: number
    _all: number
  }


  export type QuestionAnalyticsViewAvgAggregateInputType = {
    usageCount?: true
    correctAnswerRate?: true
    averageTime?: true
  }

  export type QuestionAnalyticsViewSumAggregateInputType = {
    usageCount?: true
    correctAnswerRate?: true
    averageTime?: true
  }

  export type QuestionAnalyticsViewMinAggregateInputType = {
    questionId?: true
    questionText?: true
    usageCount?: true
    correctAnswerRate?: true
    averageTime?: true
    difficulty?: true
    examCategoryName?: true
  }

  export type QuestionAnalyticsViewMaxAggregateInputType = {
    questionId?: true
    questionText?: true
    usageCount?: true
    correctAnswerRate?: true
    averageTime?: true
    difficulty?: true
    examCategoryName?: true
  }

  export type QuestionAnalyticsViewCountAggregateInputType = {
    questionId?: true
    questionText?: true
    usageCount?: true
    correctAnswerRate?: true
    averageTime?: true
    difficulty?: true
    examCategoryName?: true
    _all?: true
  }

  export type QuestionAnalyticsViewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionAnalyticsView to aggregate.
     */
    where?: QuestionAnalyticsViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionAnalyticsViews to fetch.
     */
    orderBy?: QuestionAnalyticsViewOrderByWithRelationInput | QuestionAnalyticsViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionAnalyticsViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionAnalyticsViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionAnalyticsViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestionAnalyticsViews
    **/
    _count?: true | QuestionAnalyticsViewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionAnalyticsViewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionAnalyticsViewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionAnalyticsViewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionAnalyticsViewMaxAggregateInputType
  }

  export type GetQuestionAnalyticsViewAggregateType<T extends QuestionAnalyticsViewAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionAnalyticsView]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionAnalyticsView[P]>
      : GetScalarType<T[P], AggregateQuestionAnalyticsView[P]>
  }




  export type QuestionAnalyticsViewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionAnalyticsViewWhereInput
    orderBy?: QuestionAnalyticsViewOrderByWithAggregationInput | QuestionAnalyticsViewOrderByWithAggregationInput[]
    by: QuestionAnalyticsViewScalarFieldEnum[] | QuestionAnalyticsViewScalarFieldEnum
    having?: QuestionAnalyticsViewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionAnalyticsViewCountAggregateInputType | true
    _avg?: QuestionAnalyticsViewAvgAggregateInputType
    _sum?: QuestionAnalyticsViewSumAggregateInputType
    _min?: QuestionAnalyticsViewMinAggregateInputType
    _max?: QuestionAnalyticsViewMaxAggregateInputType
  }

  export type QuestionAnalyticsViewGroupByOutputType = {
    questionId: string
    questionText: string
    usageCount: number
    correctAnswerRate: number
    averageTime: number
    difficulty: $Enums.QuestionDifficulty
    examCategoryName: string
    _count: QuestionAnalyticsViewCountAggregateOutputType | null
    _avg: QuestionAnalyticsViewAvgAggregateOutputType | null
    _sum: QuestionAnalyticsViewSumAggregateOutputType | null
    _min: QuestionAnalyticsViewMinAggregateOutputType | null
    _max: QuestionAnalyticsViewMaxAggregateOutputType | null
  }

  type GetQuestionAnalyticsViewGroupByPayload<T extends QuestionAnalyticsViewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionAnalyticsViewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionAnalyticsViewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionAnalyticsViewGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionAnalyticsViewGroupByOutputType[P]>
        }
      >
    >


  export type QuestionAnalyticsViewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    questionId?: boolean
    questionText?: boolean
    usageCount?: boolean
    correctAnswerRate?: boolean
    averageTime?: boolean
    difficulty?: boolean
    examCategoryName?: boolean
  }, ExtArgs["result"]["questionAnalyticsView"]>

  export type QuestionAnalyticsViewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    questionId?: boolean
    questionText?: boolean
    usageCount?: boolean
    correctAnswerRate?: boolean
    averageTime?: boolean
    difficulty?: boolean
    examCategoryName?: boolean
  }, ExtArgs["result"]["questionAnalyticsView"]>

  export type QuestionAnalyticsViewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    questionId?: boolean
    questionText?: boolean
    usageCount?: boolean
    correctAnswerRate?: boolean
    averageTime?: boolean
    difficulty?: boolean
    examCategoryName?: boolean
  }, ExtArgs["result"]["questionAnalyticsView"]>

  export type QuestionAnalyticsViewSelectScalar = {
    questionId?: boolean
    questionText?: boolean
    usageCount?: boolean
    correctAnswerRate?: boolean
    averageTime?: boolean
    difficulty?: boolean
    examCategoryName?: boolean
  }

  export type QuestionAnalyticsViewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"questionId" | "questionText" | "usageCount" | "correctAnswerRate" | "averageTime" | "difficulty" | "examCategoryName", ExtArgs["result"]["questionAnalyticsView"]>

  export type $QuestionAnalyticsViewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuestionAnalyticsView"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      questionId: string
      questionText: string
      usageCount: number
      correctAnswerRate: number
      averageTime: number
      difficulty: $Enums.QuestionDifficulty
      examCategoryName: string
    }, ExtArgs["result"]["questionAnalyticsView"]>
    composites: {}
  }

  type QuestionAnalyticsViewGetPayload<S extends boolean | null | undefined | QuestionAnalyticsViewDefaultArgs> = $Result.GetResult<Prisma.$QuestionAnalyticsViewPayload, S>

  type QuestionAnalyticsViewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuestionAnalyticsViewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuestionAnalyticsViewCountAggregateInputType | true
    }

  export interface QuestionAnalyticsViewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuestionAnalyticsView'], meta: { name: 'QuestionAnalyticsView' } }
    /**
     * Find zero or one QuestionAnalyticsView that matches the filter.
     * @param {QuestionAnalyticsViewFindUniqueArgs} args - Arguments to find a QuestionAnalyticsView
     * @example
     * // Get one QuestionAnalyticsView
     * const questionAnalyticsView = await prisma.questionAnalyticsView.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionAnalyticsViewFindUniqueArgs>(args: SelectSubset<T, QuestionAnalyticsViewFindUniqueArgs<ExtArgs>>): Prisma__QuestionAnalyticsViewClient<$Result.GetResult<Prisma.$QuestionAnalyticsViewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuestionAnalyticsView that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuestionAnalyticsViewFindUniqueOrThrowArgs} args - Arguments to find a QuestionAnalyticsView
     * @example
     * // Get one QuestionAnalyticsView
     * const questionAnalyticsView = await prisma.questionAnalyticsView.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionAnalyticsViewFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionAnalyticsViewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionAnalyticsViewClient<$Result.GetResult<Prisma.$QuestionAnalyticsViewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuestionAnalyticsView that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAnalyticsViewFindFirstArgs} args - Arguments to find a QuestionAnalyticsView
     * @example
     * // Get one QuestionAnalyticsView
     * const questionAnalyticsView = await prisma.questionAnalyticsView.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionAnalyticsViewFindFirstArgs>(args?: SelectSubset<T, QuestionAnalyticsViewFindFirstArgs<ExtArgs>>): Prisma__QuestionAnalyticsViewClient<$Result.GetResult<Prisma.$QuestionAnalyticsViewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuestionAnalyticsView that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAnalyticsViewFindFirstOrThrowArgs} args - Arguments to find a QuestionAnalyticsView
     * @example
     * // Get one QuestionAnalyticsView
     * const questionAnalyticsView = await prisma.questionAnalyticsView.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionAnalyticsViewFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionAnalyticsViewFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionAnalyticsViewClient<$Result.GetResult<Prisma.$QuestionAnalyticsViewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuestionAnalyticsViews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAnalyticsViewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionAnalyticsViews
     * const questionAnalyticsViews = await prisma.questionAnalyticsView.findMany()
     * 
     * // Get first 10 QuestionAnalyticsViews
     * const questionAnalyticsViews = await prisma.questionAnalyticsView.findMany({ take: 10 })
     * 
     * // Only select the `questionId`
     * const questionAnalyticsViewWithQuestionIdOnly = await prisma.questionAnalyticsView.findMany({ select: { questionId: true } })
     * 
     */
    findMany<T extends QuestionAnalyticsViewFindManyArgs>(args?: SelectSubset<T, QuestionAnalyticsViewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionAnalyticsViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuestionAnalyticsView.
     * @param {QuestionAnalyticsViewCreateArgs} args - Arguments to create a QuestionAnalyticsView.
     * @example
     * // Create one QuestionAnalyticsView
     * const QuestionAnalyticsView = await prisma.questionAnalyticsView.create({
     *   data: {
     *     // ... data to create a QuestionAnalyticsView
     *   }
     * })
     * 
     */
    create<T extends QuestionAnalyticsViewCreateArgs>(args: SelectSubset<T, QuestionAnalyticsViewCreateArgs<ExtArgs>>): Prisma__QuestionAnalyticsViewClient<$Result.GetResult<Prisma.$QuestionAnalyticsViewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuestionAnalyticsViews.
     * @param {QuestionAnalyticsViewCreateManyArgs} args - Arguments to create many QuestionAnalyticsViews.
     * @example
     * // Create many QuestionAnalyticsViews
     * const questionAnalyticsView = await prisma.questionAnalyticsView.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionAnalyticsViewCreateManyArgs>(args?: SelectSubset<T, QuestionAnalyticsViewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuestionAnalyticsViews and returns the data saved in the database.
     * @param {QuestionAnalyticsViewCreateManyAndReturnArgs} args - Arguments to create many QuestionAnalyticsViews.
     * @example
     * // Create many QuestionAnalyticsViews
     * const questionAnalyticsView = await prisma.questionAnalyticsView.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuestionAnalyticsViews and only return the `questionId`
     * const questionAnalyticsViewWithQuestionIdOnly = await prisma.questionAnalyticsView.createManyAndReturn({
     *   select: { questionId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestionAnalyticsViewCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestionAnalyticsViewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionAnalyticsViewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuestionAnalyticsView.
     * @param {QuestionAnalyticsViewDeleteArgs} args - Arguments to delete one QuestionAnalyticsView.
     * @example
     * // Delete one QuestionAnalyticsView
     * const QuestionAnalyticsView = await prisma.questionAnalyticsView.delete({
     *   where: {
     *     // ... filter to delete one QuestionAnalyticsView
     *   }
     * })
     * 
     */
    delete<T extends QuestionAnalyticsViewDeleteArgs>(args: SelectSubset<T, QuestionAnalyticsViewDeleteArgs<ExtArgs>>): Prisma__QuestionAnalyticsViewClient<$Result.GetResult<Prisma.$QuestionAnalyticsViewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuestionAnalyticsView.
     * @param {QuestionAnalyticsViewUpdateArgs} args - Arguments to update one QuestionAnalyticsView.
     * @example
     * // Update one QuestionAnalyticsView
     * const questionAnalyticsView = await prisma.questionAnalyticsView.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionAnalyticsViewUpdateArgs>(args: SelectSubset<T, QuestionAnalyticsViewUpdateArgs<ExtArgs>>): Prisma__QuestionAnalyticsViewClient<$Result.GetResult<Prisma.$QuestionAnalyticsViewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuestionAnalyticsViews.
     * @param {QuestionAnalyticsViewDeleteManyArgs} args - Arguments to filter QuestionAnalyticsViews to delete.
     * @example
     * // Delete a few QuestionAnalyticsViews
     * const { count } = await prisma.questionAnalyticsView.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionAnalyticsViewDeleteManyArgs>(args?: SelectSubset<T, QuestionAnalyticsViewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionAnalyticsViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAnalyticsViewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionAnalyticsViews
     * const questionAnalyticsView = await prisma.questionAnalyticsView.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionAnalyticsViewUpdateManyArgs>(args: SelectSubset<T, QuestionAnalyticsViewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionAnalyticsViews and returns the data updated in the database.
     * @param {QuestionAnalyticsViewUpdateManyAndReturnArgs} args - Arguments to update many QuestionAnalyticsViews.
     * @example
     * // Update many QuestionAnalyticsViews
     * const questionAnalyticsView = await prisma.questionAnalyticsView.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuestionAnalyticsViews and only return the `questionId`
     * const questionAnalyticsViewWithQuestionIdOnly = await prisma.questionAnalyticsView.updateManyAndReturn({
     *   select: { questionId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuestionAnalyticsViewUpdateManyAndReturnArgs>(args: SelectSubset<T, QuestionAnalyticsViewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionAnalyticsViewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuestionAnalyticsView.
     * @param {QuestionAnalyticsViewUpsertArgs} args - Arguments to update or create a QuestionAnalyticsView.
     * @example
     * // Update or create a QuestionAnalyticsView
     * const questionAnalyticsView = await prisma.questionAnalyticsView.upsert({
     *   create: {
     *     // ... data to create a QuestionAnalyticsView
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionAnalyticsView we want to update
     *   }
     * })
     */
    upsert<T extends QuestionAnalyticsViewUpsertArgs>(args: SelectSubset<T, QuestionAnalyticsViewUpsertArgs<ExtArgs>>): Prisma__QuestionAnalyticsViewClient<$Result.GetResult<Prisma.$QuestionAnalyticsViewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuestionAnalyticsViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAnalyticsViewCountArgs} args - Arguments to filter QuestionAnalyticsViews to count.
     * @example
     * // Count the number of QuestionAnalyticsViews
     * const count = await prisma.questionAnalyticsView.count({
     *   where: {
     *     // ... the filter for the QuestionAnalyticsViews we want to count
     *   }
     * })
    **/
    count<T extends QuestionAnalyticsViewCountArgs>(
      args?: Subset<T, QuestionAnalyticsViewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionAnalyticsViewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionAnalyticsView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAnalyticsViewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionAnalyticsViewAggregateArgs>(args: Subset<T, QuestionAnalyticsViewAggregateArgs>): Prisma.PrismaPromise<GetQuestionAnalyticsViewAggregateType<T>>

    /**
     * Group by QuestionAnalyticsView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionAnalyticsViewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionAnalyticsViewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionAnalyticsViewGroupByArgs['orderBy'] }
        : { orderBy?: QuestionAnalyticsViewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionAnalyticsViewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionAnalyticsViewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuestionAnalyticsView model
   */
  readonly fields: QuestionAnalyticsViewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestionAnalyticsView.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionAnalyticsViewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuestionAnalyticsView model
   */
  interface QuestionAnalyticsViewFieldRefs {
    readonly questionId: FieldRef<"QuestionAnalyticsView", 'String'>
    readonly questionText: FieldRef<"QuestionAnalyticsView", 'String'>
    readonly usageCount: FieldRef<"QuestionAnalyticsView", 'Int'>
    readonly correctAnswerRate: FieldRef<"QuestionAnalyticsView", 'Float'>
    readonly averageTime: FieldRef<"QuestionAnalyticsView", 'Int'>
    readonly difficulty: FieldRef<"QuestionAnalyticsView", 'QuestionDifficulty'>
    readonly examCategoryName: FieldRef<"QuestionAnalyticsView", 'String'>
  }
    

  // Custom InputTypes
  /**
   * QuestionAnalyticsView findUnique
   */
  export type QuestionAnalyticsViewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnalyticsView
     */
    select?: QuestionAnalyticsViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAnalyticsView
     */
    omit?: QuestionAnalyticsViewOmit<ExtArgs> | null
    /**
     * Filter, which QuestionAnalyticsView to fetch.
     */
    where: QuestionAnalyticsViewWhereUniqueInput
  }

  /**
   * QuestionAnalyticsView findUniqueOrThrow
   */
  export type QuestionAnalyticsViewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnalyticsView
     */
    select?: QuestionAnalyticsViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAnalyticsView
     */
    omit?: QuestionAnalyticsViewOmit<ExtArgs> | null
    /**
     * Filter, which QuestionAnalyticsView to fetch.
     */
    where: QuestionAnalyticsViewWhereUniqueInput
  }

  /**
   * QuestionAnalyticsView findFirst
   */
  export type QuestionAnalyticsViewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnalyticsView
     */
    select?: QuestionAnalyticsViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAnalyticsView
     */
    omit?: QuestionAnalyticsViewOmit<ExtArgs> | null
    /**
     * Filter, which QuestionAnalyticsView to fetch.
     */
    where?: QuestionAnalyticsViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionAnalyticsViews to fetch.
     */
    orderBy?: QuestionAnalyticsViewOrderByWithRelationInput | QuestionAnalyticsViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionAnalyticsViews.
     */
    cursor?: QuestionAnalyticsViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionAnalyticsViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionAnalyticsViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionAnalyticsViews.
     */
    distinct?: QuestionAnalyticsViewScalarFieldEnum | QuestionAnalyticsViewScalarFieldEnum[]
  }

  /**
   * QuestionAnalyticsView findFirstOrThrow
   */
  export type QuestionAnalyticsViewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnalyticsView
     */
    select?: QuestionAnalyticsViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAnalyticsView
     */
    omit?: QuestionAnalyticsViewOmit<ExtArgs> | null
    /**
     * Filter, which QuestionAnalyticsView to fetch.
     */
    where?: QuestionAnalyticsViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionAnalyticsViews to fetch.
     */
    orderBy?: QuestionAnalyticsViewOrderByWithRelationInput | QuestionAnalyticsViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionAnalyticsViews.
     */
    cursor?: QuestionAnalyticsViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionAnalyticsViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionAnalyticsViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionAnalyticsViews.
     */
    distinct?: QuestionAnalyticsViewScalarFieldEnum | QuestionAnalyticsViewScalarFieldEnum[]
  }

  /**
   * QuestionAnalyticsView findMany
   */
  export type QuestionAnalyticsViewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnalyticsView
     */
    select?: QuestionAnalyticsViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAnalyticsView
     */
    omit?: QuestionAnalyticsViewOmit<ExtArgs> | null
    /**
     * Filter, which QuestionAnalyticsViews to fetch.
     */
    where?: QuestionAnalyticsViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionAnalyticsViews to fetch.
     */
    orderBy?: QuestionAnalyticsViewOrderByWithRelationInput | QuestionAnalyticsViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestionAnalyticsViews.
     */
    cursor?: QuestionAnalyticsViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionAnalyticsViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionAnalyticsViews.
     */
    skip?: number
    distinct?: QuestionAnalyticsViewScalarFieldEnum | QuestionAnalyticsViewScalarFieldEnum[]
  }

  /**
   * QuestionAnalyticsView create
   */
  export type QuestionAnalyticsViewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnalyticsView
     */
    select?: QuestionAnalyticsViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAnalyticsView
     */
    omit?: QuestionAnalyticsViewOmit<ExtArgs> | null
    /**
     * The data needed to create a QuestionAnalyticsView.
     */
    data: XOR<QuestionAnalyticsViewCreateInput, QuestionAnalyticsViewUncheckedCreateInput>
  }

  /**
   * QuestionAnalyticsView createMany
   */
  export type QuestionAnalyticsViewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuestionAnalyticsViews.
     */
    data: QuestionAnalyticsViewCreateManyInput | QuestionAnalyticsViewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuestionAnalyticsView createManyAndReturn
   */
  export type QuestionAnalyticsViewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnalyticsView
     */
    select?: QuestionAnalyticsViewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAnalyticsView
     */
    omit?: QuestionAnalyticsViewOmit<ExtArgs> | null
    /**
     * The data used to create many QuestionAnalyticsViews.
     */
    data: QuestionAnalyticsViewCreateManyInput | QuestionAnalyticsViewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuestionAnalyticsView update
   */
  export type QuestionAnalyticsViewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnalyticsView
     */
    select?: QuestionAnalyticsViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAnalyticsView
     */
    omit?: QuestionAnalyticsViewOmit<ExtArgs> | null
    /**
     * The data needed to update a QuestionAnalyticsView.
     */
    data: XOR<QuestionAnalyticsViewUpdateInput, QuestionAnalyticsViewUncheckedUpdateInput>
    /**
     * Choose, which QuestionAnalyticsView to update.
     */
    where: QuestionAnalyticsViewWhereUniqueInput
  }

  /**
   * QuestionAnalyticsView updateMany
   */
  export type QuestionAnalyticsViewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuestionAnalyticsViews.
     */
    data: XOR<QuestionAnalyticsViewUpdateManyMutationInput, QuestionAnalyticsViewUncheckedUpdateManyInput>
    /**
     * Filter which QuestionAnalyticsViews to update
     */
    where?: QuestionAnalyticsViewWhereInput
    /**
     * Limit how many QuestionAnalyticsViews to update.
     */
    limit?: number
  }

  /**
   * QuestionAnalyticsView updateManyAndReturn
   */
  export type QuestionAnalyticsViewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnalyticsView
     */
    select?: QuestionAnalyticsViewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAnalyticsView
     */
    omit?: QuestionAnalyticsViewOmit<ExtArgs> | null
    /**
     * The data used to update QuestionAnalyticsViews.
     */
    data: XOR<QuestionAnalyticsViewUpdateManyMutationInput, QuestionAnalyticsViewUncheckedUpdateManyInput>
    /**
     * Filter which QuestionAnalyticsViews to update
     */
    where?: QuestionAnalyticsViewWhereInput
    /**
     * Limit how many QuestionAnalyticsViews to update.
     */
    limit?: number
  }

  /**
   * QuestionAnalyticsView upsert
   */
  export type QuestionAnalyticsViewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnalyticsView
     */
    select?: QuestionAnalyticsViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAnalyticsView
     */
    omit?: QuestionAnalyticsViewOmit<ExtArgs> | null
    /**
     * The filter to search for the QuestionAnalyticsView to update in case it exists.
     */
    where: QuestionAnalyticsViewWhereUniqueInput
    /**
     * In case the QuestionAnalyticsView found by the `where` argument doesn't exist, create a new QuestionAnalyticsView with this data.
     */
    create: XOR<QuestionAnalyticsViewCreateInput, QuestionAnalyticsViewUncheckedCreateInput>
    /**
     * In case the QuestionAnalyticsView was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionAnalyticsViewUpdateInput, QuestionAnalyticsViewUncheckedUpdateInput>
  }

  /**
   * QuestionAnalyticsView delete
   */
  export type QuestionAnalyticsViewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnalyticsView
     */
    select?: QuestionAnalyticsViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAnalyticsView
     */
    omit?: QuestionAnalyticsViewOmit<ExtArgs> | null
    /**
     * Filter which QuestionAnalyticsView to delete.
     */
    where: QuestionAnalyticsViewWhereUniqueInput
  }

  /**
   * QuestionAnalyticsView deleteMany
   */
  export type QuestionAnalyticsViewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionAnalyticsViews to delete
     */
    where?: QuestionAnalyticsViewWhereInput
    /**
     * Limit how many QuestionAnalyticsViews to delete.
     */
    limit?: number
  }

  /**
   * QuestionAnalyticsView without action
   */
  export type QuestionAnalyticsViewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionAnalyticsView
     */
    select?: QuestionAnalyticsViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionAnalyticsView
     */
    omit?: QuestionAnalyticsViewOmit<ExtArgs> | null
  }


  /**
   * Model RevenueAnalyticsView
   */

  export type AggregateRevenueAnalyticsView = {
    _count: RevenueAnalyticsViewCountAggregateOutputType | null
    _avg: RevenueAnalyticsViewAvgAggregateOutputType | null
    _sum: RevenueAnalyticsViewSumAggregateOutputType | null
    _min: RevenueAnalyticsViewMinAggregateOutputType | null
    _max: RevenueAnalyticsViewMaxAggregateOutputType | null
  }

  export type RevenueAnalyticsViewAvgAggregateOutputType = {
    totalRevenue: Decimal | null
    totalTransactions: number | null
    averageTransactionValue: Decimal | null
  }

  export type RevenueAnalyticsViewSumAggregateOutputType = {
    totalRevenue: Decimal | null
    totalTransactions: number | null
    averageTransactionValue: Decimal | null
  }

  export type RevenueAnalyticsViewMinAggregateOutputType = {
    date: Date | null
    totalRevenue: Decimal | null
    totalTransactions: number | null
    averageTransactionValue: Decimal | null
    topExamCategory: string | null
    topExam: string | null
  }

  export type RevenueAnalyticsViewMaxAggregateOutputType = {
    date: Date | null
    totalRevenue: Decimal | null
    totalTransactions: number | null
    averageTransactionValue: Decimal | null
    topExamCategory: string | null
    topExam: string | null
  }

  export type RevenueAnalyticsViewCountAggregateOutputType = {
    date: number
    totalRevenue: number
    totalTransactions: number
    averageTransactionValue: number
    topExamCategory: number
    topExam: number
    _all: number
  }


  export type RevenueAnalyticsViewAvgAggregateInputType = {
    totalRevenue?: true
    totalTransactions?: true
    averageTransactionValue?: true
  }

  export type RevenueAnalyticsViewSumAggregateInputType = {
    totalRevenue?: true
    totalTransactions?: true
    averageTransactionValue?: true
  }

  export type RevenueAnalyticsViewMinAggregateInputType = {
    date?: true
    totalRevenue?: true
    totalTransactions?: true
    averageTransactionValue?: true
    topExamCategory?: true
    topExam?: true
  }

  export type RevenueAnalyticsViewMaxAggregateInputType = {
    date?: true
    totalRevenue?: true
    totalTransactions?: true
    averageTransactionValue?: true
    topExamCategory?: true
    topExam?: true
  }

  export type RevenueAnalyticsViewCountAggregateInputType = {
    date?: true
    totalRevenue?: true
    totalTransactions?: true
    averageTransactionValue?: true
    topExamCategory?: true
    topExam?: true
    _all?: true
  }

  export type RevenueAnalyticsViewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RevenueAnalyticsView to aggregate.
     */
    where?: RevenueAnalyticsViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RevenueAnalyticsViews to fetch.
     */
    orderBy?: RevenueAnalyticsViewOrderByWithRelationInput | RevenueAnalyticsViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RevenueAnalyticsViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RevenueAnalyticsViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RevenueAnalyticsViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RevenueAnalyticsViews
    **/
    _count?: true | RevenueAnalyticsViewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RevenueAnalyticsViewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RevenueAnalyticsViewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RevenueAnalyticsViewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RevenueAnalyticsViewMaxAggregateInputType
  }

  export type GetRevenueAnalyticsViewAggregateType<T extends RevenueAnalyticsViewAggregateArgs> = {
        [P in keyof T & keyof AggregateRevenueAnalyticsView]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRevenueAnalyticsView[P]>
      : GetScalarType<T[P], AggregateRevenueAnalyticsView[P]>
  }




  export type RevenueAnalyticsViewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RevenueAnalyticsViewWhereInput
    orderBy?: RevenueAnalyticsViewOrderByWithAggregationInput | RevenueAnalyticsViewOrderByWithAggregationInput[]
    by: RevenueAnalyticsViewScalarFieldEnum[] | RevenueAnalyticsViewScalarFieldEnum
    having?: RevenueAnalyticsViewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RevenueAnalyticsViewCountAggregateInputType | true
    _avg?: RevenueAnalyticsViewAvgAggregateInputType
    _sum?: RevenueAnalyticsViewSumAggregateInputType
    _min?: RevenueAnalyticsViewMinAggregateInputType
    _max?: RevenueAnalyticsViewMaxAggregateInputType
  }

  export type RevenueAnalyticsViewGroupByOutputType = {
    date: Date
    totalRevenue: Decimal
    totalTransactions: number
    averageTransactionValue: Decimal
    topExamCategory: string
    topExam: string
    _count: RevenueAnalyticsViewCountAggregateOutputType | null
    _avg: RevenueAnalyticsViewAvgAggregateOutputType | null
    _sum: RevenueAnalyticsViewSumAggregateOutputType | null
    _min: RevenueAnalyticsViewMinAggregateOutputType | null
    _max: RevenueAnalyticsViewMaxAggregateOutputType | null
  }

  type GetRevenueAnalyticsViewGroupByPayload<T extends RevenueAnalyticsViewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RevenueAnalyticsViewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RevenueAnalyticsViewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RevenueAnalyticsViewGroupByOutputType[P]>
            : GetScalarType<T[P], RevenueAnalyticsViewGroupByOutputType[P]>
        }
      >
    >


  export type RevenueAnalyticsViewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    date?: boolean
    totalRevenue?: boolean
    totalTransactions?: boolean
    averageTransactionValue?: boolean
    topExamCategory?: boolean
    topExam?: boolean
  }, ExtArgs["result"]["revenueAnalyticsView"]>

  export type RevenueAnalyticsViewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    date?: boolean
    totalRevenue?: boolean
    totalTransactions?: boolean
    averageTransactionValue?: boolean
    topExamCategory?: boolean
    topExam?: boolean
  }, ExtArgs["result"]["revenueAnalyticsView"]>

  export type RevenueAnalyticsViewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    date?: boolean
    totalRevenue?: boolean
    totalTransactions?: boolean
    averageTransactionValue?: boolean
    topExamCategory?: boolean
    topExam?: boolean
  }, ExtArgs["result"]["revenueAnalyticsView"]>

  export type RevenueAnalyticsViewSelectScalar = {
    date?: boolean
    totalRevenue?: boolean
    totalTransactions?: boolean
    averageTransactionValue?: boolean
    topExamCategory?: boolean
    topExam?: boolean
  }

  export type RevenueAnalyticsViewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"date" | "totalRevenue" | "totalTransactions" | "averageTransactionValue" | "topExamCategory" | "topExam", ExtArgs["result"]["revenueAnalyticsView"]>

  export type $RevenueAnalyticsViewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RevenueAnalyticsView"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      date: Date
      totalRevenue: Prisma.Decimal
      totalTransactions: number
      averageTransactionValue: Prisma.Decimal
      topExamCategory: string
      topExam: string
    }, ExtArgs["result"]["revenueAnalyticsView"]>
    composites: {}
  }

  type RevenueAnalyticsViewGetPayload<S extends boolean | null | undefined | RevenueAnalyticsViewDefaultArgs> = $Result.GetResult<Prisma.$RevenueAnalyticsViewPayload, S>

  type RevenueAnalyticsViewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RevenueAnalyticsViewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RevenueAnalyticsViewCountAggregateInputType | true
    }

  export interface RevenueAnalyticsViewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RevenueAnalyticsView'], meta: { name: 'RevenueAnalyticsView' } }
    /**
     * Find zero or one RevenueAnalyticsView that matches the filter.
     * @param {RevenueAnalyticsViewFindUniqueArgs} args - Arguments to find a RevenueAnalyticsView
     * @example
     * // Get one RevenueAnalyticsView
     * const revenueAnalyticsView = await prisma.revenueAnalyticsView.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RevenueAnalyticsViewFindUniqueArgs>(args: SelectSubset<T, RevenueAnalyticsViewFindUniqueArgs<ExtArgs>>): Prisma__RevenueAnalyticsViewClient<$Result.GetResult<Prisma.$RevenueAnalyticsViewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RevenueAnalyticsView that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RevenueAnalyticsViewFindUniqueOrThrowArgs} args - Arguments to find a RevenueAnalyticsView
     * @example
     * // Get one RevenueAnalyticsView
     * const revenueAnalyticsView = await prisma.revenueAnalyticsView.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RevenueAnalyticsViewFindUniqueOrThrowArgs>(args: SelectSubset<T, RevenueAnalyticsViewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RevenueAnalyticsViewClient<$Result.GetResult<Prisma.$RevenueAnalyticsViewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RevenueAnalyticsView that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueAnalyticsViewFindFirstArgs} args - Arguments to find a RevenueAnalyticsView
     * @example
     * // Get one RevenueAnalyticsView
     * const revenueAnalyticsView = await prisma.revenueAnalyticsView.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RevenueAnalyticsViewFindFirstArgs>(args?: SelectSubset<T, RevenueAnalyticsViewFindFirstArgs<ExtArgs>>): Prisma__RevenueAnalyticsViewClient<$Result.GetResult<Prisma.$RevenueAnalyticsViewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RevenueAnalyticsView that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueAnalyticsViewFindFirstOrThrowArgs} args - Arguments to find a RevenueAnalyticsView
     * @example
     * // Get one RevenueAnalyticsView
     * const revenueAnalyticsView = await prisma.revenueAnalyticsView.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RevenueAnalyticsViewFindFirstOrThrowArgs>(args?: SelectSubset<T, RevenueAnalyticsViewFindFirstOrThrowArgs<ExtArgs>>): Prisma__RevenueAnalyticsViewClient<$Result.GetResult<Prisma.$RevenueAnalyticsViewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RevenueAnalyticsViews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueAnalyticsViewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RevenueAnalyticsViews
     * const revenueAnalyticsViews = await prisma.revenueAnalyticsView.findMany()
     * 
     * // Get first 10 RevenueAnalyticsViews
     * const revenueAnalyticsViews = await prisma.revenueAnalyticsView.findMany({ take: 10 })
     * 
     * // Only select the `date`
     * const revenueAnalyticsViewWithDateOnly = await prisma.revenueAnalyticsView.findMany({ select: { date: true } })
     * 
     */
    findMany<T extends RevenueAnalyticsViewFindManyArgs>(args?: SelectSubset<T, RevenueAnalyticsViewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RevenueAnalyticsViewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RevenueAnalyticsView.
     * @param {RevenueAnalyticsViewCreateArgs} args - Arguments to create a RevenueAnalyticsView.
     * @example
     * // Create one RevenueAnalyticsView
     * const RevenueAnalyticsView = await prisma.revenueAnalyticsView.create({
     *   data: {
     *     // ... data to create a RevenueAnalyticsView
     *   }
     * })
     * 
     */
    create<T extends RevenueAnalyticsViewCreateArgs>(args: SelectSubset<T, RevenueAnalyticsViewCreateArgs<ExtArgs>>): Prisma__RevenueAnalyticsViewClient<$Result.GetResult<Prisma.$RevenueAnalyticsViewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RevenueAnalyticsViews.
     * @param {RevenueAnalyticsViewCreateManyArgs} args - Arguments to create many RevenueAnalyticsViews.
     * @example
     * // Create many RevenueAnalyticsViews
     * const revenueAnalyticsView = await prisma.revenueAnalyticsView.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RevenueAnalyticsViewCreateManyArgs>(args?: SelectSubset<T, RevenueAnalyticsViewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RevenueAnalyticsViews and returns the data saved in the database.
     * @param {RevenueAnalyticsViewCreateManyAndReturnArgs} args - Arguments to create many RevenueAnalyticsViews.
     * @example
     * // Create many RevenueAnalyticsViews
     * const revenueAnalyticsView = await prisma.revenueAnalyticsView.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RevenueAnalyticsViews and only return the `date`
     * const revenueAnalyticsViewWithDateOnly = await prisma.revenueAnalyticsView.createManyAndReturn({
     *   select: { date: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RevenueAnalyticsViewCreateManyAndReturnArgs>(args?: SelectSubset<T, RevenueAnalyticsViewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RevenueAnalyticsViewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RevenueAnalyticsView.
     * @param {RevenueAnalyticsViewDeleteArgs} args - Arguments to delete one RevenueAnalyticsView.
     * @example
     * // Delete one RevenueAnalyticsView
     * const RevenueAnalyticsView = await prisma.revenueAnalyticsView.delete({
     *   where: {
     *     // ... filter to delete one RevenueAnalyticsView
     *   }
     * })
     * 
     */
    delete<T extends RevenueAnalyticsViewDeleteArgs>(args: SelectSubset<T, RevenueAnalyticsViewDeleteArgs<ExtArgs>>): Prisma__RevenueAnalyticsViewClient<$Result.GetResult<Prisma.$RevenueAnalyticsViewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RevenueAnalyticsView.
     * @param {RevenueAnalyticsViewUpdateArgs} args - Arguments to update one RevenueAnalyticsView.
     * @example
     * // Update one RevenueAnalyticsView
     * const revenueAnalyticsView = await prisma.revenueAnalyticsView.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RevenueAnalyticsViewUpdateArgs>(args: SelectSubset<T, RevenueAnalyticsViewUpdateArgs<ExtArgs>>): Prisma__RevenueAnalyticsViewClient<$Result.GetResult<Prisma.$RevenueAnalyticsViewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RevenueAnalyticsViews.
     * @param {RevenueAnalyticsViewDeleteManyArgs} args - Arguments to filter RevenueAnalyticsViews to delete.
     * @example
     * // Delete a few RevenueAnalyticsViews
     * const { count } = await prisma.revenueAnalyticsView.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RevenueAnalyticsViewDeleteManyArgs>(args?: SelectSubset<T, RevenueAnalyticsViewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RevenueAnalyticsViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueAnalyticsViewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RevenueAnalyticsViews
     * const revenueAnalyticsView = await prisma.revenueAnalyticsView.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RevenueAnalyticsViewUpdateManyArgs>(args: SelectSubset<T, RevenueAnalyticsViewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RevenueAnalyticsViews and returns the data updated in the database.
     * @param {RevenueAnalyticsViewUpdateManyAndReturnArgs} args - Arguments to update many RevenueAnalyticsViews.
     * @example
     * // Update many RevenueAnalyticsViews
     * const revenueAnalyticsView = await prisma.revenueAnalyticsView.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RevenueAnalyticsViews and only return the `date`
     * const revenueAnalyticsViewWithDateOnly = await prisma.revenueAnalyticsView.updateManyAndReturn({
     *   select: { date: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RevenueAnalyticsViewUpdateManyAndReturnArgs>(args: SelectSubset<T, RevenueAnalyticsViewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RevenueAnalyticsViewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RevenueAnalyticsView.
     * @param {RevenueAnalyticsViewUpsertArgs} args - Arguments to update or create a RevenueAnalyticsView.
     * @example
     * // Update or create a RevenueAnalyticsView
     * const revenueAnalyticsView = await prisma.revenueAnalyticsView.upsert({
     *   create: {
     *     // ... data to create a RevenueAnalyticsView
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RevenueAnalyticsView we want to update
     *   }
     * })
     */
    upsert<T extends RevenueAnalyticsViewUpsertArgs>(args: SelectSubset<T, RevenueAnalyticsViewUpsertArgs<ExtArgs>>): Prisma__RevenueAnalyticsViewClient<$Result.GetResult<Prisma.$RevenueAnalyticsViewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RevenueAnalyticsViews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueAnalyticsViewCountArgs} args - Arguments to filter RevenueAnalyticsViews to count.
     * @example
     * // Count the number of RevenueAnalyticsViews
     * const count = await prisma.revenueAnalyticsView.count({
     *   where: {
     *     // ... the filter for the RevenueAnalyticsViews we want to count
     *   }
     * })
    **/
    count<T extends RevenueAnalyticsViewCountArgs>(
      args?: Subset<T, RevenueAnalyticsViewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RevenueAnalyticsViewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RevenueAnalyticsView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueAnalyticsViewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RevenueAnalyticsViewAggregateArgs>(args: Subset<T, RevenueAnalyticsViewAggregateArgs>): Prisma.PrismaPromise<GetRevenueAnalyticsViewAggregateType<T>>

    /**
     * Group by RevenueAnalyticsView.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RevenueAnalyticsViewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RevenueAnalyticsViewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RevenueAnalyticsViewGroupByArgs['orderBy'] }
        : { orderBy?: RevenueAnalyticsViewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RevenueAnalyticsViewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRevenueAnalyticsViewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RevenueAnalyticsView model
   */
  readonly fields: RevenueAnalyticsViewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RevenueAnalyticsView.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RevenueAnalyticsViewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RevenueAnalyticsView model
   */
  interface RevenueAnalyticsViewFieldRefs {
    readonly date: FieldRef<"RevenueAnalyticsView", 'DateTime'>
    readonly totalRevenue: FieldRef<"RevenueAnalyticsView", 'Decimal'>
    readonly totalTransactions: FieldRef<"RevenueAnalyticsView", 'Int'>
    readonly averageTransactionValue: FieldRef<"RevenueAnalyticsView", 'Decimal'>
    readonly topExamCategory: FieldRef<"RevenueAnalyticsView", 'String'>
    readonly topExam: FieldRef<"RevenueAnalyticsView", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RevenueAnalyticsView findUnique
   */
  export type RevenueAnalyticsViewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueAnalyticsView
     */
    select?: RevenueAnalyticsViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RevenueAnalyticsView
     */
    omit?: RevenueAnalyticsViewOmit<ExtArgs> | null
    /**
     * Filter, which RevenueAnalyticsView to fetch.
     */
    where: RevenueAnalyticsViewWhereUniqueInput
  }

  /**
   * RevenueAnalyticsView findUniqueOrThrow
   */
  export type RevenueAnalyticsViewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueAnalyticsView
     */
    select?: RevenueAnalyticsViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RevenueAnalyticsView
     */
    omit?: RevenueAnalyticsViewOmit<ExtArgs> | null
    /**
     * Filter, which RevenueAnalyticsView to fetch.
     */
    where: RevenueAnalyticsViewWhereUniqueInput
  }

  /**
   * RevenueAnalyticsView findFirst
   */
  export type RevenueAnalyticsViewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueAnalyticsView
     */
    select?: RevenueAnalyticsViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RevenueAnalyticsView
     */
    omit?: RevenueAnalyticsViewOmit<ExtArgs> | null
    /**
     * Filter, which RevenueAnalyticsView to fetch.
     */
    where?: RevenueAnalyticsViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RevenueAnalyticsViews to fetch.
     */
    orderBy?: RevenueAnalyticsViewOrderByWithRelationInput | RevenueAnalyticsViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RevenueAnalyticsViews.
     */
    cursor?: RevenueAnalyticsViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RevenueAnalyticsViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RevenueAnalyticsViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RevenueAnalyticsViews.
     */
    distinct?: RevenueAnalyticsViewScalarFieldEnum | RevenueAnalyticsViewScalarFieldEnum[]
  }

  /**
   * RevenueAnalyticsView findFirstOrThrow
   */
  export type RevenueAnalyticsViewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueAnalyticsView
     */
    select?: RevenueAnalyticsViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RevenueAnalyticsView
     */
    omit?: RevenueAnalyticsViewOmit<ExtArgs> | null
    /**
     * Filter, which RevenueAnalyticsView to fetch.
     */
    where?: RevenueAnalyticsViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RevenueAnalyticsViews to fetch.
     */
    orderBy?: RevenueAnalyticsViewOrderByWithRelationInput | RevenueAnalyticsViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RevenueAnalyticsViews.
     */
    cursor?: RevenueAnalyticsViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RevenueAnalyticsViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RevenueAnalyticsViews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RevenueAnalyticsViews.
     */
    distinct?: RevenueAnalyticsViewScalarFieldEnum | RevenueAnalyticsViewScalarFieldEnum[]
  }

  /**
   * RevenueAnalyticsView findMany
   */
  export type RevenueAnalyticsViewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueAnalyticsView
     */
    select?: RevenueAnalyticsViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RevenueAnalyticsView
     */
    omit?: RevenueAnalyticsViewOmit<ExtArgs> | null
    /**
     * Filter, which RevenueAnalyticsViews to fetch.
     */
    where?: RevenueAnalyticsViewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RevenueAnalyticsViews to fetch.
     */
    orderBy?: RevenueAnalyticsViewOrderByWithRelationInput | RevenueAnalyticsViewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RevenueAnalyticsViews.
     */
    cursor?: RevenueAnalyticsViewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RevenueAnalyticsViews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RevenueAnalyticsViews.
     */
    skip?: number
    distinct?: RevenueAnalyticsViewScalarFieldEnum | RevenueAnalyticsViewScalarFieldEnum[]
  }

  /**
   * RevenueAnalyticsView create
   */
  export type RevenueAnalyticsViewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueAnalyticsView
     */
    select?: RevenueAnalyticsViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RevenueAnalyticsView
     */
    omit?: RevenueAnalyticsViewOmit<ExtArgs> | null
    /**
     * The data needed to create a RevenueAnalyticsView.
     */
    data: XOR<RevenueAnalyticsViewCreateInput, RevenueAnalyticsViewUncheckedCreateInput>
  }

  /**
   * RevenueAnalyticsView createMany
   */
  export type RevenueAnalyticsViewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RevenueAnalyticsViews.
     */
    data: RevenueAnalyticsViewCreateManyInput | RevenueAnalyticsViewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RevenueAnalyticsView createManyAndReturn
   */
  export type RevenueAnalyticsViewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueAnalyticsView
     */
    select?: RevenueAnalyticsViewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RevenueAnalyticsView
     */
    omit?: RevenueAnalyticsViewOmit<ExtArgs> | null
    /**
     * The data used to create many RevenueAnalyticsViews.
     */
    data: RevenueAnalyticsViewCreateManyInput | RevenueAnalyticsViewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RevenueAnalyticsView update
   */
  export type RevenueAnalyticsViewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueAnalyticsView
     */
    select?: RevenueAnalyticsViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RevenueAnalyticsView
     */
    omit?: RevenueAnalyticsViewOmit<ExtArgs> | null
    /**
     * The data needed to update a RevenueAnalyticsView.
     */
    data: XOR<RevenueAnalyticsViewUpdateInput, RevenueAnalyticsViewUncheckedUpdateInput>
    /**
     * Choose, which RevenueAnalyticsView to update.
     */
    where: RevenueAnalyticsViewWhereUniqueInput
  }

  /**
   * RevenueAnalyticsView updateMany
   */
  export type RevenueAnalyticsViewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RevenueAnalyticsViews.
     */
    data: XOR<RevenueAnalyticsViewUpdateManyMutationInput, RevenueAnalyticsViewUncheckedUpdateManyInput>
    /**
     * Filter which RevenueAnalyticsViews to update
     */
    where?: RevenueAnalyticsViewWhereInput
    /**
     * Limit how many RevenueAnalyticsViews to update.
     */
    limit?: number
  }

  /**
   * RevenueAnalyticsView updateManyAndReturn
   */
  export type RevenueAnalyticsViewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueAnalyticsView
     */
    select?: RevenueAnalyticsViewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RevenueAnalyticsView
     */
    omit?: RevenueAnalyticsViewOmit<ExtArgs> | null
    /**
     * The data used to update RevenueAnalyticsViews.
     */
    data: XOR<RevenueAnalyticsViewUpdateManyMutationInput, RevenueAnalyticsViewUncheckedUpdateManyInput>
    /**
     * Filter which RevenueAnalyticsViews to update
     */
    where?: RevenueAnalyticsViewWhereInput
    /**
     * Limit how many RevenueAnalyticsViews to update.
     */
    limit?: number
  }

  /**
   * RevenueAnalyticsView upsert
   */
  export type RevenueAnalyticsViewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueAnalyticsView
     */
    select?: RevenueAnalyticsViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RevenueAnalyticsView
     */
    omit?: RevenueAnalyticsViewOmit<ExtArgs> | null
    /**
     * The filter to search for the RevenueAnalyticsView to update in case it exists.
     */
    where: RevenueAnalyticsViewWhereUniqueInput
    /**
     * In case the RevenueAnalyticsView found by the `where` argument doesn't exist, create a new RevenueAnalyticsView with this data.
     */
    create: XOR<RevenueAnalyticsViewCreateInput, RevenueAnalyticsViewUncheckedCreateInput>
    /**
     * In case the RevenueAnalyticsView was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RevenueAnalyticsViewUpdateInput, RevenueAnalyticsViewUncheckedUpdateInput>
  }

  /**
   * RevenueAnalyticsView delete
   */
  export type RevenueAnalyticsViewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueAnalyticsView
     */
    select?: RevenueAnalyticsViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RevenueAnalyticsView
     */
    omit?: RevenueAnalyticsViewOmit<ExtArgs> | null
    /**
     * Filter which RevenueAnalyticsView to delete.
     */
    where: RevenueAnalyticsViewWhereUniqueInput
  }

  /**
   * RevenueAnalyticsView deleteMany
   */
  export type RevenueAnalyticsViewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RevenueAnalyticsViews to delete
     */
    where?: RevenueAnalyticsViewWhereInput
    /**
     * Limit how many RevenueAnalyticsViews to delete.
     */
    limit?: number
  }

  /**
   * RevenueAnalyticsView without action
   */
  export type RevenueAnalyticsViewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RevenueAnalyticsView
     */
    select?: RevenueAnalyticsViewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RevenueAnalyticsView
     */
    omit?: RevenueAnalyticsViewOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    dateOfBirth: 'dateOfBirth',
    gender: 'gender',
    profileImage: 'profileImage',
    profilePicture: 'profilePicture',
    address: 'address',
    isActive: 'isActive',
    isEmailVerified: 'isEmailVerified',
    isPhoneVerified: 'isPhoneVerified',
    emailVerificationToken: 'emailVerificationToken',
    passwordResetToken: 'passwordResetToken',
    passwordResetExpires: 'passwordResetExpires',
    lastLoginAt: 'lastLoginAt',
    loginAttempts: 'loginAttempts',
    lockedUntil: 'lockedUntil',
    role: 'role',
    status: 'status',
    departmentId: 'departmentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    sessionToken: 'sessionToken',
    expiresAt: 'expiresAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type UserSessionScalarFieldEnum = (typeof UserSessionScalarFieldEnum)[keyof typeof UserSessionScalarFieldEnum]


  export const ExamCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    icon: 'icon',
    color: 'color',
    isActive: 'isActive',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExamCategoryScalarFieldEnum = (typeof ExamCategoryScalarFieldEnum)[keyof typeof ExamCategoryScalarFieldEnum]


  export const QuestionScalarFieldEnum: {
    id: 'id',
    text: 'text',
    type: 'type',
    difficulty: 'difficulty',
    examCategoryId: 'examCategoryId',
    marks: 'marks',
    timeLimit: 'timeLimit',
    isActive: 'isActive',
    isPublic: 'isPublic',
    createdBy: 'createdBy',
    approvedBy: 'approvedBy',
    approvedAt: 'approvedAt',
    usageCount: 'usageCount',
    correctAnswerRate: 'correctAnswerRate',
    averageTime: 'averageTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuestionScalarFieldEnum = (typeof QuestionScalarFieldEnum)[keyof typeof QuestionScalarFieldEnum]


  export const QuestionOptionScalarFieldEnum: {
    id: 'id',
    questionId: 'questionId',
    text: 'text',
    isCorrect: 'isCorrect',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt'
  };

  export type QuestionOptionScalarFieldEnum = (typeof QuestionOptionScalarFieldEnum)[keyof typeof QuestionOptionScalarFieldEnum]


  export const QuestionImageScalarFieldEnum: {
    id: 'id',
    questionId: 'questionId',
    imageUrl: 'imageUrl',
    altText: 'altText',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt'
  };

  export type QuestionImageScalarFieldEnum = (typeof QuestionImageScalarFieldEnum)[keyof typeof QuestionImageScalarFieldEnum]


  export const QuestionTagScalarFieldEnum: {
    id: 'id',
    questionId: 'questionId',
    tag: 'tag',
    createdAt: 'createdAt'
  };

  export type QuestionTagScalarFieldEnum = (typeof QuestionTagScalarFieldEnum)[keyof typeof QuestionTagScalarFieldEnum]


  export const ExamScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    examCategoryId: 'examCategoryId',
    duration: 'duration',
    totalMarks: 'totalMarks',
    passingMarks: 'passingMarks',
    price: 'price',
    currency: 'currency',
    isActive: 'isActive',
    isPublic: 'isPublic',
    allowRetakes: 'allowRetakes',
    maxRetakes: 'maxRetakes',
    showResults: 'showResults',
    showAnswers: 'showAnswers',
    randomizeQuestions: 'randomizeQuestions',
    randomizeOptions: 'randomizeOptions',
    questionOverlapPercentage: 'questionOverlapPercentage',
    createdBy: 'createdBy',
    approvedBy: 'approvedBy',
    approvedAt: 'approvedAt',
    scheduledStart: 'scheduledStart',
    scheduledEnd: 'scheduledEnd',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExamScalarFieldEnum = (typeof ExamScalarFieldEnum)[keyof typeof ExamScalarFieldEnum]


  export const ExamQuestionScalarFieldEnum: {
    id: 'id',
    examId: 'examId',
    questionId: 'questionId',
    order: 'order',
    marks: 'marks',
    createdAt: 'createdAt'
  };

  export type ExamQuestionScalarFieldEnum = (typeof ExamQuestionScalarFieldEnum)[keyof typeof ExamQuestionScalarFieldEnum]


  export const ExamBookingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    examId: 'examId',
    bookingDate: 'bookingDate',
    scheduledAt: 'scheduledAt',
    status: 'status',
    paymentId: 'paymentId',
    totalAmount: 'totalAmount',
    currency: 'currency',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExamBookingScalarFieldEnum = (typeof ExamBookingScalarFieldEnum)[keyof typeof ExamBookingScalarFieldEnum]


  export const ExamAttemptScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    examId: 'examId',
    bookingId: 'bookingId',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    status: 'status',
    totalMarks: 'totalMarks',
    obtainedMarks: 'obtainedMarks',
    percentage: 'percentage',
    isPassed: 'isPassed',
    timeSpent: 'timeSpent',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    isCheating: 'isCheating',
    cheatingReason: 'cheatingReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExamAttemptScalarFieldEnum = (typeof ExamAttemptScalarFieldEnum)[keyof typeof ExamAttemptScalarFieldEnum]


  export const QuestionResponseScalarFieldEnum: {
    id: 'id',
    attemptId: 'attemptId',
    questionId: 'questionId',
    userId: 'userId',
    selectedOptions: 'selectedOptions',
    isCorrect: 'isCorrect',
    marksObtained: 'marksObtained',
    timeSpent: 'timeSpent',
    answeredAt: 'answeredAt',
    submittedAt: 'submittedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuestionResponseScalarFieldEnum = (typeof QuestionResponseScalarFieldEnum)[keyof typeof QuestionResponseScalarFieldEnum]


  export const QuestionScoreScalarFieldEnum: {
    id: 'id',
    responseId: 'responseId',
    questionId: 'questionId',
    attemptId: 'attemptId',
    userId: 'userId',
    isCorrect: 'isCorrect',
    marksObtained: 'marksObtained',
    maxMarks: 'maxMarks',
    accuracy: 'accuracy',
    timeEfficiency: 'timeEfficiency',
    difficultyBonus: 'difficultyBonus',
    penalty: 'penalty',
    responseTime: 'responseTime',
    attemptsCount: 'attemptsCount',
    confidenceLevel: 'confidenceLevel',
    questionDifficulty: 'questionDifficulty',
    scoredAt: 'scoredAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuestionScoreScalarFieldEnum = (typeof QuestionScoreScalarFieldEnum)[keyof typeof QuestionScoreScalarFieldEnum]


  export const ExamScoreScalarFieldEnum: {
    id: 'id',
    attemptId: 'attemptId',
    examId: 'examId',
    userId: 'userId',
    totalMarks: 'totalMarks',
    maxMarks: 'maxMarks',
    percentage: 'percentage',
    grade: 'grade',
    correctAnswers: 'correctAnswers',
    wrongAnswers: 'wrongAnswers',
    unanswered: 'unanswered',
    totalQuestions: 'totalQuestions',
    totalTimeSpent: 'totalTimeSpent',
    averageTimePerQuestion: 'averageTimePerQuestion',
    timeEfficiency: 'timeEfficiency',
    easyCorrect: 'easyCorrect',
    easyTotal: 'easyTotal',
    mediumCorrect: 'mediumCorrect',
    mediumTotal: 'mediumTotal',
    hardCorrect: 'hardCorrect',
    hardTotal: 'hardTotal',
    accuracy: 'accuracy',
    speedScore: 'speedScore',
    consistencyScore: 'consistencyScore',
    difficultyScore: 'difficultyScore',
    percentile: 'percentile',
    rank: 'rank',
    improvement: 'improvement',
    calculatedAt: 'calculatedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExamScoreScalarFieldEnum = (typeof ExamScoreScalarFieldEnum)[keyof typeof ExamScoreScalarFieldEnum]


  export const UserPerformanceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    examCategoryId: 'examCategoryId',
    totalAttempts: 'totalAttempts',
    totalPassed: 'totalPassed',
    totalFailed: 'totalFailed',
    passRate: 'passRate',
    averageScore: 'averageScore',
    highestScore: 'highestScore',
    lowestScore: 'lowestScore',
    totalMarks: 'totalMarks',
    totalTimeSpent: 'totalTimeSpent',
    averageTimePerExam: 'averageTimePerExam',
    easyAccuracy: 'easyAccuracy',
    mediumAccuracy: 'mediumAccuracy',
    hardAccuracy: 'hardAccuracy',
    improvementRate: 'improvementRate',
    consistencyScore: 'consistencyScore',
    learningCurve: 'learningCurve',
    lastAttemptAt: 'lastAttemptAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserPerformanceScalarFieldEnum = (typeof UserPerformanceScalarFieldEnum)[keyof typeof UserPerformanceScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    bookingId: 'bookingId',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    paymentMethod: 'paymentMethod',
    stripePaymentId: 'stripePaymentId',
    stripeRefundId: 'stripeRefundId',
    description: 'description',
    metadata: 'metadata',
    refundedAt: 'refundedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const CertificateScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    examId: 'examId',
    attemptId: 'attemptId',
    certificateNumber: 'certificateNumber',
    issuedAt: 'issuedAt',
    expiresAt: 'expiresAt',
    isRevoked: 'isRevoked',
    revokedAt: 'revokedAt',
    revokedBy: 'revokedBy',
    revokedReason: 'revokedReason',
    pdfUrl: 'pdfUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CertificateScalarFieldEnum = (typeof CertificateScalarFieldEnum)[keyof typeof CertificateScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    message: 'message',
    isRead: 'isRead',
    readAt: 'readAt',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const StudyGroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isPrivate: 'isPrivate',
    maxMembers: 'maxMembers',
    createdBy: 'createdBy',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudyGroupScalarFieldEnum = (typeof StudyGroupScalarFieldEnum)[keyof typeof StudyGroupScalarFieldEnum]


  export const StudyGroupMemberScalarFieldEnum: {
    id: 'id',
    groupId: 'groupId',
    userId: 'userId',
    role: 'role',
    joinedAt: 'joinedAt',
    isActive: 'isActive'
  };

  export type StudyGroupMemberScalarFieldEnum = (typeof StudyGroupMemberScalarFieldEnum)[keyof typeof StudyGroupMemberScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    resource: 'resource',
    resourceId: 'resourceId',
    details: 'details',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const ExamCategoryUserScalarFieldEnum: {
    id: 'id',
    examCategoryId: 'examCategoryId',
    userId: 'userId',
    accessLevel: 'accessLevel',
    grantedAt: 'grantedAt',
    grantedBy: 'grantedBy'
  };

  export type ExamCategoryUserScalarFieldEnum = (typeof ExamCategoryUserScalarFieldEnum)[keyof typeof ExamCategoryUserScalarFieldEnum]


  export const ExamStatisticsViewScalarFieldEnum: {
    examId: 'examId',
    examTitle: 'examTitle',
    totalAttempts: 'totalAttempts',
    totalBookings: 'totalBookings',
    totalRevenue: 'totalRevenue',
    averageScore: 'averageScore',
    passRate: 'passRate',
    averageTime: 'averageTime',
    lastAttemptDate: 'lastAttemptDate'
  };

  export type ExamStatisticsViewScalarFieldEnum = (typeof ExamStatisticsViewScalarFieldEnum)[keyof typeof ExamStatisticsViewScalarFieldEnum]


  export const UserPerformanceViewScalarFieldEnum: {
    userId: 'userId',
    userEmail: 'userEmail',
    totalExamsTaken: 'totalExamsTaken',
    totalExamsPassed: 'totalExamsPassed',
    averageScore: 'averageScore',
    totalTimeSpent: 'totalTimeSpent',
    certificatesEarned: 'certificatesEarned',
    lastExamDate: 'lastExamDate'
  };

  export type UserPerformanceViewScalarFieldEnum = (typeof UserPerformanceViewScalarFieldEnum)[keyof typeof UserPerformanceViewScalarFieldEnum]


  export const QuestionAnalyticsViewScalarFieldEnum: {
    questionId: 'questionId',
    questionText: 'questionText',
    usageCount: 'usageCount',
    correctAnswerRate: 'correctAnswerRate',
    averageTime: 'averageTime',
    difficulty: 'difficulty',
    examCategoryName: 'examCategoryName'
  };

  export type QuestionAnalyticsViewScalarFieldEnum = (typeof QuestionAnalyticsViewScalarFieldEnum)[keyof typeof QuestionAnalyticsViewScalarFieldEnum]


  export const RevenueAnalyticsViewScalarFieldEnum: {
    date: 'date',
    totalRevenue: 'totalRevenue',
    totalTransactions: 'totalTransactions',
    averageTransactionValue: 'averageTransactionValue',
    topExamCategory: 'topExamCategory',
    topExam: 'topExam'
  };

  export type RevenueAnalyticsViewScalarFieldEnum = (typeof RevenueAnalyticsViewScalarFieldEnum)[keyof typeof RevenueAnalyticsViewScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'QuestionType'
   */
  export type EnumQuestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionType'>
    


  /**
   * Reference to a field of type 'QuestionType[]'
   */
  export type ListEnumQuestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionType[]'>
    


  /**
   * Reference to a field of type 'QuestionDifficulty'
   */
  export type EnumQuestionDifficultyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionDifficulty'>
    


  /**
   * Reference to a field of type 'QuestionDifficulty[]'
   */
  export type ListEnumQuestionDifficultyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionDifficulty[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'BookingStatus'
   */
  export type EnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus'>
    


  /**
   * Reference to a field of type 'BookingStatus[]'
   */
  export type ListEnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus[]'>
    


  /**
   * Reference to a field of type 'AttemptStatus'
   */
  export type EnumAttemptStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttemptStatus'>
    


  /**
   * Reference to a field of type 'AttemptStatus[]'
   */
  export type ListEnumAttemptStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttemptStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'GroupRole'
   */
  export type EnumGroupRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GroupRole'>
    


  /**
   * Reference to a field of type 'GroupRole[]'
   */
  export type ListEnumGroupRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GroupRole[]'>
    


  /**
   * Reference to a field of type 'AccessLevel'
   */
  export type EnumAccessLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccessLevel'>
    


  /**
   * Reference to a field of type 'AccessLevel[]'
   */
  export type ListEnumAccessLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccessLevel[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    gender?: EnumGenderNullableFilter<"User"> | $Enums.Gender | null
    profileImage?: StringNullableFilter<"User"> | string | null
    profilePicture?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    isEmailVerified?: BoolFilter<"User"> | boolean
    isPhoneVerified?: BoolFilter<"User"> | boolean
    emailVerificationToken?: StringNullableFilter<"User"> | string | null
    passwordResetToken?: StringNullableFilter<"User"> | string | null
    passwordResetExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    loginAttempts?: IntFilter<"User"> | number
    lockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: StringNullableFilter<"User"> | string | null
    departmentId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    examBookings?: ExamBookingListRelationFilter
    payments?: PaymentListRelationFilter
    examAttempts?: ExamAttemptListRelationFilter
    questionResponses?: QuestionResponseListRelationFilter
    questionScores?: QuestionScoreListRelationFilter
    examScores?: ExamScoreListRelationFilter
    userPerformances?: UserPerformanceListRelationFilter
    notifications?: NotificationListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    userSessions?: UserSessionListRelationFilter
    examCategories?: ExamCategoryUserListRelationFilter
    studyGroups?: StudyGroupMemberListRelationFilter
    certificates?: CertificateListRelationFilter
    grantedExamCategories?: ExamCategoryUserListRelationFilter
    createdStudyGroups?: StudyGroupListRelationFilter
    createdQuestions?: QuestionListRelationFilter
    approvedQuestions?: QuestionListRelationFilter
    createdExams?: ExamListRelationFilter
    approvedExams?: ExamListRelationFilter
    revokedCertificates?: CertificateListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    profileImage?: SortOrderInput | SortOrder
    profilePicture?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isEmailVerified?: SortOrder
    isPhoneVerified?: SortOrder
    emailVerificationToken?: SortOrderInput | SortOrder
    passwordResetToken?: SortOrderInput | SortOrder
    passwordResetExpires?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    loginAttempts?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    examBookings?: ExamBookingOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    examAttempts?: ExamAttemptOrderByRelationAggregateInput
    questionResponses?: QuestionResponseOrderByRelationAggregateInput
    questionScores?: QuestionScoreOrderByRelationAggregateInput
    examScores?: ExamScoreOrderByRelationAggregateInput
    userPerformances?: UserPerformanceOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    userSessions?: UserSessionOrderByRelationAggregateInput
    examCategories?: ExamCategoryUserOrderByRelationAggregateInput
    studyGroups?: StudyGroupMemberOrderByRelationAggregateInput
    certificates?: CertificateOrderByRelationAggregateInput
    grantedExamCategories?: ExamCategoryUserOrderByRelationAggregateInput
    createdStudyGroups?: StudyGroupOrderByRelationAggregateInput
    createdQuestions?: QuestionOrderByRelationAggregateInput
    approvedQuestions?: QuestionOrderByRelationAggregateInput
    createdExams?: ExamOrderByRelationAggregateInput
    approvedExams?: ExamOrderByRelationAggregateInput
    revokedCertificates?: CertificateOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    gender?: EnumGenderNullableFilter<"User"> | $Enums.Gender | null
    profileImage?: StringNullableFilter<"User"> | string | null
    profilePicture?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    isEmailVerified?: BoolFilter<"User"> | boolean
    isPhoneVerified?: BoolFilter<"User"> | boolean
    emailVerificationToken?: StringNullableFilter<"User"> | string | null
    passwordResetToken?: StringNullableFilter<"User"> | string | null
    passwordResetExpires?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLoginAt?: DateTimeNullableFilter<"User"> | Date | string | null
    loginAttempts?: IntFilter<"User"> | number
    lockedUntil?: DateTimeNullableFilter<"User"> | Date | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: StringNullableFilter<"User"> | string | null
    departmentId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    examBookings?: ExamBookingListRelationFilter
    payments?: PaymentListRelationFilter
    examAttempts?: ExamAttemptListRelationFilter
    questionResponses?: QuestionResponseListRelationFilter
    questionScores?: QuestionScoreListRelationFilter
    examScores?: ExamScoreListRelationFilter
    userPerformances?: UserPerformanceListRelationFilter
    notifications?: NotificationListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    userSessions?: UserSessionListRelationFilter
    examCategories?: ExamCategoryUserListRelationFilter
    studyGroups?: StudyGroupMemberListRelationFilter
    certificates?: CertificateListRelationFilter
    grantedExamCategories?: ExamCategoryUserListRelationFilter
    createdStudyGroups?: StudyGroupListRelationFilter
    createdQuestions?: QuestionListRelationFilter
    approvedQuestions?: QuestionListRelationFilter
    createdExams?: ExamListRelationFilter
    approvedExams?: ExamListRelationFilter
    revokedCertificates?: CertificateListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    profileImage?: SortOrderInput | SortOrder
    profilePicture?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isEmailVerified?: SortOrder
    isPhoneVerified?: SortOrder
    emailVerificationToken?: SortOrderInput | SortOrder
    passwordResetToken?: SortOrderInput | SortOrder
    passwordResetExpires?: SortOrderInput | SortOrder
    lastLoginAt?: SortOrderInput | SortOrder
    loginAttempts?: SortOrder
    lockedUntil?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    gender?: EnumGenderNullableWithAggregatesFilter<"User"> | $Enums.Gender | null
    profileImage?: StringNullableWithAggregatesFilter<"User"> | string | null
    profilePicture?: StringNullableWithAggregatesFilter<"User"> | string | null
    address?: StringNullableWithAggregatesFilter<"User"> | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    isEmailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    isPhoneVerified?: BoolWithAggregatesFilter<"User"> | boolean
    emailVerificationToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordResetToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordResetExpires?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    lastLoginAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    loginAttempts?: IntWithAggregatesFilter<"User"> | number
    lockedUntil?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    status?: StringNullableWithAggregatesFilter<"User"> | string | null
    departmentId?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type UserSessionWhereInput = {
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    id?: StringFilter<"UserSession"> | string
    userId?: StringFilter<"UserSession"> | string
    sessionToken?: StringFilter<"UserSession"> | string
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    ipAddress?: StringNullableFilter<"UserSession"> | string | null
    userAgent?: StringNullableFilter<"UserSession"> | string | null
    isActive?: BoolFilter<"UserSession"> | boolean
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionToken?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    userId?: StringFilter<"UserSession"> | string
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    ipAddress?: StringNullableFilter<"UserSession"> | string | null
    userAgent?: StringNullableFilter<"UserSession"> | string | null
    isActive?: BoolFilter<"UserSession"> | boolean
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type UserSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionToken?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: UserSessionCountOrderByAggregateInput
    _max?: UserSessionMaxOrderByAggregateInput
    _min?: UserSessionMinOrderByAggregateInput
  }

  export type UserSessionScalarWhereWithAggregatesInput = {
    AND?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    OR?: UserSessionScalarWhereWithAggregatesInput[]
    NOT?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSession"> | string
    userId?: StringWithAggregatesFilter<"UserSession"> | string
    sessionToken?: StringWithAggregatesFilter<"UserSession"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"UserSession"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"UserSession"> | string | null
    isActive?: BoolWithAggregatesFilter<"UserSession"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
  }

  export type ExamCategoryWhereInput = {
    AND?: ExamCategoryWhereInput | ExamCategoryWhereInput[]
    OR?: ExamCategoryWhereInput[]
    NOT?: ExamCategoryWhereInput | ExamCategoryWhereInput[]
    id?: StringFilter<"ExamCategory"> | string
    name?: StringFilter<"ExamCategory"> | string
    description?: StringNullableFilter<"ExamCategory"> | string | null
    icon?: StringNullableFilter<"ExamCategory"> | string | null
    color?: StringNullableFilter<"ExamCategory"> | string | null
    isActive?: BoolFilter<"ExamCategory"> | boolean
    sortOrder?: IntFilter<"ExamCategory"> | number
    createdAt?: DateTimeFilter<"ExamCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ExamCategory"> | Date | string
    exams?: ExamListRelationFilter
    questions?: QuestionListRelationFilter
    users?: ExamCategoryUserListRelationFilter
    userPerformances?: UserPerformanceListRelationFilter
  }

  export type ExamCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    exams?: ExamOrderByRelationAggregateInput
    questions?: QuestionOrderByRelationAggregateInput
    users?: ExamCategoryUserOrderByRelationAggregateInput
    userPerformances?: UserPerformanceOrderByRelationAggregateInput
  }

  export type ExamCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ExamCategoryWhereInput | ExamCategoryWhereInput[]
    OR?: ExamCategoryWhereInput[]
    NOT?: ExamCategoryWhereInput | ExamCategoryWhereInput[]
    description?: StringNullableFilter<"ExamCategory"> | string | null
    icon?: StringNullableFilter<"ExamCategory"> | string | null
    color?: StringNullableFilter<"ExamCategory"> | string | null
    isActive?: BoolFilter<"ExamCategory"> | boolean
    sortOrder?: IntFilter<"ExamCategory"> | number
    createdAt?: DateTimeFilter<"ExamCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ExamCategory"> | Date | string
    exams?: ExamListRelationFilter
    questions?: QuestionListRelationFilter
    users?: ExamCategoryUserListRelationFilter
    userPerformances?: UserPerformanceListRelationFilter
  }, "id" | "name">

  export type ExamCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExamCategoryCountOrderByAggregateInput
    _avg?: ExamCategoryAvgOrderByAggregateInput
    _max?: ExamCategoryMaxOrderByAggregateInput
    _min?: ExamCategoryMinOrderByAggregateInput
    _sum?: ExamCategorySumOrderByAggregateInput
  }

  export type ExamCategoryScalarWhereWithAggregatesInput = {
    AND?: ExamCategoryScalarWhereWithAggregatesInput | ExamCategoryScalarWhereWithAggregatesInput[]
    OR?: ExamCategoryScalarWhereWithAggregatesInput[]
    NOT?: ExamCategoryScalarWhereWithAggregatesInput | ExamCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExamCategory"> | string
    name?: StringWithAggregatesFilter<"ExamCategory"> | string
    description?: StringNullableWithAggregatesFilter<"ExamCategory"> | string | null
    icon?: StringNullableWithAggregatesFilter<"ExamCategory"> | string | null
    color?: StringNullableWithAggregatesFilter<"ExamCategory"> | string | null
    isActive?: BoolWithAggregatesFilter<"ExamCategory"> | boolean
    sortOrder?: IntWithAggregatesFilter<"ExamCategory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ExamCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExamCategory"> | Date | string
  }

  export type QuestionWhereInput = {
    AND?: QuestionWhereInput | QuestionWhereInput[]
    OR?: QuestionWhereInput[]
    NOT?: QuestionWhereInput | QuestionWhereInput[]
    id?: StringFilter<"Question"> | string
    text?: StringFilter<"Question"> | string
    type?: EnumQuestionTypeFilter<"Question"> | $Enums.QuestionType
    difficulty?: EnumQuestionDifficultyFilter<"Question"> | $Enums.QuestionDifficulty
    examCategoryId?: StringFilter<"Question"> | string
    marks?: IntFilter<"Question"> | number
    timeLimit?: IntNullableFilter<"Question"> | number | null
    isActive?: BoolFilter<"Question"> | boolean
    isPublic?: BoolFilter<"Question"> | boolean
    createdBy?: StringFilter<"Question"> | string
    approvedBy?: StringNullableFilter<"Question"> | string | null
    approvedAt?: DateTimeNullableFilter<"Question"> | Date | string | null
    usageCount?: IntFilter<"Question"> | number
    correctAnswerRate?: FloatNullableFilter<"Question"> | number | null
    averageTime?: IntNullableFilter<"Question"> | number | null
    createdAt?: DateTimeFilter<"Question"> | Date | string
    updatedAt?: DateTimeFilter<"Question"> | Date | string
    examCategory?: XOR<ExamCategoryScalarRelationFilter, ExamCategoryWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    approver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    options?: QuestionOptionListRelationFilter
    images?: QuestionImageListRelationFilter
    tags?: QuestionTagListRelationFilter
    examQuestions?: ExamQuestionListRelationFilter
    responses?: QuestionResponseListRelationFilter
    scores?: QuestionScoreListRelationFilter
  }

  export type QuestionOrderByWithRelationInput = {
    id?: SortOrder
    text?: SortOrder
    type?: SortOrder
    difficulty?: SortOrder
    examCategoryId?: SortOrder
    marks?: SortOrder
    timeLimit?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    createdBy?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    usageCount?: SortOrder
    correctAnswerRate?: SortOrderInput | SortOrder
    averageTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    examCategory?: ExamCategoryOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    approver?: UserOrderByWithRelationInput
    options?: QuestionOptionOrderByRelationAggregateInput
    images?: QuestionImageOrderByRelationAggregateInput
    tags?: QuestionTagOrderByRelationAggregateInput
    examQuestions?: ExamQuestionOrderByRelationAggregateInput
    responses?: QuestionResponseOrderByRelationAggregateInput
    scores?: QuestionScoreOrderByRelationAggregateInput
  }

  export type QuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuestionWhereInput | QuestionWhereInput[]
    OR?: QuestionWhereInput[]
    NOT?: QuestionWhereInput | QuestionWhereInput[]
    text?: StringFilter<"Question"> | string
    type?: EnumQuestionTypeFilter<"Question"> | $Enums.QuestionType
    difficulty?: EnumQuestionDifficultyFilter<"Question"> | $Enums.QuestionDifficulty
    examCategoryId?: StringFilter<"Question"> | string
    marks?: IntFilter<"Question"> | number
    timeLimit?: IntNullableFilter<"Question"> | number | null
    isActive?: BoolFilter<"Question"> | boolean
    isPublic?: BoolFilter<"Question"> | boolean
    createdBy?: StringFilter<"Question"> | string
    approvedBy?: StringNullableFilter<"Question"> | string | null
    approvedAt?: DateTimeNullableFilter<"Question"> | Date | string | null
    usageCount?: IntFilter<"Question"> | number
    correctAnswerRate?: FloatNullableFilter<"Question"> | number | null
    averageTime?: IntNullableFilter<"Question"> | number | null
    createdAt?: DateTimeFilter<"Question"> | Date | string
    updatedAt?: DateTimeFilter<"Question"> | Date | string
    examCategory?: XOR<ExamCategoryScalarRelationFilter, ExamCategoryWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    approver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    options?: QuestionOptionListRelationFilter
    images?: QuestionImageListRelationFilter
    tags?: QuestionTagListRelationFilter
    examQuestions?: ExamQuestionListRelationFilter
    responses?: QuestionResponseListRelationFilter
    scores?: QuestionScoreListRelationFilter
  }, "id">

  export type QuestionOrderByWithAggregationInput = {
    id?: SortOrder
    text?: SortOrder
    type?: SortOrder
    difficulty?: SortOrder
    examCategoryId?: SortOrder
    marks?: SortOrder
    timeLimit?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    createdBy?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    usageCount?: SortOrder
    correctAnswerRate?: SortOrderInput | SortOrder
    averageTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuestionCountOrderByAggregateInput
    _avg?: QuestionAvgOrderByAggregateInput
    _max?: QuestionMaxOrderByAggregateInput
    _min?: QuestionMinOrderByAggregateInput
    _sum?: QuestionSumOrderByAggregateInput
  }

  export type QuestionScalarWhereWithAggregatesInput = {
    AND?: QuestionScalarWhereWithAggregatesInput | QuestionScalarWhereWithAggregatesInput[]
    OR?: QuestionScalarWhereWithAggregatesInput[]
    NOT?: QuestionScalarWhereWithAggregatesInput | QuestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Question"> | string
    text?: StringWithAggregatesFilter<"Question"> | string
    type?: EnumQuestionTypeWithAggregatesFilter<"Question"> | $Enums.QuestionType
    difficulty?: EnumQuestionDifficultyWithAggregatesFilter<"Question"> | $Enums.QuestionDifficulty
    examCategoryId?: StringWithAggregatesFilter<"Question"> | string
    marks?: IntWithAggregatesFilter<"Question"> | number
    timeLimit?: IntNullableWithAggregatesFilter<"Question"> | number | null
    isActive?: BoolWithAggregatesFilter<"Question"> | boolean
    isPublic?: BoolWithAggregatesFilter<"Question"> | boolean
    createdBy?: StringWithAggregatesFilter<"Question"> | string
    approvedBy?: StringNullableWithAggregatesFilter<"Question"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"Question"> | Date | string | null
    usageCount?: IntWithAggregatesFilter<"Question"> | number
    correctAnswerRate?: FloatNullableWithAggregatesFilter<"Question"> | number | null
    averageTime?: IntNullableWithAggregatesFilter<"Question"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Question"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Question"> | Date | string
  }

  export type QuestionOptionWhereInput = {
    AND?: QuestionOptionWhereInput | QuestionOptionWhereInput[]
    OR?: QuestionOptionWhereInput[]
    NOT?: QuestionOptionWhereInput | QuestionOptionWhereInput[]
    id?: StringFilter<"QuestionOption"> | string
    questionId?: StringFilter<"QuestionOption"> | string
    text?: StringFilter<"QuestionOption"> | string
    isCorrect?: BoolFilter<"QuestionOption"> | boolean
    sortOrder?: IntFilter<"QuestionOption"> | number
    createdAt?: DateTimeFilter<"QuestionOption"> | Date | string
    question?: XOR<QuestionScalarRelationFilter, QuestionWhereInput>
  }

  export type QuestionOptionOrderByWithRelationInput = {
    id?: SortOrder
    questionId?: SortOrder
    text?: SortOrder
    isCorrect?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    question?: QuestionOrderByWithRelationInput
  }

  export type QuestionOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuestionOptionWhereInput | QuestionOptionWhereInput[]
    OR?: QuestionOptionWhereInput[]
    NOT?: QuestionOptionWhereInput | QuestionOptionWhereInput[]
    questionId?: StringFilter<"QuestionOption"> | string
    text?: StringFilter<"QuestionOption"> | string
    isCorrect?: BoolFilter<"QuestionOption"> | boolean
    sortOrder?: IntFilter<"QuestionOption"> | number
    createdAt?: DateTimeFilter<"QuestionOption"> | Date | string
    question?: XOR<QuestionScalarRelationFilter, QuestionWhereInput>
  }, "id">

  export type QuestionOptionOrderByWithAggregationInput = {
    id?: SortOrder
    questionId?: SortOrder
    text?: SortOrder
    isCorrect?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    _count?: QuestionOptionCountOrderByAggregateInput
    _avg?: QuestionOptionAvgOrderByAggregateInput
    _max?: QuestionOptionMaxOrderByAggregateInput
    _min?: QuestionOptionMinOrderByAggregateInput
    _sum?: QuestionOptionSumOrderByAggregateInput
  }

  export type QuestionOptionScalarWhereWithAggregatesInput = {
    AND?: QuestionOptionScalarWhereWithAggregatesInput | QuestionOptionScalarWhereWithAggregatesInput[]
    OR?: QuestionOptionScalarWhereWithAggregatesInput[]
    NOT?: QuestionOptionScalarWhereWithAggregatesInput | QuestionOptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuestionOption"> | string
    questionId?: StringWithAggregatesFilter<"QuestionOption"> | string
    text?: StringWithAggregatesFilter<"QuestionOption"> | string
    isCorrect?: BoolWithAggregatesFilter<"QuestionOption"> | boolean
    sortOrder?: IntWithAggregatesFilter<"QuestionOption"> | number
    createdAt?: DateTimeWithAggregatesFilter<"QuestionOption"> | Date | string
  }

  export type QuestionImageWhereInput = {
    AND?: QuestionImageWhereInput | QuestionImageWhereInput[]
    OR?: QuestionImageWhereInput[]
    NOT?: QuestionImageWhereInput | QuestionImageWhereInput[]
    id?: StringFilter<"QuestionImage"> | string
    questionId?: StringFilter<"QuestionImage"> | string
    imageUrl?: StringFilter<"QuestionImage"> | string
    altText?: StringNullableFilter<"QuestionImage"> | string | null
    sortOrder?: IntFilter<"QuestionImage"> | number
    createdAt?: DateTimeFilter<"QuestionImage"> | Date | string
    question?: XOR<QuestionScalarRelationFilter, QuestionWhereInput>
  }

  export type QuestionImageOrderByWithRelationInput = {
    id?: SortOrder
    questionId?: SortOrder
    imageUrl?: SortOrder
    altText?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    question?: QuestionOrderByWithRelationInput
  }

  export type QuestionImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuestionImageWhereInput | QuestionImageWhereInput[]
    OR?: QuestionImageWhereInput[]
    NOT?: QuestionImageWhereInput | QuestionImageWhereInput[]
    questionId?: StringFilter<"QuestionImage"> | string
    imageUrl?: StringFilter<"QuestionImage"> | string
    altText?: StringNullableFilter<"QuestionImage"> | string | null
    sortOrder?: IntFilter<"QuestionImage"> | number
    createdAt?: DateTimeFilter<"QuestionImage"> | Date | string
    question?: XOR<QuestionScalarRelationFilter, QuestionWhereInput>
  }, "id">

  export type QuestionImageOrderByWithAggregationInput = {
    id?: SortOrder
    questionId?: SortOrder
    imageUrl?: SortOrder
    altText?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    _count?: QuestionImageCountOrderByAggregateInput
    _avg?: QuestionImageAvgOrderByAggregateInput
    _max?: QuestionImageMaxOrderByAggregateInput
    _min?: QuestionImageMinOrderByAggregateInput
    _sum?: QuestionImageSumOrderByAggregateInput
  }

  export type QuestionImageScalarWhereWithAggregatesInput = {
    AND?: QuestionImageScalarWhereWithAggregatesInput | QuestionImageScalarWhereWithAggregatesInput[]
    OR?: QuestionImageScalarWhereWithAggregatesInput[]
    NOT?: QuestionImageScalarWhereWithAggregatesInput | QuestionImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuestionImage"> | string
    questionId?: StringWithAggregatesFilter<"QuestionImage"> | string
    imageUrl?: StringWithAggregatesFilter<"QuestionImage"> | string
    altText?: StringNullableWithAggregatesFilter<"QuestionImage"> | string | null
    sortOrder?: IntWithAggregatesFilter<"QuestionImage"> | number
    createdAt?: DateTimeWithAggregatesFilter<"QuestionImage"> | Date | string
  }

  export type QuestionTagWhereInput = {
    AND?: QuestionTagWhereInput | QuestionTagWhereInput[]
    OR?: QuestionTagWhereInput[]
    NOT?: QuestionTagWhereInput | QuestionTagWhereInput[]
    id?: StringFilter<"QuestionTag"> | string
    questionId?: StringFilter<"QuestionTag"> | string
    tag?: StringFilter<"QuestionTag"> | string
    createdAt?: DateTimeFilter<"QuestionTag"> | Date | string
    question?: XOR<QuestionScalarRelationFilter, QuestionWhereInput>
  }

  export type QuestionTagOrderByWithRelationInput = {
    id?: SortOrder
    questionId?: SortOrder
    tag?: SortOrder
    createdAt?: SortOrder
    question?: QuestionOrderByWithRelationInput
  }

  export type QuestionTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    questionId_tag?: QuestionTagQuestionIdTagCompoundUniqueInput
    AND?: QuestionTagWhereInput | QuestionTagWhereInput[]
    OR?: QuestionTagWhereInput[]
    NOT?: QuestionTagWhereInput | QuestionTagWhereInput[]
    questionId?: StringFilter<"QuestionTag"> | string
    tag?: StringFilter<"QuestionTag"> | string
    createdAt?: DateTimeFilter<"QuestionTag"> | Date | string
    question?: XOR<QuestionScalarRelationFilter, QuestionWhereInput>
  }, "id" | "questionId_tag">

  export type QuestionTagOrderByWithAggregationInput = {
    id?: SortOrder
    questionId?: SortOrder
    tag?: SortOrder
    createdAt?: SortOrder
    _count?: QuestionTagCountOrderByAggregateInput
    _max?: QuestionTagMaxOrderByAggregateInput
    _min?: QuestionTagMinOrderByAggregateInput
  }

  export type QuestionTagScalarWhereWithAggregatesInput = {
    AND?: QuestionTagScalarWhereWithAggregatesInput | QuestionTagScalarWhereWithAggregatesInput[]
    OR?: QuestionTagScalarWhereWithAggregatesInput[]
    NOT?: QuestionTagScalarWhereWithAggregatesInput | QuestionTagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuestionTag"> | string
    questionId?: StringWithAggregatesFilter<"QuestionTag"> | string
    tag?: StringWithAggregatesFilter<"QuestionTag"> | string
    createdAt?: DateTimeWithAggregatesFilter<"QuestionTag"> | Date | string
  }

  export type ExamWhereInput = {
    AND?: ExamWhereInput | ExamWhereInput[]
    OR?: ExamWhereInput[]
    NOT?: ExamWhereInput | ExamWhereInput[]
    id?: StringFilter<"Exam"> | string
    title?: StringFilter<"Exam"> | string
    description?: StringNullableFilter<"Exam"> | string | null
    examCategoryId?: StringFilter<"Exam"> | string
    duration?: IntFilter<"Exam"> | number
    totalMarks?: IntFilter<"Exam"> | number
    passingMarks?: IntFilter<"Exam"> | number
    price?: DecimalFilter<"Exam"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Exam"> | string
    isActive?: BoolFilter<"Exam"> | boolean
    isPublic?: BoolFilter<"Exam"> | boolean
    allowRetakes?: BoolFilter<"Exam"> | boolean
    maxRetakes?: IntFilter<"Exam"> | number
    showResults?: BoolFilter<"Exam"> | boolean
    showAnswers?: BoolFilter<"Exam"> | boolean
    randomizeQuestions?: BoolFilter<"Exam"> | boolean
    randomizeOptions?: BoolFilter<"Exam"> | boolean
    questionOverlapPercentage?: FloatFilter<"Exam"> | number
    createdBy?: StringFilter<"Exam"> | string
    approvedBy?: StringNullableFilter<"Exam"> | string | null
    approvedAt?: DateTimeNullableFilter<"Exam"> | Date | string | null
    scheduledStart?: DateTimeNullableFilter<"Exam"> | Date | string | null
    scheduledEnd?: DateTimeNullableFilter<"Exam"> | Date | string | null
    createdAt?: DateTimeFilter<"Exam"> | Date | string
    updatedAt?: DateTimeFilter<"Exam"> | Date | string
    examCategory?: XOR<ExamCategoryScalarRelationFilter, ExamCategoryWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    approver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    questions?: ExamQuestionListRelationFilter
    bookings?: ExamBookingListRelationFilter
    attempts?: ExamAttemptListRelationFilter
    examScores?: ExamScoreListRelationFilter
    certificates?: CertificateListRelationFilter
  }

  export type ExamOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    examCategoryId?: SortOrder
    duration?: SortOrder
    totalMarks?: SortOrder
    passingMarks?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    allowRetakes?: SortOrder
    maxRetakes?: SortOrder
    showResults?: SortOrder
    showAnswers?: SortOrder
    randomizeQuestions?: SortOrder
    randomizeOptions?: SortOrder
    questionOverlapPercentage?: SortOrder
    createdBy?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    scheduledStart?: SortOrderInput | SortOrder
    scheduledEnd?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    examCategory?: ExamCategoryOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    approver?: UserOrderByWithRelationInput
    questions?: ExamQuestionOrderByRelationAggregateInput
    bookings?: ExamBookingOrderByRelationAggregateInput
    attempts?: ExamAttemptOrderByRelationAggregateInput
    examScores?: ExamScoreOrderByRelationAggregateInput
    certificates?: CertificateOrderByRelationAggregateInput
  }

  export type ExamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExamWhereInput | ExamWhereInput[]
    OR?: ExamWhereInput[]
    NOT?: ExamWhereInput | ExamWhereInput[]
    title?: StringFilter<"Exam"> | string
    description?: StringNullableFilter<"Exam"> | string | null
    examCategoryId?: StringFilter<"Exam"> | string
    duration?: IntFilter<"Exam"> | number
    totalMarks?: IntFilter<"Exam"> | number
    passingMarks?: IntFilter<"Exam"> | number
    price?: DecimalFilter<"Exam"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Exam"> | string
    isActive?: BoolFilter<"Exam"> | boolean
    isPublic?: BoolFilter<"Exam"> | boolean
    allowRetakes?: BoolFilter<"Exam"> | boolean
    maxRetakes?: IntFilter<"Exam"> | number
    showResults?: BoolFilter<"Exam"> | boolean
    showAnswers?: BoolFilter<"Exam"> | boolean
    randomizeQuestions?: BoolFilter<"Exam"> | boolean
    randomizeOptions?: BoolFilter<"Exam"> | boolean
    questionOverlapPercentage?: FloatFilter<"Exam"> | number
    createdBy?: StringFilter<"Exam"> | string
    approvedBy?: StringNullableFilter<"Exam"> | string | null
    approvedAt?: DateTimeNullableFilter<"Exam"> | Date | string | null
    scheduledStart?: DateTimeNullableFilter<"Exam"> | Date | string | null
    scheduledEnd?: DateTimeNullableFilter<"Exam"> | Date | string | null
    createdAt?: DateTimeFilter<"Exam"> | Date | string
    updatedAt?: DateTimeFilter<"Exam"> | Date | string
    examCategory?: XOR<ExamCategoryScalarRelationFilter, ExamCategoryWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    approver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    questions?: ExamQuestionListRelationFilter
    bookings?: ExamBookingListRelationFilter
    attempts?: ExamAttemptListRelationFilter
    examScores?: ExamScoreListRelationFilter
    certificates?: CertificateListRelationFilter
  }, "id">

  export type ExamOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    examCategoryId?: SortOrder
    duration?: SortOrder
    totalMarks?: SortOrder
    passingMarks?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    allowRetakes?: SortOrder
    maxRetakes?: SortOrder
    showResults?: SortOrder
    showAnswers?: SortOrder
    randomizeQuestions?: SortOrder
    randomizeOptions?: SortOrder
    questionOverlapPercentage?: SortOrder
    createdBy?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    scheduledStart?: SortOrderInput | SortOrder
    scheduledEnd?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExamCountOrderByAggregateInput
    _avg?: ExamAvgOrderByAggregateInput
    _max?: ExamMaxOrderByAggregateInput
    _min?: ExamMinOrderByAggregateInput
    _sum?: ExamSumOrderByAggregateInput
  }

  export type ExamScalarWhereWithAggregatesInput = {
    AND?: ExamScalarWhereWithAggregatesInput | ExamScalarWhereWithAggregatesInput[]
    OR?: ExamScalarWhereWithAggregatesInput[]
    NOT?: ExamScalarWhereWithAggregatesInput | ExamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Exam"> | string
    title?: StringWithAggregatesFilter<"Exam"> | string
    description?: StringNullableWithAggregatesFilter<"Exam"> | string | null
    examCategoryId?: StringWithAggregatesFilter<"Exam"> | string
    duration?: IntWithAggregatesFilter<"Exam"> | number
    totalMarks?: IntWithAggregatesFilter<"Exam"> | number
    passingMarks?: IntWithAggregatesFilter<"Exam"> | number
    price?: DecimalWithAggregatesFilter<"Exam"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Exam"> | string
    isActive?: BoolWithAggregatesFilter<"Exam"> | boolean
    isPublic?: BoolWithAggregatesFilter<"Exam"> | boolean
    allowRetakes?: BoolWithAggregatesFilter<"Exam"> | boolean
    maxRetakes?: IntWithAggregatesFilter<"Exam"> | number
    showResults?: BoolWithAggregatesFilter<"Exam"> | boolean
    showAnswers?: BoolWithAggregatesFilter<"Exam"> | boolean
    randomizeQuestions?: BoolWithAggregatesFilter<"Exam"> | boolean
    randomizeOptions?: BoolWithAggregatesFilter<"Exam"> | boolean
    questionOverlapPercentage?: FloatWithAggregatesFilter<"Exam"> | number
    createdBy?: StringWithAggregatesFilter<"Exam"> | string
    approvedBy?: StringNullableWithAggregatesFilter<"Exam"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"Exam"> | Date | string | null
    scheduledStart?: DateTimeNullableWithAggregatesFilter<"Exam"> | Date | string | null
    scheduledEnd?: DateTimeNullableWithAggregatesFilter<"Exam"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Exam"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Exam"> | Date | string
  }

  export type ExamQuestionWhereInput = {
    AND?: ExamQuestionWhereInput | ExamQuestionWhereInput[]
    OR?: ExamQuestionWhereInput[]
    NOT?: ExamQuestionWhereInput | ExamQuestionWhereInput[]
    id?: StringFilter<"ExamQuestion"> | string
    examId?: StringFilter<"ExamQuestion"> | string
    questionId?: StringFilter<"ExamQuestion"> | string
    order?: IntFilter<"ExamQuestion"> | number
    marks?: IntFilter<"ExamQuestion"> | number
    createdAt?: DateTimeFilter<"ExamQuestion"> | Date | string
    exam?: XOR<ExamScalarRelationFilter, ExamWhereInput>
    question?: XOR<QuestionScalarRelationFilter, QuestionWhereInput>
  }

  export type ExamQuestionOrderByWithRelationInput = {
    id?: SortOrder
    examId?: SortOrder
    questionId?: SortOrder
    order?: SortOrder
    marks?: SortOrder
    createdAt?: SortOrder
    exam?: ExamOrderByWithRelationInput
    question?: QuestionOrderByWithRelationInput
  }

  export type ExamQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    examId_questionId?: ExamQuestionExamIdQuestionIdCompoundUniqueInput
    AND?: ExamQuestionWhereInput | ExamQuestionWhereInput[]
    OR?: ExamQuestionWhereInput[]
    NOT?: ExamQuestionWhereInput | ExamQuestionWhereInput[]
    examId?: StringFilter<"ExamQuestion"> | string
    questionId?: StringFilter<"ExamQuestion"> | string
    order?: IntFilter<"ExamQuestion"> | number
    marks?: IntFilter<"ExamQuestion"> | number
    createdAt?: DateTimeFilter<"ExamQuestion"> | Date | string
    exam?: XOR<ExamScalarRelationFilter, ExamWhereInput>
    question?: XOR<QuestionScalarRelationFilter, QuestionWhereInput>
  }, "id" | "examId_questionId">

  export type ExamQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    examId?: SortOrder
    questionId?: SortOrder
    order?: SortOrder
    marks?: SortOrder
    createdAt?: SortOrder
    _count?: ExamQuestionCountOrderByAggregateInput
    _avg?: ExamQuestionAvgOrderByAggregateInput
    _max?: ExamQuestionMaxOrderByAggregateInput
    _min?: ExamQuestionMinOrderByAggregateInput
    _sum?: ExamQuestionSumOrderByAggregateInput
  }

  export type ExamQuestionScalarWhereWithAggregatesInput = {
    AND?: ExamQuestionScalarWhereWithAggregatesInput | ExamQuestionScalarWhereWithAggregatesInput[]
    OR?: ExamQuestionScalarWhereWithAggregatesInput[]
    NOT?: ExamQuestionScalarWhereWithAggregatesInput | ExamQuestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExamQuestion"> | string
    examId?: StringWithAggregatesFilter<"ExamQuestion"> | string
    questionId?: StringWithAggregatesFilter<"ExamQuestion"> | string
    order?: IntWithAggregatesFilter<"ExamQuestion"> | number
    marks?: IntWithAggregatesFilter<"ExamQuestion"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ExamQuestion"> | Date | string
  }

  export type ExamBookingWhereInput = {
    AND?: ExamBookingWhereInput | ExamBookingWhereInput[]
    OR?: ExamBookingWhereInput[]
    NOT?: ExamBookingWhereInput | ExamBookingWhereInput[]
    id?: StringFilter<"ExamBooking"> | string
    userId?: StringFilter<"ExamBooking"> | string
    examId?: StringFilter<"ExamBooking"> | string
    bookingDate?: DateTimeFilter<"ExamBooking"> | Date | string
    scheduledAt?: DateTimeNullableFilter<"ExamBooking"> | Date | string | null
    status?: EnumBookingStatusFilter<"ExamBooking"> | $Enums.BookingStatus
    paymentId?: StringNullableFilter<"ExamBooking"> | string | null
    totalAmount?: DecimalFilter<"ExamBooking"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"ExamBooking"> | string
    notes?: StringNullableFilter<"ExamBooking"> | string | null
    createdAt?: DateTimeFilter<"ExamBooking"> | Date | string
    updatedAt?: DateTimeFilter<"ExamBooking"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    exam?: XOR<ExamScalarRelationFilter, ExamWhereInput>
    payment?: XOR<PaymentNullableScalarRelationFilter, PaymentWhereInput> | null
    attempts?: ExamAttemptListRelationFilter
  }

  export type ExamBookingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    examId?: SortOrder
    bookingDate?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    status?: SortOrder
    paymentId?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    exam?: ExamOrderByWithRelationInput
    payment?: PaymentOrderByWithRelationInput
    attempts?: ExamAttemptOrderByRelationAggregateInput
  }

  export type ExamBookingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExamBookingWhereInput | ExamBookingWhereInput[]
    OR?: ExamBookingWhereInput[]
    NOT?: ExamBookingWhereInput | ExamBookingWhereInput[]
    userId?: StringFilter<"ExamBooking"> | string
    examId?: StringFilter<"ExamBooking"> | string
    bookingDate?: DateTimeFilter<"ExamBooking"> | Date | string
    scheduledAt?: DateTimeNullableFilter<"ExamBooking"> | Date | string | null
    status?: EnumBookingStatusFilter<"ExamBooking"> | $Enums.BookingStatus
    paymentId?: StringNullableFilter<"ExamBooking"> | string | null
    totalAmount?: DecimalFilter<"ExamBooking"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"ExamBooking"> | string
    notes?: StringNullableFilter<"ExamBooking"> | string | null
    createdAt?: DateTimeFilter<"ExamBooking"> | Date | string
    updatedAt?: DateTimeFilter<"ExamBooking"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    exam?: XOR<ExamScalarRelationFilter, ExamWhereInput>
    payment?: XOR<PaymentNullableScalarRelationFilter, PaymentWhereInput> | null
    attempts?: ExamAttemptListRelationFilter
  }, "id">

  export type ExamBookingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    examId?: SortOrder
    bookingDate?: SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    status?: SortOrder
    paymentId?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExamBookingCountOrderByAggregateInput
    _avg?: ExamBookingAvgOrderByAggregateInput
    _max?: ExamBookingMaxOrderByAggregateInput
    _min?: ExamBookingMinOrderByAggregateInput
    _sum?: ExamBookingSumOrderByAggregateInput
  }

  export type ExamBookingScalarWhereWithAggregatesInput = {
    AND?: ExamBookingScalarWhereWithAggregatesInput | ExamBookingScalarWhereWithAggregatesInput[]
    OR?: ExamBookingScalarWhereWithAggregatesInput[]
    NOT?: ExamBookingScalarWhereWithAggregatesInput | ExamBookingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExamBooking"> | string
    userId?: StringWithAggregatesFilter<"ExamBooking"> | string
    examId?: StringWithAggregatesFilter<"ExamBooking"> | string
    bookingDate?: DateTimeWithAggregatesFilter<"ExamBooking"> | Date | string
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"ExamBooking"> | Date | string | null
    status?: EnumBookingStatusWithAggregatesFilter<"ExamBooking"> | $Enums.BookingStatus
    paymentId?: StringNullableWithAggregatesFilter<"ExamBooking"> | string | null
    totalAmount?: DecimalWithAggregatesFilter<"ExamBooking"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"ExamBooking"> | string
    notes?: StringNullableWithAggregatesFilter<"ExamBooking"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ExamBooking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExamBooking"> | Date | string
  }

  export type ExamAttemptWhereInput = {
    AND?: ExamAttemptWhereInput | ExamAttemptWhereInput[]
    OR?: ExamAttemptWhereInput[]
    NOT?: ExamAttemptWhereInput | ExamAttemptWhereInput[]
    id?: StringFilter<"ExamAttempt"> | string
    userId?: StringFilter<"ExamAttempt"> | string
    examId?: StringFilter<"ExamAttempt"> | string
    bookingId?: StringNullableFilter<"ExamAttempt"> | string | null
    startedAt?: DateTimeFilter<"ExamAttempt"> | Date | string
    completedAt?: DateTimeNullableFilter<"ExamAttempt"> | Date | string | null
    status?: EnumAttemptStatusFilter<"ExamAttempt"> | $Enums.AttemptStatus
    totalMarks?: IntFilter<"ExamAttempt"> | number
    obtainedMarks?: IntFilter<"ExamAttempt"> | number
    percentage?: FloatFilter<"ExamAttempt"> | number
    isPassed?: BoolFilter<"ExamAttempt"> | boolean
    timeSpent?: IntNullableFilter<"ExamAttempt"> | number | null
    ipAddress?: StringNullableFilter<"ExamAttempt"> | string | null
    userAgent?: StringNullableFilter<"ExamAttempt"> | string | null
    isCheating?: BoolFilter<"ExamAttempt"> | boolean
    cheatingReason?: StringNullableFilter<"ExamAttempt"> | string | null
    createdAt?: DateTimeFilter<"ExamAttempt"> | Date | string
    updatedAt?: DateTimeFilter<"ExamAttempt"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    exam?: XOR<ExamScalarRelationFilter, ExamWhereInput>
    booking?: XOR<ExamBookingNullableScalarRelationFilter, ExamBookingWhereInput> | null
    responses?: QuestionResponseListRelationFilter
    questionScores?: QuestionScoreListRelationFilter
    examScore?: XOR<ExamScoreNullableScalarRelationFilter, ExamScoreWhereInput> | null
    certificate?: XOR<CertificateNullableScalarRelationFilter, CertificateWhereInput> | null
  }

  export type ExamAttemptOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    examId?: SortOrder
    bookingId?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    totalMarks?: SortOrder
    obtainedMarks?: SortOrder
    percentage?: SortOrder
    isPassed?: SortOrder
    timeSpent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    isCheating?: SortOrder
    cheatingReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    exam?: ExamOrderByWithRelationInput
    booking?: ExamBookingOrderByWithRelationInput
    responses?: QuestionResponseOrderByRelationAggregateInput
    questionScores?: QuestionScoreOrderByRelationAggregateInput
    examScore?: ExamScoreOrderByWithRelationInput
    certificate?: CertificateOrderByWithRelationInput
  }

  export type ExamAttemptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExamAttemptWhereInput | ExamAttemptWhereInput[]
    OR?: ExamAttemptWhereInput[]
    NOT?: ExamAttemptWhereInput | ExamAttemptWhereInput[]
    userId?: StringFilter<"ExamAttempt"> | string
    examId?: StringFilter<"ExamAttempt"> | string
    bookingId?: StringNullableFilter<"ExamAttempt"> | string | null
    startedAt?: DateTimeFilter<"ExamAttempt"> | Date | string
    completedAt?: DateTimeNullableFilter<"ExamAttempt"> | Date | string | null
    status?: EnumAttemptStatusFilter<"ExamAttempt"> | $Enums.AttemptStatus
    totalMarks?: IntFilter<"ExamAttempt"> | number
    obtainedMarks?: IntFilter<"ExamAttempt"> | number
    percentage?: FloatFilter<"ExamAttempt"> | number
    isPassed?: BoolFilter<"ExamAttempt"> | boolean
    timeSpent?: IntNullableFilter<"ExamAttempt"> | number | null
    ipAddress?: StringNullableFilter<"ExamAttempt"> | string | null
    userAgent?: StringNullableFilter<"ExamAttempt"> | string | null
    isCheating?: BoolFilter<"ExamAttempt"> | boolean
    cheatingReason?: StringNullableFilter<"ExamAttempt"> | string | null
    createdAt?: DateTimeFilter<"ExamAttempt"> | Date | string
    updatedAt?: DateTimeFilter<"ExamAttempt"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    exam?: XOR<ExamScalarRelationFilter, ExamWhereInput>
    booking?: XOR<ExamBookingNullableScalarRelationFilter, ExamBookingWhereInput> | null
    responses?: QuestionResponseListRelationFilter
    questionScores?: QuestionScoreListRelationFilter
    examScore?: XOR<ExamScoreNullableScalarRelationFilter, ExamScoreWhereInput> | null
    certificate?: XOR<CertificateNullableScalarRelationFilter, CertificateWhereInput> | null
  }, "id">

  export type ExamAttemptOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    examId?: SortOrder
    bookingId?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    totalMarks?: SortOrder
    obtainedMarks?: SortOrder
    percentage?: SortOrder
    isPassed?: SortOrder
    timeSpent?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    isCheating?: SortOrder
    cheatingReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExamAttemptCountOrderByAggregateInput
    _avg?: ExamAttemptAvgOrderByAggregateInput
    _max?: ExamAttemptMaxOrderByAggregateInput
    _min?: ExamAttemptMinOrderByAggregateInput
    _sum?: ExamAttemptSumOrderByAggregateInput
  }

  export type ExamAttemptScalarWhereWithAggregatesInput = {
    AND?: ExamAttemptScalarWhereWithAggregatesInput | ExamAttemptScalarWhereWithAggregatesInput[]
    OR?: ExamAttemptScalarWhereWithAggregatesInput[]
    NOT?: ExamAttemptScalarWhereWithAggregatesInput | ExamAttemptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExamAttempt"> | string
    userId?: StringWithAggregatesFilter<"ExamAttempt"> | string
    examId?: StringWithAggregatesFilter<"ExamAttempt"> | string
    bookingId?: StringNullableWithAggregatesFilter<"ExamAttempt"> | string | null
    startedAt?: DateTimeWithAggregatesFilter<"ExamAttempt"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"ExamAttempt"> | Date | string | null
    status?: EnumAttemptStatusWithAggregatesFilter<"ExamAttempt"> | $Enums.AttemptStatus
    totalMarks?: IntWithAggregatesFilter<"ExamAttempt"> | number
    obtainedMarks?: IntWithAggregatesFilter<"ExamAttempt"> | number
    percentage?: FloatWithAggregatesFilter<"ExamAttempt"> | number
    isPassed?: BoolWithAggregatesFilter<"ExamAttempt"> | boolean
    timeSpent?: IntNullableWithAggregatesFilter<"ExamAttempt"> | number | null
    ipAddress?: StringNullableWithAggregatesFilter<"ExamAttempt"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"ExamAttempt"> | string | null
    isCheating?: BoolWithAggregatesFilter<"ExamAttempt"> | boolean
    cheatingReason?: StringNullableWithAggregatesFilter<"ExamAttempt"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ExamAttempt"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExamAttempt"> | Date | string
  }

  export type QuestionResponseWhereInput = {
    AND?: QuestionResponseWhereInput | QuestionResponseWhereInput[]
    OR?: QuestionResponseWhereInput[]
    NOT?: QuestionResponseWhereInput | QuestionResponseWhereInput[]
    id?: StringFilter<"QuestionResponse"> | string
    attemptId?: StringFilter<"QuestionResponse"> | string
    questionId?: StringFilter<"QuestionResponse"> | string
    userId?: StringFilter<"QuestionResponse"> | string
    selectedOptions?: StringNullableListFilter<"QuestionResponse">
    isCorrect?: BoolNullableFilter<"QuestionResponse"> | boolean | null
    marksObtained?: IntFilter<"QuestionResponse"> | number
    timeSpent?: IntNullableFilter<"QuestionResponse"> | number | null
    answeredAt?: DateTimeFilter<"QuestionResponse"> | Date | string
    submittedAt?: DateTimeFilter<"QuestionResponse"> | Date | string
    createdAt?: DateTimeFilter<"QuestionResponse"> | Date | string
    updatedAt?: DateTimeFilter<"QuestionResponse"> | Date | string
    attempt?: XOR<ExamAttemptScalarRelationFilter, ExamAttemptWhereInput>
    question?: XOR<QuestionScalarRelationFilter, QuestionWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    score?: XOR<QuestionScoreNullableScalarRelationFilter, QuestionScoreWhereInput> | null
  }

  export type QuestionResponseOrderByWithRelationInput = {
    id?: SortOrder
    attemptId?: SortOrder
    questionId?: SortOrder
    userId?: SortOrder
    selectedOptions?: SortOrder
    isCorrect?: SortOrderInput | SortOrder
    marksObtained?: SortOrder
    timeSpent?: SortOrderInput | SortOrder
    answeredAt?: SortOrder
    submittedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    attempt?: ExamAttemptOrderByWithRelationInput
    question?: QuestionOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    score?: QuestionScoreOrderByWithRelationInput
  }

  export type QuestionResponseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    attemptId_questionId?: QuestionResponseAttemptIdQuestionIdCompoundUniqueInput
    AND?: QuestionResponseWhereInput | QuestionResponseWhereInput[]
    OR?: QuestionResponseWhereInput[]
    NOT?: QuestionResponseWhereInput | QuestionResponseWhereInput[]
    attemptId?: StringFilter<"QuestionResponse"> | string
    questionId?: StringFilter<"QuestionResponse"> | string
    userId?: StringFilter<"QuestionResponse"> | string
    selectedOptions?: StringNullableListFilter<"QuestionResponse">
    isCorrect?: BoolNullableFilter<"QuestionResponse"> | boolean | null
    marksObtained?: IntFilter<"QuestionResponse"> | number
    timeSpent?: IntNullableFilter<"QuestionResponse"> | number | null
    answeredAt?: DateTimeFilter<"QuestionResponse"> | Date | string
    submittedAt?: DateTimeFilter<"QuestionResponse"> | Date | string
    createdAt?: DateTimeFilter<"QuestionResponse"> | Date | string
    updatedAt?: DateTimeFilter<"QuestionResponse"> | Date | string
    attempt?: XOR<ExamAttemptScalarRelationFilter, ExamAttemptWhereInput>
    question?: XOR<QuestionScalarRelationFilter, QuestionWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    score?: XOR<QuestionScoreNullableScalarRelationFilter, QuestionScoreWhereInput> | null
  }, "id" | "attemptId_questionId">

  export type QuestionResponseOrderByWithAggregationInput = {
    id?: SortOrder
    attemptId?: SortOrder
    questionId?: SortOrder
    userId?: SortOrder
    selectedOptions?: SortOrder
    isCorrect?: SortOrderInput | SortOrder
    marksObtained?: SortOrder
    timeSpent?: SortOrderInput | SortOrder
    answeredAt?: SortOrder
    submittedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuestionResponseCountOrderByAggregateInput
    _avg?: QuestionResponseAvgOrderByAggregateInput
    _max?: QuestionResponseMaxOrderByAggregateInput
    _min?: QuestionResponseMinOrderByAggregateInput
    _sum?: QuestionResponseSumOrderByAggregateInput
  }

  export type QuestionResponseScalarWhereWithAggregatesInput = {
    AND?: QuestionResponseScalarWhereWithAggregatesInput | QuestionResponseScalarWhereWithAggregatesInput[]
    OR?: QuestionResponseScalarWhereWithAggregatesInput[]
    NOT?: QuestionResponseScalarWhereWithAggregatesInput | QuestionResponseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuestionResponse"> | string
    attemptId?: StringWithAggregatesFilter<"QuestionResponse"> | string
    questionId?: StringWithAggregatesFilter<"QuestionResponse"> | string
    userId?: StringWithAggregatesFilter<"QuestionResponse"> | string
    selectedOptions?: StringNullableListFilter<"QuestionResponse">
    isCorrect?: BoolNullableWithAggregatesFilter<"QuestionResponse"> | boolean | null
    marksObtained?: IntWithAggregatesFilter<"QuestionResponse"> | number
    timeSpent?: IntNullableWithAggregatesFilter<"QuestionResponse"> | number | null
    answeredAt?: DateTimeWithAggregatesFilter<"QuestionResponse"> | Date | string
    submittedAt?: DateTimeWithAggregatesFilter<"QuestionResponse"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"QuestionResponse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QuestionResponse"> | Date | string
  }

  export type QuestionScoreWhereInput = {
    AND?: QuestionScoreWhereInput | QuestionScoreWhereInput[]
    OR?: QuestionScoreWhereInput[]
    NOT?: QuestionScoreWhereInput | QuestionScoreWhereInput[]
    id?: StringFilter<"QuestionScore"> | string
    responseId?: StringFilter<"QuestionScore"> | string
    questionId?: StringFilter<"QuestionScore"> | string
    attemptId?: StringFilter<"QuestionScore"> | string
    userId?: StringFilter<"QuestionScore"> | string
    isCorrect?: BoolFilter<"QuestionScore"> | boolean
    marksObtained?: FloatFilter<"QuestionScore"> | number
    maxMarks?: FloatFilter<"QuestionScore"> | number
    accuracy?: FloatFilter<"QuestionScore"> | number
    timeEfficiency?: FloatFilter<"QuestionScore"> | number
    difficultyBonus?: FloatFilter<"QuestionScore"> | number
    penalty?: FloatFilter<"QuestionScore"> | number
    responseTime?: IntFilter<"QuestionScore"> | number
    attemptsCount?: IntFilter<"QuestionScore"> | number
    confidenceLevel?: FloatFilter<"QuestionScore"> | number
    questionDifficulty?: StringFilter<"QuestionScore"> | string
    scoredAt?: DateTimeFilter<"QuestionScore"> | Date | string
    createdAt?: DateTimeFilter<"QuestionScore"> | Date | string
    updatedAt?: DateTimeFilter<"QuestionScore"> | Date | string
    response?: XOR<QuestionResponseScalarRelationFilter, QuestionResponseWhereInput>
    question?: XOR<QuestionScalarRelationFilter, QuestionWhereInput>
    attempt?: XOR<ExamAttemptScalarRelationFilter, ExamAttemptWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type QuestionScoreOrderByWithRelationInput = {
    id?: SortOrder
    responseId?: SortOrder
    questionId?: SortOrder
    attemptId?: SortOrder
    userId?: SortOrder
    isCorrect?: SortOrder
    marksObtained?: SortOrder
    maxMarks?: SortOrder
    accuracy?: SortOrder
    timeEfficiency?: SortOrder
    difficultyBonus?: SortOrder
    penalty?: SortOrder
    responseTime?: SortOrder
    attemptsCount?: SortOrder
    confidenceLevel?: SortOrder
    questionDifficulty?: SortOrder
    scoredAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    response?: QuestionResponseOrderByWithRelationInput
    question?: QuestionOrderByWithRelationInput
    attempt?: ExamAttemptOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type QuestionScoreWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    responseId?: string
    AND?: QuestionScoreWhereInput | QuestionScoreWhereInput[]
    OR?: QuestionScoreWhereInput[]
    NOT?: QuestionScoreWhereInput | QuestionScoreWhereInput[]
    questionId?: StringFilter<"QuestionScore"> | string
    attemptId?: StringFilter<"QuestionScore"> | string
    userId?: StringFilter<"QuestionScore"> | string
    isCorrect?: BoolFilter<"QuestionScore"> | boolean
    marksObtained?: FloatFilter<"QuestionScore"> | number
    maxMarks?: FloatFilter<"QuestionScore"> | number
    accuracy?: FloatFilter<"QuestionScore"> | number
    timeEfficiency?: FloatFilter<"QuestionScore"> | number
    difficultyBonus?: FloatFilter<"QuestionScore"> | number
    penalty?: FloatFilter<"QuestionScore"> | number
    responseTime?: IntFilter<"QuestionScore"> | number
    attemptsCount?: IntFilter<"QuestionScore"> | number
    confidenceLevel?: FloatFilter<"QuestionScore"> | number
    questionDifficulty?: StringFilter<"QuestionScore"> | string
    scoredAt?: DateTimeFilter<"QuestionScore"> | Date | string
    createdAt?: DateTimeFilter<"QuestionScore"> | Date | string
    updatedAt?: DateTimeFilter<"QuestionScore"> | Date | string
    response?: XOR<QuestionResponseScalarRelationFilter, QuestionResponseWhereInput>
    question?: XOR<QuestionScalarRelationFilter, QuestionWhereInput>
    attempt?: XOR<ExamAttemptScalarRelationFilter, ExamAttemptWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "responseId">

  export type QuestionScoreOrderByWithAggregationInput = {
    id?: SortOrder
    responseId?: SortOrder
    questionId?: SortOrder
    attemptId?: SortOrder
    userId?: SortOrder
    isCorrect?: SortOrder
    marksObtained?: SortOrder
    maxMarks?: SortOrder
    accuracy?: SortOrder
    timeEfficiency?: SortOrder
    difficultyBonus?: SortOrder
    penalty?: SortOrder
    responseTime?: SortOrder
    attemptsCount?: SortOrder
    confidenceLevel?: SortOrder
    questionDifficulty?: SortOrder
    scoredAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuestionScoreCountOrderByAggregateInput
    _avg?: QuestionScoreAvgOrderByAggregateInput
    _max?: QuestionScoreMaxOrderByAggregateInput
    _min?: QuestionScoreMinOrderByAggregateInput
    _sum?: QuestionScoreSumOrderByAggregateInput
  }

  export type QuestionScoreScalarWhereWithAggregatesInput = {
    AND?: QuestionScoreScalarWhereWithAggregatesInput | QuestionScoreScalarWhereWithAggregatesInput[]
    OR?: QuestionScoreScalarWhereWithAggregatesInput[]
    NOT?: QuestionScoreScalarWhereWithAggregatesInput | QuestionScoreScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuestionScore"> | string
    responseId?: StringWithAggregatesFilter<"QuestionScore"> | string
    questionId?: StringWithAggregatesFilter<"QuestionScore"> | string
    attemptId?: StringWithAggregatesFilter<"QuestionScore"> | string
    userId?: StringWithAggregatesFilter<"QuestionScore"> | string
    isCorrect?: BoolWithAggregatesFilter<"QuestionScore"> | boolean
    marksObtained?: FloatWithAggregatesFilter<"QuestionScore"> | number
    maxMarks?: FloatWithAggregatesFilter<"QuestionScore"> | number
    accuracy?: FloatWithAggregatesFilter<"QuestionScore"> | number
    timeEfficiency?: FloatWithAggregatesFilter<"QuestionScore"> | number
    difficultyBonus?: FloatWithAggregatesFilter<"QuestionScore"> | number
    penalty?: FloatWithAggregatesFilter<"QuestionScore"> | number
    responseTime?: IntWithAggregatesFilter<"QuestionScore"> | number
    attemptsCount?: IntWithAggregatesFilter<"QuestionScore"> | number
    confidenceLevel?: FloatWithAggregatesFilter<"QuestionScore"> | number
    questionDifficulty?: StringWithAggregatesFilter<"QuestionScore"> | string
    scoredAt?: DateTimeWithAggregatesFilter<"QuestionScore"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"QuestionScore"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QuestionScore"> | Date | string
  }

  export type ExamScoreWhereInput = {
    AND?: ExamScoreWhereInput | ExamScoreWhereInput[]
    OR?: ExamScoreWhereInput[]
    NOT?: ExamScoreWhereInput | ExamScoreWhereInput[]
    id?: StringFilter<"ExamScore"> | string
    attemptId?: StringFilter<"ExamScore"> | string
    examId?: StringFilter<"ExamScore"> | string
    userId?: StringFilter<"ExamScore"> | string
    totalMarks?: FloatFilter<"ExamScore"> | number
    maxMarks?: FloatFilter<"ExamScore"> | number
    percentage?: FloatFilter<"ExamScore"> | number
    grade?: StringNullableFilter<"ExamScore"> | string | null
    correctAnswers?: IntFilter<"ExamScore"> | number
    wrongAnswers?: IntFilter<"ExamScore"> | number
    unanswered?: IntFilter<"ExamScore"> | number
    totalQuestions?: IntFilter<"ExamScore"> | number
    totalTimeSpent?: IntFilter<"ExamScore"> | number
    averageTimePerQuestion?: FloatFilter<"ExamScore"> | number
    timeEfficiency?: FloatFilter<"ExamScore"> | number
    easyCorrect?: IntFilter<"ExamScore"> | number
    easyTotal?: IntFilter<"ExamScore"> | number
    mediumCorrect?: IntFilter<"ExamScore"> | number
    mediumTotal?: IntFilter<"ExamScore"> | number
    hardCorrect?: IntFilter<"ExamScore"> | number
    hardTotal?: IntFilter<"ExamScore"> | number
    accuracy?: FloatFilter<"ExamScore"> | number
    speedScore?: FloatFilter<"ExamScore"> | number
    consistencyScore?: FloatFilter<"ExamScore"> | number
    difficultyScore?: FloatFilter<"ExamScore"> | number
    percentile?: FloatNullableFilter<"ExamScore"> | number | null
    rank?: IntNullableFilter<"ExamScore"> | number | null
    improvement?: FloatNullableFilter<"ExamScore"> | number | null
    calculatedAt?: DateTimeFilter<"ExamScore"> | Date | string
    createdAt?: DateTimeFilter<"ExamScore"> | Date | string
    updatedAt?: DateTimeFilter<"ExamScore"> | Date | string
    attempt?: XOR<ExamAttemptScalarRelationFilter, ExamAttemptWhereInput>
    exam?: XOR<ExamScalarRelationFilter, ExamWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ExamScoreOrderByWithRelationInput = {
    id?: SortOrder
    attemptId?: SortOrder
    examId?: SortOrder
    userId?: SortOrder
    totalMarks?: SortOrder
    maxMarks?: SortOrder
    percentage?: SortOrder
    grade?: SortOrderInput | SortOrder
    correctAnswers?: SortOrder
    wrongAnswers?: SortOrder
    unanswered?: SortOrder
    totalQuestions?: SortOrder
    totalTimeSpent?: SortOrder
    averageTimePerQuestion?: SortOrder
    timeEfficiency?: SortOrder
    easyCorrect?: SortOrder
    easyTotal?: SortOrder
    mediumCorrect?: SortOrder
    mediumTotal?: SortOrder
    hardCorrect?: SortOrder
    hardTotal?: SortOrder
    accuracy?: SortOrder
    speedScore?: SortOrder
    consistencyScore?: SortOrder
    difficultyScore?: SortOrder
    percentile?: SortOrderInput | SortOrder
    rank?: SortOrderInput | SortOrder
    improvement?: SortOrderInput | SortOrder
    calculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    attempt?: ExamAttemptOrderByWithRelationInput
    exam?: ExamOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ExamScoreWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    attemptId?: string
    AND?: ExamScoreWhereInput | ExamScoreWhereInput[]
    OR?: ExamScoreWhereInput[]
    NOT?: ExamScoreWhereInput | ExamScoreWhereInput[]
    examId?: StringFilter<"ExamScore"> | string
    userId?: StringFilter<"ExamScore"> | string
    totalMarks?: FloatFilter<"ExamScore"> | number
    maxMarks?: FloatFilter<"ExamScore"> | number
    percentage?: FloatFilter<"ExamScore"> | number
    grade?: StringNullableFilter<"ExamScore"> | string | null
    correctAnswers?: IntFilter<"ExamScore"> | number
    wrongAnswers?: IntFilter<"ExamScore"> | number
    unanswered?: IntFilter<"ExamScore"> | number
    totalQuestions?: IntFilter<"ExamScore"> | number
    totalTimeSpent?: IntFilter<"ExamScore"> | number
    averageTimePerQuestion?: FloatFilter<"ExamScore"> | number
    timeEfficiency?: FloatFilter<"ExamScore"> | number
    easyCorrect?: IntFilter<"ExamScore"> | number
    easyTotal?: IntFilter<"ExamScore"> | number
    mediumCorrect?: IntFilter<"ExamScore"> | number
    mediumTotal?: IntFilter<"ExamScore"> | number
    hardCorrect?: IntFilter<"ExamScore"> | number
    hardTotal?: IntFilter<"ExamScore"> | number
    accuracy?: FloatFilter<"ExamScore"> | number
    speedScore?: FloatFilter<"ExamScore"> | number
    consistencyScore?: FloatFilter<"ExamScore"> | number
    difficultyScore?: FloatFilter<"ExamScore"> | number
    percentile?: FloatNullableFilter<"ExamScore"> | number | null
    rank?: IntNullableFilter<"ExamScore"> | number | null
    improvement?: FloatNullableFilter<"ExamScore"> | number | null
    calculatedAt?: DateTimeFilter<"ExamScore"> | Date | string
    createdAt?: DateTimeFilter<"ExamScore"> | Date | string
    updatedAt?: DateTimeFilter<"ExamScore"> | Date | string
    attempt?: XOR<ExamAttemptScalarRelationFilter, ExamAttemptWhereInput>
    exam?: XOR<ExamScalarRelationFilter, ExamWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "attemptId">

  export type ExamScoreOrderByWithAggregationInput = {
    id?: SortOrder
    attemptId?: SortOrder
    examId?: SortOrder
    userId?: SortOrder
    totalMarks?: SortOrder
    maxMarks?: SortOrder
    percentage?: SortOrder
    grade?: SortOrderInput | SortOrder
    correctAnswers?: SortOrder
    wrongAnswers?: SortOrder
    unanswered?: SortOrder
    totalQuestions?: SortOrder
    totalTimeSpent?: SortOrder
    averageTimePerQuestion?: SortOrder
    timeEfficiency?: SortOrder
    easyCorrect?: SortOrder
    easyTotal?: SortOrder
    mediumCorrect?: SortOrder
    mediumTotal?: SortOrder
    hardCorrect?: SortOrder
    hardTotal?: SortOrder
    accuracy?: SortOrder
    speedScore?: SortOrder
    consistencyScore?: SortOrder
    difficultyScore?: SortOrder
    percentile?: SortOrderInput | SortOrder
    rank?: SortOrderInput | SortOrder
    improvement?: SortOrderInput | SortOrder
    calculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExamScoreCountOrderByAggregateInput
    _avg?: ExamScoreAvgOrderByAggregateInput
    _max?: ExamScoreMaxOrderByAggregateInput
    _min?: ExamScoreMinOrderByAggregateInput
    _sum?: ExamScoreSumOrderByAggregateInput
  }

  export type ExamScoreScalarWhereWithAggregatesInput = {
    AND?: ExamScoreScalarWhereWithAggregatesInput | ExamScoreScalarWhereWithAggregatesInput[]
    OR?: ExamScoreScalarWhereWithAggregatesInput[]
    NOT?: ExamScoreScalarWhereWithAggregatesInput | ExamScoreScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExamScore"> | string
    attemptId?: StringWithAggregatesFilter<"ExamScore"> | string
    examId?: StringWithAggregatesFilter<"ExamScore"> | string
    userId?: StringWithAggregatesFilter<"ExamScore"> | string
    totalMarks?: FloatWithAggregatesFilter<"ExamScore"> | number
    maxMarks?: FloatWithAggregatesFilter<"ExamScore"> | number
    percentage?: FloatWithAggregatesFilter<"ExamScore"> | number
    grade?: StringNullableWithAggregatesFilter<"ExamScore"> | string | null
    correctAnswers?: IntWithAggregatesFilter<"ExamScore"> | number
    wrongAnswers?: IntWithAggregatesFilter<"ExamScore"> | number
    unanswered?: IntWithAggregatesFilter<"ExamScore"> | number
    totalQuestions?: IntWithAggregatesFilter<"ExamScore"> | number
    totalTimeSpent?: IntWithAggregatesFilter<"ExamScore"> | number
    averageTimePerQuestion?: FloatWithAggregatesFilter<"ExamScore"> | number
    timeEfficiency?: FloatWithAggregatesFilter<"ExamScore"> | number
    easyCorrect?: IntWithAggregatesFilter<"ExamScore"> | number
    easyTotal?: IntWithAggregatesFilter<"ExamScore"> | number
    mediumCorrect?: IntWithAggregatesFilter<"ExamScore"> | number
    mediumTotal?: IntWithAggregatesFilter<"ExamScore"> | number
    hardCorrect?: IntWithAggregatesFilter<"ExamScore"> | number
    hardTotal?: IntWithAggregatesFilter<"ExamScore"> | number
    accuracy?: FloatWithAggregatesFilter<"ExamScore"> | number
    speedScore?: FloatWithAggregatesFilter<"ExamScore"> | number
    consistencyScore?: FloatWithAggregatesFilter<"ExamScore"> | number
    difficultyScore?: FloatWithAggregatesFilter<"ExamScore"> | number
    percentile?: FloatNullableWithAggregatesFilter<"ExamScore"> | number | null
    rank?: IntNullableWithAggregatesFilter<"ExamScore"> | number | null
    improvement?: FloatNullableWithAggregatesFilter<"ExamScore"> | number | null
    calculatedAt?: DateTimeWithAggregatesFilter<"ExamScore"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"ExamScore"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExamScore"> | Date | string
  }

  export type UserPerformanceWhereInput = {
    AND?: UserPerformanceWhereInput | UserPerformanceWhereInput[]
    OR?: UserPerformanceWhereInput[]
    NOT?: UserPerformanceWhereInput | UserPerformanceWhereInput[]
    id?: StringFilter<"UserPerformance"> | string
    userId?: StringFilter<"UserPerformance"> | string
    examCategoryId?: StringNullableFilter<"UserPerformance"> | string | null
    totalAttempts?: IntFilter<"UserPerformance"> | number
    totalPassed?: IntFilter<"UserPerformance"> | number
    totalFailed?: IntFilter<"UserPerformance"> | number
    passRate?: FloatFilter<"UserPerformance"> | number
    averageScore?: FloatFilter<"UserPerformance"> | number
    highestScore?: FloatFilter<"UserPerformance"> | number
    lowestScore?: FloatFilter<"UserPerformance"> | number
    totalMarks?: FloatFilter<"UserPerformance"> | number
    totalTimeSpent?: IntFilter<"UserPerformance"> | number
    averageTimePerExam?: FloatFilter<"UserPerformance"> | number
    easyAccuracy?: FloatFilter<"UserPerformance"> | number
    mediumAccuracy?: FloatFilter<"UserPerformance"> | number
    hardAccuracy?: FloatFilter<"UserPerformance"> | number
    improvementRate?: FloatFilter<"UserPerformance"> | number
    consistencyScore?: FloatFilter<"UserPerformance"> | number
    learningCurve?: FloatFilter<"UserPerformance"> | number
    lastAttemptAt?: DateTimeNullableFilter<"UserPerformance"> | Date | string | null
    createdAt?: DateTimeFilter<"UserPerformance"> | Date | string
    updatedAt?: DateTimeFilter<"UserPerformance"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    examCategory?: XOR<ExamCategoryNullableScalarRelationFilter, ExamCategoryWhereInput> | null
  }

  export type UserPerformanceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    examCategoryId?: SortOrderInput | SortOrder
    totalAttempts?: SortOrder
    totalPassed?: SortOrder
    totalFailed?: SortOrder
    passRate?: SortOrder
    averageScore?: SortOrder
    highestScore?: SortOrder
    lowestScore?: SortOrder
    totalMarks?: SortOrder
    totalTimeSpent?: SortOrder
    averageTimePerExam?: SortOrder
    easyAccuracy?: SortOrder
    mediumAccuracy?: SortOrder
    hardAccuracy?: SortOrder
    improvementRate?: SortOrder
    consistencyScore?: SortOrder
    learningCurve?: SortOrder
    lastAttemptAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    examCategory?: ExamCategoryOrderByWithRelationInput
  }

  export type UserPerformanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_examCategoryId?: UserPerformanceUserIdExamCategoryIdCompoundUniqueInput
    AND?: UserPerformanceWhereInput | UserPerformanceWhereInput[]
    OR?: UserPerformanceWhereInput[]
    NOT?: UserPerformanceWhereInput | UserPerformanceWhereInput[]
    userId?: StringFilter<"UserPerformance"> | string
    examCategoryId?: StringNullableFilter<"UserPerformance"> | string | null
    totalAttempts?: IntFilter<"UserPerformance"> | number
    totalPassed?: IntFilter<"UserPerformance"> | number
    totalFailed?: IntFilter<"UserPerformance"> | number
    passRate?: FloatFilter<"UserPerformance"> | number
    averageScore?: FloatFilter<"UserPerformance"> | number
    highestScore?: FloatFilter<"UserPerformance"> | number
    lowestScore?: FloatFilter<"UserPerformance"> | number
    totalMarks?: FloatFilter<"UserPerformance"> | number
    totalTimeSpent?: IntFilter<"UserPerformance"> | number
    averageTimePerExam?: FloatFilter<"UserPerformance"> | number
    easyAccuracy?: FloatFilter<"UserPerformance"> | number
    mediumAccuracy?: FloatFilter<"UserPerformance"> | number
    hardAccuracy?: FloatFilter<"UserPerformance"> | number
    improvementRate?: FloatFilter<"UserPerformance"> | number
    consistencyScore?: FloatFilter<"UserPerformance"> | number
    learningCurve?: FloatFilter<"UserPerformance"> | number
    lastAttemptAt?: DateTimeNullableFilter<"UserPerformance"> | Date | string | null
    createdAt?: DateTimeFilter<"UserPerformance"> | Date | string
    updatedAt?: DateTimeFilter<"UserPerformance"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    examCategory?: XOR<ExamCategoryNullableScalarRelationFilter, ExamCategoryWhereInput> | null
  }, "id" | "userId_examCategoryId">

  export type UserPerformanceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    examCategoryId?: SortOrderInput | SortOrder
    totalAttempts?: SortOrder
    totalPassed?: SortOrder
    totalFailed?: SortOrder
    passRate?: SortOrder
    averageScore?: SortOrder
    highestScore?: SortOrder
    lowestScore?: SortOrder
    totalMarks?: SortOrder
    totalTimeSpent?: SortOrder
    averageTimePerExam?: SortOrder
    easyAccuracy?: SortOrder
    mediumAccuracy?: SortOrder
    hardAccuracy?: SortOrder
    improvementRate?: SortOrder
    consistencyScore?: SortOrder
    learningCurve?: SortOrder
    lastAttemptAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserPerformanceCountOrderByAggregateInput
    _avg?: UserPerformanceAvgOrderByAggregateInput
    _max?: UserPerformanceMaxOrderByAggregateInput
    _min?: UserPerformanceMinOrderByAggregateInput
    _sum?: UserPerformanceSumOrderByAggregateInput
  }

  export type UserPerformanceScalarWhereWithAggregatesInput = {
    AND?: UserPerformanceScalarWhereWithAggregatesInput | UserPerformanceScalarWhereWithAggregatesInput[]
    OR?: UserPerformanceScalarWhereWithAggregatesInput[]
    NOT?: UserPerformanceScalarWhereWithAggregatesInput | UserPerformanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserPerformance"> | string
    userId?: StringWithAggregatesFilter<"UserPerformance"> | string
    examCategoryId?: StringNullableWithAggregatesFilter<"UserPerformance"> | string | null
    totalAttempts?: IntWithAggregatesFilter<"UserPerformance"> | number
    totalPassed?: IntWithAggregatesFilter<"UserPerformance"> | number
    totalFailed?: IntWithAggregatesFilter<"UserPerformance"> | number
    passRate?: FloatWithAggregatesFilter<"UserPerformance"> | number
    averageScore?: FloatWithAggregatesFilter<"UserPerformance"> | number
    highestScore?: FloatWithAggregatesFilter<"UserPerformance"> | number
    lowestScore?: FloatWithAggregatesFilter<"UserPerformance"> | number
    totalMarks?: FloatWithAggregatesFilter<"UserPerformance"> | number
    totalTimeSpent?: IntWithAggregatesFilter<"UserPerformance"> | number
    averageTimePerExam?: FloatWithAggregatesFilter<"UserPerformance"> | number
    easyAccuracy?: FloatWithAggregatesFilter<"UserPerformance"> | number
    mediumAccuracy?: FloatWithAggregatesFilter<"UserPerformance"> | number
    hardAccuracy?: FloatWithAggregatesFilter<"UserPerformance"> | number
    improvementRate?: FloatWithAggregatesFilter<"UserPerformance"> | number
    consistencyScore?: FloatWithAggregatesFilter<"UserPerformance"> | number
    learningCurve?: FloatWithAggregatesFilter<"UserPerformance"> | number
    lastAttemptAt?: DateTimeNullableWithAggregatesFilter<"UserPerformance"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserPerformance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserPerformance"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    bookingId?: StringNullableFilter<"Payment"> | string | null
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    stripePaymentId?: StringNullableFilter<"Payment"> | string | null
    stripeRefundId?: StringNullableFilter<"Payment"> | string | null
    description?: StringNullableFilter<"Payment"> | string | null
    metadata?: JsonNullableFilter<"Payment">
    refundedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    booking?: XOR<ExamBookingNullableScalarRelationFilter, ExamBookingWhereInput> | null
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    bookingId?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    stripePaymentId?: SortOrderInput | SortOrder
    stripeRefundId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    refundedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    booking?: ExamBookingOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    bookingId?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    userId?: StringFilter<"Payment"> | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    stripePaymentId?: StringNullableFilter<"Payment"> | string | null
    stripeRefundId?: StringNullableFilter<"Payment"> | string | null
    description?: StringNullableFilter<"Payment"> | string | null
    metadata?: JsonNullableFilter<"Payment">
    refundedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    booking?: XOR<ExamBookingNullableScalarRelationFilter, ExamBookingWhereInput> | null
  }, "id" | "bookingId">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    bookingId?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    stripePaymentId?: SortOrderInput | SortOrder
    stripeRefundId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    refundedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    userId?: StringWithAggregatesFilter<"Payment"> | string
    bookingId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Payment"> | string
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"Payment"> | $Enums.PaymentMethod
    stripePaymentId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    stripeRefundId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    description?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Payment">
    refundedAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type CertificateWhereInput = {
    AND?: CertificateWhereInput | CertificateWhereInput[]
    OR?: CertificateWhereInput[]
    NOT?: CertificateWhereInput | CertificateWhereInput[]
    id?: StringFilter<"Certificate"> | string
    userId?: StringFilter<"Certificate"> | string
    examId?: StringFilter<"Certificate"> | string
    attemptId?: StringFilter<"Certificate"> | string
    certificateNumber?: StringFilter<"Certificate"> | string
    issuedAt?: DateTimeFilter<"Certificate"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Certificate"> | Date | string | null
    isRevoked?: BoolFilter<"Certificate"> | boolean
    revokedAt?: DateTimeNullableFilter<"Certificate"> | Date | string | null
    revokedBy?: StringNullableFilter<"Certificate"> | string | null
    revokedReason?: StringNullableFilter<"Certificate"> | string | null
    pdfUrl?: StringNullableFilter<"Certificate"> | string | null
    createdAt?: DateTimeFilter<"Certificate"> | Date | string
    updatedAt?: DateTimeFilter<"Certificate"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    exam?: XOR<ExamScalarRelationFilter, ExamWhereInput>
    attempt?: XOR<ExamAttemptScalarRelationFilter, ExamAttemptWhereInput>
    revoker?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type CertificateOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    examId?: SortOrder
    attemptId?: SortOrder
    certificateNumber?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isRevoked?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    revokedBy?: SortOrderInput | SortOrder
    revokedReason?: SortOrderInput | SortOrder
    pdfUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    exam?: ExamOrderByWithRelationInput
    attempt?: ExamAttemptOrderByWithRelationInput
    revoker?: UserOrderByWithRelationInput
  }

  export type CertificateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    attemptId?: string
    certificateNumber?: string
    AND?: CertificateWhereInput | CertificateWhereInput[]
    OR?: CertificateWhereInput[]
    NOT?: CertificateWhereInput | CertificateWhereInput[]
    userId?: StringFilter<"Certificate"> | string
    examId?: StringFilter<"Certificate"> | string
    issuedAt?: DateTimeFilter<"Certificate"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Certificate"> | Date | string | null
    isRevoked?: BoolFilter<"Certificate"> | boolean
    revokedAt?: DateTimeNullableFilter<"Certificate"> | Date | string | null
    revokedBy?: StringNullableFilter<"Certificate"> | string | null
    revokedReason?: StringNullableFilter<"Certificate"> | string | null
    pdfUrl?: StringNullableFilter<"Certificate"> | string | null
    createdAt?: DateTimeFilter<"Certificate"> | Date | string
    updatedAt?: DateTimeFilter<"Certificate"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    exam?: XOR<ExamScalarRelationFilter, ExamWhereInput>
    attempt?: XOR<ExamAttemptScalarRelationFilter, ExamAttemptWhereInput>
    revoker?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "attemptId" | "certificateNumber">

  export type CertificateOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    examId?: SortOrder
    attemptId?: SortOrder
    certificateNumber?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isRevoked?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    revokedBy?: SortOrderInput | SortOrder
    revokedReason?: SortOrderInput | SortOrder
    pdfUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CertificateCountOrderByAggregateInput
    _max?: CertificateMaxOrderByAggregateInput
    _min?: CertificateMinOrderByAggregateInput
  }

  export type CertificateScalarWhereWithAggregatesInput = {
    AND?: CertificateScalarWhereWithAggregatesInput | CertificateScalarWhereWithAggregatesInput[]
    OR?: CertificateScalarWhereWithAggregatesInput[]
    NOT?: CertificateScalarWhereWithAggregatesInput | CertificateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Certificate"> | string
    userId?: StringWithAggregatesFilter<"Certificate"> | string
    examId?: StringWithAggregatesFilter<"Certificate"> | string
    attemptId?: StringWithAggregatesFilter<"Certificate"> | string
    certificateNumber?: StringWithAggregatesFilter<"Certificate"> | string
    issuedAt?: DateTimeWithAggregatesFilter<"Certificate"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Certificate"> | Date | string | null
    isRevoked?: BoolWithAggregatesFilter<"Certificate"> | boolean
    revokedAt?: DateTimeNullableWithAggregatesFilter<"Certificate"> | Date | string | null
    revokedBy?: StringNullableWithAggregatesFilter<"Certificate"> | string | null
    revokedReason?: StringNullableWithAggregatesFilter<"Certificate"> | string | null
    pdfUrl?: StringNullableWithAggregatesFilter<"Certificate"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Certificate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Certificate"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Notification">
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type StudyGroupWhereInput = {
    AND?: StudyGroupWhereInput | StudyGroupWhereInput[]
    OR?: StudyGroupWhereInput[]
    NOT?: StudyGroupWhereInput | StudyGroupWhereInput[]
    id?: StringFilter<"StudyGroup"> | string
    name?: StringFilter<"StudyGroup"> | string
    description?: StringNullableFilter<"StudyGroup"> | string | null
    isPrivate?: BoolFilter<"StudyGroup"> | boolean
    maxMembers?: IntFilter<"StudyGroup"> | number
    createdBy?: StringFilter<"StudyGroup"> | string
    isActive?: BoolFilter<"StudyGroup"> | boolean
    createdAt?: DateTimeFilter<"StudyGroup"> | Date | string
    updatedAt?: DateTimeFilter<"StudyGroup"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    members?: StudyGroupMemberListRelationFilter
  }

  export type StudyGroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isPrivate?: SortOrder
    maxMembers?: SortOrder
    createdBy?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: UserOrderByWithRelationInput
    members?: StudyGroupMemberOrderByRelationAggregateInput
  }

  export type StudyGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StudyGroupWhereInput | StudyGroupWhereInput[]
    OR?: StudyGroupWhereInput[]
    NOT?: StudyGroupWhereInput | StudyGroupWhereInput[]
    name?: StringFilter<"StudyGroup"> | string
    description?: StringNullableFilter<"StudyGroup"> | string | null
    isPrivate?: BoolFilter<"StudyGroup"> | boolean
    maxMembers?: IntFilter<"StudyGroup"> | number
    createdBy?: StringFilter<"StudyGroup"> | string
    isActive?: BoolFilter<"StudyGroup"> | boolean
    createdAt?: DateTimeFilter<"StudyGroup"> | Date | string
    updatedAt?: DateTimeFilter<"StudyGroup"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    members?: StudyGroupMemberListRelationFilter
  }, "id">

  export type StudyGroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isPrivate?: SortOrder
    maxMembers?: SortOrder
    createdBy?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudyGroupCountOrderByAggregateInput
    _avg?: StudyGroupAvgOrderByAggregateInput
    _max?: StudyGroupMaxOrderByAggregateInput
    _min?: StudyGroupMinOrderByAggregateInput
    _sum?: StudyGroupSumOrderByAggregateInput
  }

  export type StudyGroupScalarWhereWithAggregatesInput = {
    AND?: StudyGroupScalarWhereWithAggregatesInput | StudyGroupScalarWhereWithAggregatesInput[]
    OR?: StudyGroupScalarWhereWithAggregatesInput[]
    NOT?: StudyGroupScalarWhereWithAggregatesInput | StudyGroupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudyGroup"> | string
    name?: StringWithAggregatesFilter<"StudyGroup"> | string
    description?: StringNullableWithAggregatesFilter<"StudyGroup"> | string | null
    isPrivate?: BoolWithAggregatesFilter<"StudyGroup"> | boolean
    maxMembers?: IntWithAggregatesFilter<"StudyGroup"> | number
    createdBy?: StringWithAggregatesFilter<"StudyGroup"> | string
    isActive?: BoolWithAggregatesFilter<"StudyGroup"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"StudyGroup"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudyGroup"> | Date | string
  }

  export type StudyGroupMemberWhereInput = {
    AND?: StudyGroupMemberWhereInput | StudyGroupMemberWhereInput[]
    OR?: StudyGroupMemberWhereInput[]
    NOT?: StudyGroupMemberWhereInput | StudyGroupMemberWhereInput[]
    id?: StringFilter<"StudyGroupMember"> | string
    groupId?: StringFilter<"StudyGroupMember"> | string
    userId?: StringFilter<"StudyGroupMember"> | string
    role?: EnumGroupRoleFilter<"StudyGroupMember"> | $Enums.GroupRole
    joinedAt?: DateTimeFilter<"StudyGroupMember"> | Date | string
    isActive?: BoolFilter<"StudyGroupMember"> | boolean
    group?: XOR<StudyGroupScalarRelationFilter, StudyGroupWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type StudyGroupMemberOrderByWithRelationInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    isActive?: SortOrder
    group?: StudyGroupOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type StudyGroupMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    groupId_userId?: StudyGroupMemberGroupIdUserIdCompoundUniqueInput
    AND?: StudyGroupMemberWhereInput | StudyGroupMemberWhereInput[]
    OR?: StudyGroupMemberWhereInput[]
    NOT?: StudyGroupMemberWhereInput | StudyGroupMemberWhereInput[]
    groupId?: StringFilter<"StudyGroupMember"> | string
    userId?: StringFilter<"StudyGroupMember"> | string
    role?: EnumGroupRoleFilter<"StudyGroupMember"> | $Enums.GroupRole
    joinedAt?: DateTimeFilter<"StudyGroupMember"> | Date | string
    isActive?: BoolFilter<"StudyGroupMember"> | boolean
    group?: XOR<StudyGroupScalarRelationFilter, StudyGroupWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "groupId_userId">

  export type StudyGroupMemberOrderByWithAggregationInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    isActive?: SortOrder
    _count?: StudyGroupMemberCountOrderByAggregateInput
    _max?: StudyGroupMemberMaxOrderByAggregateInput
    _min?: StudyGroupMemberMinOrderByAggregateInput
  }

  export type StudyGroupMemberScalarWhereWithAggregatesInput = {
    AND?: StudyGroupMemberScalarWhereWithAggregatesInput | StudyGroupMemberScalarWhereWithAggregatesInput[]
    OR?: StudyGroupMemberScalarWhereWithAggregatesInput[]
    NOT?: StudyGroupMemberScalarWhereWithAggregatesInput | StudyGroupMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudyGroupMember"> | string
    groupId?: StringWithAggregatesFilter<"StudyGroupMember"> | string
    userId?: StringWithAggregatesFilter<"StudyGroupMember"> | string
    role?: EnumGroupRoleWithAggregatesFilter<"StudyGroupMember"> | $Enums.GroupRole
    joinedAt?: DateTimeWithAggregatesFilter<"StudyGroupMember"> | Date | string
    isActive?: BoolWithAggregatesFilter<"StudyGroupMember"> | boolean
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    resource?: StringWithAggregatesFilter<"AuditLog"> | string
    resourceId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    details?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type ExamCategoryUserWhereInput = {
    AND?: ExamCategoryUserWhereInput | ExamCategoryUserWhereInput[]
    OR?: ExamCategoryUserWhereInput[]
    NOT?: ExamCategoryUserWhereInput | ExamCategoryUserWhereInput[]
    id?: StringFilter<"ExamCategoryUser"> | string
    examCategoryId?: StringFilter<"ExamCategoryUser"> | string
    userId?: StringFilter<"ExamCategoryUser"> | string
    accessLevel?: EnumAccessLevelFilter<"ExamCategoryUser"> | $Enums.AccessLevel
    grantedAt?: DateTimeFilter<"ExamCategoryUser"> | Date | string
    grantedBy?: StringFilter<"ExamCategoryUser"> | string
    examCategory?: XOR<ExamCategoryScalarRelationFilter, ExamCategoryWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    granter?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ExamCategoryUserOrderByWithRelationInput = {
    id?: SortOrder
    examCategoryId?: SortOrder
    userId?: SortOrder
    accessLevel?: SortOrder
    grantedAt?: SortOrder
    grantedBy?: SortOrder
    examCategory?: ExamCategoryOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    granter?: UserOrderByWithRelationInput
  }

  export type ExamCategoryUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    examCategoryId_userId?: ExamCategoryUserExamCategoryIdUserIdCompoundUniqueInput
    AND?: ExamCategoryUserWhereInput | ExamCategoryUserWhereInput[]
    OR?: ExamCategoryUserWhereInput[]
    NOT?: ExamCategoryUserWhereInput | ExamCategoryUserWhereInput[]
    examCategoryId?: StringFilter<"ExamCategoryUser"> | string
    userId?: StringFilter<"ExamCategoryUser"> | string
    accessLevel?: EnumAccessLevelFilter<"ExamCategoryUser"> | $Enums.AccessLevel
    grantedAt?: DateTimeFilter<"ExamCategoryUser"> | Date | string
    grantedBy?: StringFilter<"ExamCategoryUser"> | string
    examCategory?: XOR<ExamCategoryScalarRelationFilter, ExamCategoryWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    granter?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "examCategoryId_userId">

  export type ExamCategoryUserOrderByWithAggregationInput = {
    id?: SortOrder
    examCategoryId?: SortOrder
    userId?: SortOrder
    accessLevel?: SortOrder
    grantedAt?: SortOrder
    grantedBy?: SortOrder
    _count?: ExamCategoryUserCountOrderByAggregateInput
    _max?: ExamCategoryUserMaxOrderByAggregateInput
    _min?: ExamCategoryUserMinOrderByAggregateInput
  }

  export type ExamCategoryUserScalarWhereWithAggregatesInput = {
    AND?: ExamCategoryUserScalarWhereWithAggregatesInput | ExamCategoryUserScalarWhereWithAggregatesInput[]
    OR?: ExamCategoryUserScalarWhereWithAggregatesInput[]
    NOT?: ExamCategoryUserScalarWhereWithAggregatesInput | ExamCategoryUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExamCategoryUser"> | string
    examCategoryId?: StringWithAggregatesFilter<"ExamCategoryUser"> | string
    userId?: StringWithAggregatesFilter<"ExamCategoryUser"> | string
    accessLevel?: EnumAccessLevelWithAggregatesFilter<"ExamCategoryUser"> | $Enums.AccessLevel
    grantedAt?: DateTimeWithAggregatesFilter<"ExamCategoryUser"> | Date | string
    grantedBy?: StringWithAggregatesFilter<"ExamCategoryUser"> | string
  }

  export type ExamStatisticsViewWhereInput = {
    AND?: ExamStatisticsViewWhereInput | ExamStatisticsViewWhereInput[]
    OR?: ExamStatisticsViewWhereInput[]
    NOT?: ExamStatisticsViewWhereInput | ExamStatisticsViewWhereInput[]
    examId?: StringFilter<"ExamStatisticsView"> | string
    examTitle?: StringFilter<"ExamStatisticsView"> | string
    totalAttempts?: IntFilter<"ExamStatisticsView"> | number
    totalBookings?: IntFilter<"ExamStatisticsView"> | number
    totalRevenue?: DecimalFilter<"ExamStatisticsView"> | Decimal | DecimalJsLike | number | string
    averageScore?: FloatFilter<"ExamStatisticsView"> | number
    passRate?: FloatFilter<"ExamStatisticsView"> | number
    averageTime?: IntFilter<"ExamStatisticsView"> | number
    lastAttemptDate?: DateTimeNullableFilter<"ExamStatisticsView"> | Date | string | null
  }

  export type ExamStatisticsViewOrderByWithRelationInput = {
    examId?: SortOrder
    examTitle?: SortOrder
    totalAttempts?: SortOrder
    totalBookings?: SortOrder
    totalRevenue?: SortOrder
    averageScore?: SortOrder
    passRate?: SortOrder
    averageTime?: SortOrder
    lastAttemptDate?: SortOrderInput | SortOrder
  }

  export type ExamStatisticsViewWhereUniqueInput = Prisma.AtLeast<{
    examId?: string
    AND?: ExamStatisticsViewWhereInput | ExamStatisticsViewWhereInput[]
    OR?: ExamStatisticsViewWhereInput[]
    NOT?: ExamStatisticsViewWhereInput | ExamStatisticsViewWhereInput[]
    examTitle?: StringFilter<"ExamStatisticsView"> | string
    totalAttempts?: IntFilter<"ExamStatisticsView"> | number
    totalBookings?: IntFilter<"ExamStatisticsView"> | number
    totalRevenue?: DecimalFilter<"ExamStatisticsView"> | Decimal | DecimalJsLike | number | string
    averageScore?: FloatFilter<"ExamStatisticsView"> | number
    passRate?: FloatFilter<"ExamStatisticsView"> | number
    averageTime?: IntFilter<"ExamStatisticsView"> | number
    lastAttemptDate?: DateTimeNullableFilter<"ExamStatisticsView"> | Date | string | null
  }, "examId">

  export type ExamStatisticsViewOrderByWithAggregationInput = {
    examId?: SortOrder
    examTitle?: SortOrder
    totalAttempts?: SortOrder
    totalBookings?: SortOrder
    totalRevenue?: SortOrder
    averageScore?: SortOrder
    passRate?: SortOrder
    averageTime?: SortOrder
    lastAttemptDate?: SortOrderInput | SortOrder
    _count?: ExamStatisticsViewCountOrderByAggregateInput
    _avg?: ExamStatisticsViewAvgOrderByAggregateInput
    _max?: ExamStatisticsViewMaxOrderByAggregateInput
    _min?: ExamStatisticsViewMinOrderByAggregateInput
    _sum?: ExamStatisticsViewSumOrderByAggregateInput
  }

  export type ExamStatisticsViewScalarWhereWithAggregatesInput = {
    AND?: ExamStatisticsViewScalarWhereWithAggregatesInput | ExamStatisticsViewScalarWhereWithAggregatesInput[]
    OR?: ExamStatisticsViewScalarWhereWithAggregatesInput[]
    NOT?: ExamStatisticsViewScalarWhereWithAggregatesInput | ExamStatisticsViewScalarWhereWithAggregatesInput[]
    examId?: StringWithAggregatesFilter<"ExamStatisticsView"> | string
    examTitle?: StringWithAggregatesFilter<"ExamStatisticsView"> | string
    totalAttempts?: IntWithAggregatesFilter<"ExamStatisticsView"> | number
    totalBookings?: IntWithAggregatesFilter<"ExamStatisticsView"> | number
    totalRevenue?: DecimalWithAggregatesFilter<"ExamStatisticsView"> | Decimal | DecimalJsLike | number | string
    averageScore?: FloatWithAggregatesFilter<"ExamStatisticsView"> | number
    passRate?: FloatWithAggregatesFilter<"ExamStatisticsView"> | number
    averageTime?: IntWithAggregatesFilter<"ExamStatisticsView"> | number
    lastAttemptDate?: DateTimeNullableWithAggregatesFilter<"ExamStatisticsView"> | Date | string | null
  }

  export type UserPerformanceViewWhereInput = {
    AND?: UserPerformanceViewWhereInput | UserPerformanceViewWhereInput[]
    OR?: UserPerformanceViewWhereInput[]
    NOT?: UserPerformanceViewWhereInput | UserPerformanceViewWhereInput[]
    userId?: StringFilter<"UserPerformanceView"> | string
    userEmail?: StringFilter<"UserPerformanceView"> | string
    totalExamsTaken?: IntFilter<"UserPerformanceView"> | number
    totalExamsPassed?: IntFilter<"UserPerformanceView"> | number
    averageScore?: FloatFilter<"UserPerformanceView"> | number
    totalTimeSpent?: IntFilter<"UserPerformanceView"> | number
    certificatesEarned?: IntFilter<"UserPerformanceView"> | number
    lastExamDate?: DateTimeNullableFilter<"UserPerformanceView"> | Date | string | null
  }

  export type UserPerformanceViewOrderByWithRelationInput = {
    userId?: SortOrder
    userEmail?: SortOrder
    totalExamsTaken?: SortOrder
    totalExamsPassed?: SortOrder
    averageScore?: SortOrder
    totalTimeSpent?: SortOrder
    certificatesEarned?: SortOrder
    lastExamDate?: SortOrderInput | SortOrder
  }

  export type UserPerformanceViewWhereUniqueInput = Prisma.AtLeast<{
    userId?: string
    AND?: UserPerformanceViewWhereInput | UserPerformanceViewWhereInput[]
    OR?: UserPerformanceViewWhereInput[]
    NOT?: UserPerformanceViewWhereInput | UserPerformanceViewWhereInput[]
    userEmail?: StringFilter<"UserPerformanceView"> | string
    totalExamsTaken?: IntFilter<"UserPerformanceView"> | number
    totalExamsPassed?: IntFilter<"UserPerformanceView"> | number
    averageScore?: FloatFilter<"UserPerformanceView"> | number
    totalTimeSpent?: IntFilter<"UserPerformanceView"> | number
    certificatesEarned?: IntFilter<"UserPerformanceView"> | number
    lastExamDate?: DateTimeNullableFilter<"UserPerformanceView"> | Date | string | null
  }, "userId">

  export type UserPerformanceViewOrderByWithAggregationInput = {
    userId?: SortOrder
    userEmail?: SortOrder
    totalExamsTaken?: SortOrder
    totalExamsPassed?: SortOrder
    averageScore?: SortOrder
    totalTimeSpent?: SortOrder
    certificatesEarned?: SortOrder
    lastExamDate?: SortOrderInput | SortOrder
    _count?: UserPerformanceViewCountOrderByAggregateInput
    _avg?: UserPerformanceViewAvgOrderByAggregateInput
    _max?: UserPerformanceViewMaxOrderByAggregateInput
    _min?: UserPerformanceViewMinOrderByAggregateInput
    _sum?: UserPerformanceViewSumOrderByAggregateInput
  }

  export type UserPerformanceViewScalarWhereWithAggregatesInput = {
    AND?: UserPerformanceViewScalarWhereWithAggregatesInput | UserPerformanceViewScalarWhereWithAggregatesInput[]
    OR?: UserPerformanceViewScalarWhereWithAggregatesInput[]
    NOT?: UserPerformanceViewScalarWhereWithAggregatesInput | UserPerformanceViewScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"UserPerformanceView"> | string
    userEmail?: StringWithAggregatesFilter<"UserPerformanceView"> | string
    totalExamsTaken?: IntWithAggregatesFilter<"UserPerformanceView"> | number
    totalExamsPassed?: IntWithAggregatesFilter<"UserPerformanceView"> | number
    averageScore?: FloatWithAggregatesFilter<"UserPerformanceView"> | number
    totalTimeSpent?: IntWithAggregatesFilter<"UserPerformanceView"> | number
    certificatesEarned?: IntWithAggregatesFilter<"UserPerformanceView"> | number
    lastExamDate?: DateTimeNullableWithAggregatesFilter<"UserPerformanceView"> | Date | string | null
  }

  export type QuestionAnalyticsViewWhereInput = {
    AND?: QuestionAnalyticsViewWhereInput | QuestionAnalyticsViewWhereInput[]
    OR?: QuestionAnalyticsViewWhereInput[]
    NOT?: QuestionAnalyticsViewWhereInput | QuestionAnalyticsViewWhereInput[]
    questionId?: StringFilter<"QuestionAnalyticsView"> | string
    questionText?: StringFilter<"QuestionAnalyticsView"> | string
    usageCount?: IntFilter<"QuestionAnalyticsView"> | number
    correctAnswerRate?: FloatFilter<"QuestionAnalyticsView"> | number
    averageTime?: IntFilter<"QuestionAnalyticsView"> | number
    difficulty?: EnumQuestionDifficultyFilter<"QuestionAnalyticsView"> | $Enums.QuestionDifficulty
    examCategoryName?: StringFilter<"QuestionAnalyticsView"> | string
  }

  export type QuestionAnalyticsViewOrderByWithRelationInput = {
    questionId?: SortOrder
    questionText?: SortOrder
    usageCount?: SortOrder
    correctAnswerRate?: SortOrder
    averageTime?: SortOrder
    difficulty?: SortOrder
    examCategoryName?: SortOrder
  }

  export type QuestionAnalyticsViewWhereUniqueInput = Prisma.AtLeast<{
    questionId?: string
    AND?: QuestionAnalyticsViewWhereInput | QuestionAnalyticsViewWhereInput[]
    OR?: QuestionAnalyticsViewWhereInput[]
    NOT?: QuestionAnalyticsViewWhereInput | QuestionAnalyticsViewWhereInput[]
    questionText?: StringFilter<"QuestionAnalyticsView"> | string
    usageCount?: IntFilter<"QuestionAnalyticsView"> | number
    correctAnswerRate?: FloatFilter<"QuestionAnalyticsView"> | number
    averageTime?: IntFilter<"QuestionAnalyticsView"> | number
    difficulty?: EnumQuestionDifficultyFilter<"QuestionAnalyticsView"> | $Enums.QuestionDifficulty
    examCategoryName?: StringFilter<"QuestionAnalyticsView"> | string
  }, "questionId">

  export type QuestionAnalyticsViewOrderByWithAggregationInput = {
    questionId?: SortOrder
    questionText?: SortOrder
    usageCount?: SortOrder
    correctAnswerRate?: SortOrder
    averageTime?: SortOrder
    difficulty?: SortOrder
    examCategoryName?: SortOrder
    _count?: QuestionAnalyticsViewCountOrderByAggregateInput
    _avg?: QuestionAnalyticsViewAvgOrderByAggregateInput
    _max?: QuestionAnalyticsViewMaxOrderByAggregateInput
    _min?: QuestionAnalyticsViewMinOrderByAggregateInput
    _sum?: QuestionAnalyticsViewSumOrderByAggregateInput
  }

  export type QuestionAnalyticsViewScalarWhereWithAggregatesInput = {
    AND?: QuestionAnalyticsViewScalarWhereWithAggregatesInput | QuestionAnalyticsViewScalarWhereWithAggregatesInput[]
    OR?: QuestionAnalyticsViewScalarWhereWithAggregatesInput[]
    NOT?: QuestionAnalyticsViewScalarWhereWithAggregatesInput | QuestionAnalyticsViewScalarWhereWithAggregatesInput[]
    questionId?: StringWithAggregatesFilter<"QuestionAnalyticsView"> | string
    questionText?: StringWithAggregatesFilter<"QuestionAnalyticsView"> | string
    usageCount?: IntWithAggregatesFilter<"QuestionAnalyticsView"> | number
    correctAnswerRate?: FloatWithAggregatesFilter<"QuestionAnalyticsView"> | number
    averageTime?: IntWithAggregatesFilter<"QuestionAnalyticsView"> | number
    difficulty?: EnumQuestionDifficultyWithAggregatesFilter<"QuestionAnalyticsView"> | $Enums.QuestionDifficulty
    examCategoryName?: StringWithAggregatesFilter<"QuestionAnalyticsView"> | string
  }

  export type RevenueAnalyticsViewWhereInput = {
    AND?: RevenueAnalyticsViewWhereInput | RevenueAnalyticsViewWhereInput[]
    OR?: RevenueAnalyticsViewWhereInput[]
    NOT?: RevenueAnalyticsViewWhereInput | RevenueAnalyticsViewWhereInput[]
    date?: DateTimeFilter<"RevenueAnalyticsView"> | Date | string
    totalRevenue?: DecimalFilter<"RevenueAnalyticsView"> | Decimal | DecimalJsLike | number | string
    totalTransactions?: IntFilter<"RevenueAnalyticsView"> | number
    averageTransactionValue?: DecimalFilter<"RevenueAnalyticsView"> | Decimal | DecimalJsLike | number | string
    topExamCategory?: StringFilter<"RevenueAnalyticsView"> | string
    topExam?: StringFilter<"RevenueAnalyticsView"> | string
  }

  export type RevenueAnalyticsViewOrderByWithRelationInput = {
    date?: SortOrder
    totalRevenue?: SortOrder
    totalTransactions?: SortOrder
    averageTransactionValue?: SortOrder
    topExamCategory?: SortOrder
    topExam?: SortOrder
  }

  export type RevenueAnalyticsViewWhereUniqueInput = Prisma.AtLeast<{
    date?: Date | string
    AND?: RevenueAnalyticsViewWhereInput | RevenueAnalyticsViewWhereInput[]
    OR?: RevenueAnalyticsViewWhereInput[]
    NOT?: RevenueAnalyticsViewWhereInput | RevenueAnalyticsViewWhereInput[]
    totalRevenue?: DecimalFilter<"RevenueAnalyticsView"> | Decimal | DecimalJsLike | number | string
    totalTransactions?: IntFilter<"RevenueAnalyticsView"> | number
    averageTransactionValue?: DecimalFilter<"RevenueAnalyticsView"> | Decimal | DecimalJsLike | number | string
    topExamCategory?: StringFilter<"RevenueAnalyticsView"> | string
    topExam?: StringFilter<"RevenueAnalyticsView"> | string
  }, "date">

  export type RevenueAnalyticsViewOrderByWithAggregationInput = {
    date?: SortOrder
    totalRevenue?: SortOrder
    totalTransactions?: SortOrder
    averageTransactionValue?: SortOrder
    topExamCategory?: SortOrder
    topExam?: SortOrder
    _count?: RevenueAnalyticsViewCountOrderByAggregateInput
    _avg?: RevenueAnalyticsViewAvgOrderByAggregateInput
    _max?: RevenueAnalyticsViewMaxOrderByAggregateInput
    _min?: RevenueAnalyticsViewMinOrderByAggregateInput
    _sum?: RevenueAnalyticsViewSumOrderByAggregateInput
  }

  export type RevenueAnalyticsViewScalarWhereWithAggregatesInput = {
    AND?: RevenueAnalyticsViewScalarWhereWithAggregatesInput | RevenueAnalyticsViewScalarWhereWithAggregatesInput[]
    OR?: RevenueAnalyticsViewScalarWhereWithAggregatesInput[]
    NOT?: RevenueAnalyticsViewScalarWhereWithAggregatesInput | RevenueAnalyticsViewScalarWhereWithAggregatesInput[]
    date?: DateTimeWithAggregatesFilter<"RevenueAnalyticsView"> | Date | string
    totalRevenue?: DecimalWithAggregatesFilter<"RevenueAnalyticsView"> | Decimal | DecimalJsLike | number | string
    totalTransactions?: IntWithAggregatesFilter<"RevenueAnalyticsView"> | number
    averageTransactionValue?: DecimalWithAggregatesFilter<"RevenueAnalyticsView"> | Decimal | DecimalJsLike | number | string
    topExamCategory?: StringWithAggregatesFilter<"RevenueAnalyticsView"> | string
    topExam?: StringWithAggregatesFilter<"RevenueAnalyticsView"> | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examBookings?: ExamBookingCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    examAttempts?: ExamAttemptCreateNestedManyWithoutUserInput
    questionResponses?: QuestionResponseCreateNestedManyWithoutUserInput
    questionScores?: QuestionScoreCreateNestedManyWithoutUserInput
    examScores?: ExamScoreCreateNestedManyWithoutUserInput
    userPerformances?: UserPerformanceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    examCategories?: ExamCategoryUserCreateNestedManyWithoutUserInput
    studyGroups?: StudyGroupMemberCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    grantedExamCategories?: ExamCategoryUserCreateNestedManyWithoutGranterInput
    createdStudyGroups?: StudyGroupCreateNestedManyWithoutCreatorInput
    createdQuestions?: QuestionCreateNestedManyWithoutCreatorInput
    approvedQuestions?: QuestionCreateNestedManyWithoutApproverInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    approvedExams?: ExamCreateNestedManyWithoutApproverInput
    revokedCertificates?: CertificateCreateNestedManyWithoutRevokerInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examBookings?: ExamBookingUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    examAttempts?: ExamAttemptUncheckedCreateNestedManyWithoutUserInput
    questionResponses?: QuestionResponseUncheckedCreateNestedManyWithoutUserInput
    questionScores?: QuestionScoreUncheckedCreateNestedManyWithoutUserInput
    examScores?: ExamScoreUncheckedCreateNestedManyWithoutUserInput
    userPerformances?: UserPerformanceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    examCategories?: ExamCategoryUserUncheckedCreateNestedManyWithoutUserInput
    studyGroups?: StudyGroupMemberUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    grantedExamCategories?: ExamCategoryUserUncheckedCreateNestedManyWithoutGranterInput
    createdStudyGroups?: StudyGroupUncheckedCreateNestedManyWithoutCreatorInput
    createdQuestions?: QuestionUncheckedCreateNestedManyWithoutCreatorInput
    approvedQuestions?: QuestionUncheckedCreateNestedManyWithoutApproverInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    approvedExams?: ExamUncheckedCreateNestedManyWithoutApproverInput
    revokedCertificates?: CertificateUncheckedCreateNestedManyWithoutRevokerInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examBookings?: ExamBookingUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    examAttempts?: ExamAttemptUpdateManyWithoutUserNestedInput
    questionResponses?: QuestionResponseUpdateManyWithoutUserNestedInput
    questionScores?: QuestionScoreUpdateManyWithoutUserNestedInput
    examScores?: ExamScoreUpdateManyWithoutUserNestedInput
    userPerformances?: UserPerformanceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    examCategories?: ExamCategoryUserUpdateManyWithoutUserNestedInput
    studyGroups?: StudyGroupMemberUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    grantedExamCategories?: ExamCategoryUserUpdateManyWithoutGranterNestedInput
    createdStudyGroups?: StudyGroupUpdateManyWithoutCreatorNestedInput
    createdQuestions?: QuestionUpdateManyWithoutCreatorNestedInput
    approvedQuestions?: QuestionUpdateManyWithoutApproverNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    approvedExams?: ExamUpdateManyWithoutApproverNestedInput
    revokedCertificates?: CertificateUpdateManyWithoutRevokerNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examBookings?: ExamBookingUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    examAttempts?: ExamAttemptUncheckedUpdateManyWithoutUserNestedInput
    questionResponses?: QuestionResponseUncheckedUpdateManyWithoutUserNestedInput
    questionScores?: QuestionScoreUncheckedUpdateManyWithoutUserNestedInput
    examScores?: ExamScoreUncheckedUpdateManyWithoutUserNestedInput
    userPerformances?: UserPerformanceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    examCategories?: ExamCategoryUserUncheckedUpdateManyWithoutUserNestedInput
    studyGroups?: StudyGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    grantedExamCategories?: ExamCategoryUserUncheckedUpdateManyWithoutGranterNestedInput
    createdStudyGroups?: StudyGroupUncheckedUpdateManyWithoutCreatorNestedInput
    createdQuestions?: QuestionUncheckedUpdateManyWithoutCreatorNestedInput
    approvedQuestions?: QuestionUncheckedUpdateManyWithoutApproverNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    approvedExams?: ExamUncheckedUpdateManyWithoutApproverNestedInput
    revokedCertificates?: CertificateUncheckedUpdateManyWithoutRevokerNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionCreateInput = {
    id?: string
    sessionToken: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    isActive?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutUserSessionsInput
  }

  export type UserSessionUncheckedCreateInput = {
    id?: string
    userId: string
    sessionToken: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type UserSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserSessionsNestedInput
  }

  export type UserSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionCreateManyInput = {
    id?: string
    userId: string
    sessionToken: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type UserSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamCategoryCreateInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    exams?: ExamCreateNestedManyWithoutExamCategoryInput
    questions?: QuestionCreateNestedManyWithoutExamCategoryInput
    users?: ExamCategoryUserCreateNestedManyWithoutExamCategoryInput
    userPerformances?: UserPerformanceCreateNestedManyWithoutExamCategoryInput
  }

  export type ExamCategoryUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    exams?: ExamUncheckedCreateNestedManyWithoutExamCategoryInput
    questions?: QuestionUncheckedCreateNestedManyWithoutExamCategoryInput
    users?: ExamCategoryUserUncheckedCreateNestedManyWithoutExamCategoryInput
    userPerformances?: UserPerformanceUncheckedCreateNestedManyWithoutExamCategoryInput
  }

  export type ExamCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exams?: ExamUpdateManyWithoutExamCategoryNestedInput
    questions?: QuestionUpdateManyWithoutExamCategoryNestedInput
    users?: ExamCategoryUserUpdateManyWithoutExamCategoryNestedInput
    userPerformances?: UserPerformanceUpdateManyWithoutExamCategoryNestedInput
  }

  export type ExamCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exams?: ExamUncheckedUpdateManyWithoutExamCategoryNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutExamCategoryNestedInput
    users?: ExamCategoryUserUncheckedUpdateManyWithoutExamCategoryNestedInput
    userPerformances?: UserPerformanceUncheckedUpdateManyWithoutExamCategoryNestedInput
  }

  export type ExamCategoryCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionCreateInput = {
    id?: string
    text: string
    type: $Enums.QuestionType
    difficulty: $Enums.QuestionDifficulty
    marks?: number
    timeLimit?: number | null
    isActive?: boolean
    isPublic?: boolean
    approvedAt?: Date | string | null
    usageCount?: number
    correctAnswerRate?: number | null
    averageTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examCategory: ExamCategoryCreateNestedOneWithoutQuestionsInput
    creator: UserCreateNestedOneWithoutCreatedQuestionsInput
    approver?: UserCreateNestedOneWithoutApprovedQuestionsInput
    options?: QuestionOptionCreateNestedManyWithoutQuestionInput
    images?: QuestionImageCreateNestedManyWithoutQuestionInput
    tags?: QuestionTagCreateNestedManyWithoutQuestionInput
    examQuestions?: ExamQuestionCreateNestedManyWithoutQuestionInput
    responses?: QuestionResponseCreateNestedManyWithoutQuestionInput
    scores?: QuestionScoreCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateInput = {
    id?: string
    text: string
    type: $Enums.QuestionType
    difficulty: $Enums.QuestionDifficulty
    examCategoryId: string
    marks?: number
    timeLimit?: number | null
    isActive?: boolean
    isPublic?: boolean
    createdBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    usageCount?: number
    correctAnswerRate?: number | null
    averageTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: QuestionOptionUncheckedCreateNestedManyWithoutQuestionInput
    images?: QuestionImageUncheckedCreateNestedManyWithoutQuestionInput
    tags?: QuestionTagUncheckedCreateNestedManyWithoutQuestionInput
    examQuestions?: ExamQuestionUncheckedCreateNestedManyWithoutQuestionInput
    responses?: QuestionResponseUncheckedCreateNestedManyWithoutQuestionInput
    scores?: QuestionScoreUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    difficulty?: EnumQuestionDifficultyFieldUpdateOperationsInput | $Enums.QuestionDifficulty
    marks?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    correctAnswerRate?: NullableFloatFieldUpdateOperationsInput | number | null
    averageTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examCategory?: ExamCategoryUpdateOneRequiredWithoutQuestionsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedQuestionsNestedInput
    approver?: UserUpdateOneWithoutApprovedQuestionsNestedInput
    options?: QuestionOptionUpdateManyWithoutQuestionNestedInput
    images?: QuestionImageUpdateManyWithoutQuestionNestedInput
    tags?: QuestionTagUpdateManyWithoutQuestionNestedInput
    examQuestions?: ExamQuestionUpdateManyWithoutQuestionNestedInput
    responses?: QuestionResponseUpdateManyWithoutQuestionNestedInput
    scores?: QuestionScoreUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    difficulty?: EnumQuestionDifficultyFieldUpdateOperationsInput | $Enums.QuestionDifficulty
    examCategoryId?: StringFieldUpdateOperationsInput | string
    marks?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    correctAnswerRate?: NullableFloatFieldUpdateOperationsInput | number | null
    averageTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: QuestionOptionUncheckedUpdateManyWithoutQuestionNestedInput
    images?: QuestionImageUncheckedUpdateManyWithoutQuestionNestedInput
    tags?: QuestionTagUncheckedUpdateManyWithoutQuestionNestedInput
    examQuestions?: ExamQuestionUncheckedUpdateManyWithoutQuestionNestedInput
    responses?: QuestionResponseUncheckedUpdateManyWithoutQuestionNestedInput
    scores?: QuestionScoreUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionCreateManyInput = {
    id?: string
    text: string
    type: $Enums.QuestionType
    difficulty: $Enums.QuestionDifficulty
    examCategoryId: string
    marks?: number
    timeLimit?: number | null
    isActive?: boolean
    isPublic?: boolean
    createdBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    usageCount?: number
    correctAnswerRate?: number | null
    averageTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    difficulty?: EnumQuestionDifficultyFieldUpdateOperationsInput | $Enums.QuestionDifficulty
    marks?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    correctAnswerRate?: NullableFloatFieldUpdateOperationsInput | number | null
    averageTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    difficulty?: EnumQuestionDifficultyFieldUpdateOperationsInput | $Enums.QuestionDifficulty
    examCategoryId?: StringFieldUpdateOperationsInput | string
    marks?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    correctAnswerRate?: NullableFloatFieldUpdateOperationsInput | number | null
    averageTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionOptionCreateInput = {
    id?: string
    text: string
    isCorrect?: boolean
    sortOrder?: number
    createdAt?: Date | string
    question: QuestionCreateNestedOneWithoutOptionsInput
  }

  export type QuestionOptionUncheckedCreateInput = {
    id?: string
    questionId: string
    text: string
    isCorrect?: boolean
    sortOrder?: number
    createdAt?: Date | string
  }

  export type QuestionOptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: QuestionUpdateOneRequiredWithoutOptionsNestedInput
  }

  export type QuestionOptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionOptionCreateManyInput = {
    id?: string
    questionId: string
    text: string
    isCorrect?: boolean
    sortOrder?: number
    createdAt?: Date | string
  }

  export type QuestionOptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionOptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionImageCreateInput = {
    id?: string
    imageUrl: string
    altText?: string | null
    sortOrder?: number
    createdAt?: Date | string
    question: QuestionCreateNestedOneWithoutImagesInput
  }

  export type QuestionImageUncheckedCreateInput = {
    id?: string
    questionId: string
    imageUrl: string
    altText?: string | null
    sortOrder?: number
    createdAt?: Date | string
  }

  export type QuestionImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: QuestionUpdateOneRequiredWithoutImagesNestedInput
  }

  export type QuestionImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionImageCreateManyInput = {
    id?: string
    questionId: string
    imageUrl: string
    altText?: string | null
    sortOrder?: number
    createdAt?: Date | string
  }

  export type QuestionImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionTagCreateInput = {
    id?: string
    tag: string
    createdAt?: Date | string
    question: QuestionCreateNestedOneWithoutTagsInput
  }

  export type QuestionTagUncheckedCreateInput = {
    id?: string
    questionId: string
    tag: string
    createdAt?: Date | string
  }

  export type QuestionTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: QuestionUpdateOneRequiredWithoutTagsNestedInput
  }

  export type QuestionTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionTagCreateManyInput = {
    id?: string
    questionId: string
    tag: string
    createdAt?: Date | string
  }

  export type QuestionTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamCreateInput = {
    id?: string
    title: string
    description?: string | null
    duration: number
    totalMarks: number
    passingMarks: number
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    isActive?: boolean
    isPublic?: boolean
    allowRetakes?: boolean
    maxRetakes?: number
    showResults?: boolean
    showAnswers?: boolean
    randomizeQuestions?: boolean
    randomizeOptions?: boolean
    questionOverlapPercentage?: number
    approvedAt?: Date | string | null
    scheduledStart?: Date | string | null
    scheduledEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examCategory: ExamCategoryCreateNestedOneWithoutExamsInput
    creator: UserCreateNestedOneWithoutCreatedExamsInput
    approver?: UserCreateNestedOneWithoutApprovedExamsInput
    questions?: ExamQuestionCreateNestedManyWithoutExamInput
    bookings?: ExamBookingCreateNestedManyWithoutExamInput
    attempts?: ExamAttemptCreateNestedManyWithoutExamInput
    examScores?: ExamScoreCreateNestedManyWithoutExamInput
    certificates?: CertificateCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    examCategoryId: string
    duration: number
    totalMarks: number
    passingMarks: number
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    isActive?: boolean
    isPublic?: boolean
    allowRetakes?: boolean
    maxRetakes?: number
    showResults?: boolean
    showAnswers?: boolean
    randomizeQuestions?: boolean
    randomizeOptions?: boolean
    questionOverlapPercentage?: number
    createdBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    scheduledStart?: Date | string | null
    scheduledEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: ExamQuestionUncheckedCreateNestedManyWithoutExamInput
    bookings?: ExamBookingUncheckedCreateNestedManyWithoutExamInput
    attempts?: ExamAttemptUncheckedCreateNestedManyWithoutExamInput
    examScores?: ExamScoreUncheckedCreateNestedManyWithoutExamInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    totalMarks?: IntFieldUpdateOperationsInput | number
    passingMarks?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowRetakes?: BoolFieldUpdateOperationsInput | boolean
    maxRetakes?: IntFieldUpdateOperationsInput | number
    showResults?: BoolFieldUpdateOperationsInput | boolean
    showAnswers?: BoolFieldUpdateOperationsInput | boolean
    randomizeQuestions?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: BoolFieldUpdateOperationsInput | boolean
    questionOverlapPercentage?: FloatFieldUpdateOperationsInput | number
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examCategory?: ExamCategoryUpdateOneRequiredWithoutExamsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedExamsNestedInput
    approver?: UserUpdateOneWithoutApprovedExamsNestedInput
    questions?: ExamQuestionUpdateManyWithoutExamNestedInput
    bookings?: ExamBookingUpdateManyWithoutExamNestedInput
    attempts?: ExamAttemptUpdateManyWithoutExamNestedInput
    examScores?: ExamScoreUpdateManyWithoutExamNestedInput
    certificates?: CertificateUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    examCategoryId?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    totalMarks?: IntFieldUpdateOperationsInput | number
    passingMarks?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowRetakes?: BoolFieldUpdateOperationsInput | boolean
    maxRetakes?: IntFieldUpdateOperationsInput | number
    showResults?: BoolFieldUpdateOperationsInput | boolean
    showAnswers?: BoolFieldUpdateOperationsInput | boolean
    randomizeQuestions?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: BoolFieldUpdateOperationsInput | boolean
    questionOverlapPercentage?: FloatFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: ExamQuestionUncheckedUpdateManyWithoutExamNestedInput
    bookings?: ExamBookingUncheckedUpdateManyWithoutExamNestedInput
    attempts?: ExamAttemptUncheckedUpdateManyWithoutExamNestedInput
    examScores?: ExamScoreUncheckedUpdateManyWithoutExamNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutExamNestedInput
  }

  export type ExamCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    examCategoryId: string
    duration: number
    totalMarks: number
    passingMarks: number
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    isActive?: boolean
    isPublic?: boolean
    allowRetakes?: boolean
    maxRetakes?: number
    showResults?: boolean
    showAnswers?: boolean
    randomizeQuestions?: boolean
    randomizeOptions?: boolean
    questionOverlapPercentage?: number
    createdBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    scheduledStart?: Date | string | null
    scheduledEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    totalMarks?: IntFieldUpdateOperationsInput | number
    passingMarks?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowRetakes?: BoolFieldUpdateOperationsInput | boolean
    maxRetakes?: IntFieldUpdateOperationsInput | number
    showResults?: BoolFieldUpdateOperationsInput | boolean
    showAnswers?: BoolFieldUpdateOperationsInput | boolean
    randomizeQuestions?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: BoolFieldUpdateOperationsInput | boolean
    questionOverlapPercentage?: FloatFieldUpdateOperationsInput | number
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    examCategoryId?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    totalMarks?: IntFieldUpdateOperationsInput | number
    passingMarks?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowRetakes?: BoolFieldUpdateOperationsInput | boolean
    maxRetakes?: IntFieldUpdateOperationsInput | number
    showResults?: BoolFieldUpdateOperationsInput | boolean
    showAnswers?: BoolFieldUpdateOperationsInput | boolean
    randomizeQuestions?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: BoolFieldUpdateOperationsInput | boolean
    questionOverlapPercentage?: FloatFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamQuestionCreateInput = {
    id?: string
    order: number
    marks?: number
    createdAt?: Date | string
    exam: ExamCreateNestedOneWithoutQuestionsInput
    question: QuestionCreateNestedOneWithoutExamQuestionsInput
  }

  export type ExamQuestionUncheckedCreateInput = {
    id?: string
    examId: string
    questionId: string
    order: number
    marks?: number
    createdAt?: Date | string
  }

  export type ExamQuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    marks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exam?: ExamUpdateOneRequiredWithoutQuestionsNestedInput
    question?: QuestionUpdateOneRequiredWithoutExamQuestionsNestedInput
  }

  export type ExamQuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    marks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamQuestionCreateManyInput = {
    id?: string
    examId: string
    questionId: string
    order: number
    marks?: number
    createdAt?: Date | string
  }

  export type ExamQuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    marks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamQuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    marks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamBookingCreateInput = {
    id?: string
    bookingDate?: Date | string
    scheduledAt?: Date | string | null
    status?: $Enums.BookingStatus
    paymentId?: string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutExamBookingsInput
    exam: ExamCreateNestedOneWithoutBookingsInput
    payment?: PaymentCreateNestedOneWithoutBookingInput
    attempts?: ExamAttemptCreateNestedManyWithoutBookingInput
  }

  export type ExamBookingUncheckedCreateInput = {
    id?: string
    userId: string
    examId: string
    bookingDate?: Date | string
    scheduledAt?: Date | string | null
    status?: $Enums.BookingStatus
    paymentId?: string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payment?: PaymentUncheckedCreateNestedOneWithoutBookingInput
    attempts?: ExamAttemptUncheckedCreateNestedManyWithoutBookingInput
  }

  export type ExamBookingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExamBookingsNestedInput
    exam?: ExamUpdateOneRequiredWithoutBookingsNestedInput
    payment?: PaymentUpdateOneWithoutBookingNestedInput
    attempts?: ExamAttemptUpdateManyWithoutBookingNestedInput
  }

  export type ExamBookingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUncheckedUpdateOneWithoutBookingNestedInput
    attempts?: ExamAttemptUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type ExamBookingCreateManyInput = {
    id?: string
    userId: string
    examId: string
    bookingDate?: Date | string
    scheduledAt?: Date | string | null
    status?: $Enums.BookingStatus
    paymentId?: string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamBookingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamBookingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamAttemptCreateInput = {
    id?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.AttemptStatus
    totalMarks?: number
    obtainedMarks?: number
    percentage?: number
    isPassed?: boolean
    timeSpent?: number | null
    ipAddress?: string | null
    userAgent?: string | null
    isCheating?: boolean
    cheatingReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutExamAttemptsInput
    exam: ExamCreateNestedOneWithoutAttemptsInput
    booking?: ExamBookingCreateNestedOneWithoutAttemptsInput
    responses?: QuestionResponseCreateNestedManyWithoutAttemptInput
    questionScores?: QuestionScoreCreateNestedManyWithoutAttemptInput
    examScore?: ExamScoreCreateNestedOneWithoutAttemptInput
    certificate?: CertificateCreateNestedOneWithoutAttemptInput
  }

  export type ExamAttemptUncheckedCreateInput = {
    id?: string
    userId: string
    examId: string
    bookingId?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.AttemptStatus
    totalMarks?: number
    obtainedMarks?: number
    percentage?: number
    isPassed?: boolean
    timeSpent?: number | null
    ipAddress?: string | null
    userAgent?: string | null
    isCheating?: boolean
    cheatingReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: QuestionResponseUncheckedCreateNestedManyWithoutAttemptInput
    questionScores?: QuestionScoreUncheckedCreateNestedManyWithoutAttemptInput
    examScore?: ExamScoreUncheckedCreateNestedOneWithoutAttemptInput
    certificate?: CertificateUncheckedCreateNestedOneWithoutAttemptInput
  }

  export type ExamAttemptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttemptStatusFieldUpdateOperationsInput | $Enums.AttemptStatus
    totalMarks?: IntFieldUpdateOperationsInput | number
    obtainedMarks?: IntFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isCheating?: BoolFieldUpdateOperationsInput | boolean
    cheatingReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExamAttemptsNestedInput
    exam?: ExamUpdateOneRequiredWithoutAttemptsNestedInput
    booking?: ExamBookingUpdateOneWithoutAttemptsNestedInput
    responses?: QuestionResponseUpdateManyWithoutAttemptNestedInput
    questionScores?: QuestionScoreUpdateManyWithoutAttemptNestedInput
    examScore?: ExamScoreUpdateOneWithoutAttemptNestedInput
    certificate?: CertificateUpdateOneWithoutAttemptNestedInput
  }

  export type ExamAttemptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttemptStatusFieldUpdateOperationsInput | $Enums.AttemptStatus
    totalMarks?: IntFieldUpdateOperationsInput | number
    obtainedMarks?: IntFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isCheating?: BoolFieldUpdateOperationsInput | boolean
    cheatingReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: QuestionResponseUncheckedUpdateManyWithoutAttemptNestedInput
    questionScores?: QuestionScoreUncheckedUpdateManyWithoutAttemptNestedInput
    examScore?: ExamScoreUncheckedUpdateOneWithoutAttemptNestedInput
    certificate?: CertificateUncheckedUpdateOneWithoutAttemptNestedInput
  }

  export type ExamAttemptCreateManyInput = {
    id?: string
    userId: string
    examId: string
    bookingId?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.AttemptStatus
    totalMarks?: number
    obtainedMarks?: number
    percentage?: number
    isPassed?: boolean
    timeSpent?: number | null
    ipAddress?: string | null
    userAgent?: string | null
    isCheating?: boolean
    cheatingReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamAttemptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttemptStatusFieldUpdateOperationsInput | $Enums.AttemptStatus
    totalMarks?: IntFieldUpdateOperationsInput | number
    obtainedMarks?: IntFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isCheating?: BoolFieldUpdateOperationsInput | boolean
    cheatingReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamAttemptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttemptStatusFieldUpdateOperationsInput | $Enums.AttemptStatus
    totalMarks?: IntFieldUpdateOperationsInput | number
    obtainedMarks?: IntFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isCheating?: BoolFieldUpdateOperationsInput | boolean
    cheatingReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionResponseCreateInput = {
    id?: string
    selectedOptions?: QuestionResponseCreateselectedOptionsInput | string[]
    isCorrect?: boolean | null
    marksObtained?: number
    timeSpent?: number | null
    answeredAt?: Date | string
    submittedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    attempt: ExamAttemptCreateNestedOneWithoutResponsesInput
    question: QuestionCreateNestedOneWithoutResponsesInput
    user: UserCreateNestedOneWithoutQuestionResponsesInput
    score?: QuestionScoreCreateNestedOneWithoutResponseInput
  }

  export type QuestionResponseUncheckedCreateInput = {
    id?: string
    attemptId: string
    questionId: string
    userId: string
    selectedOptions?: QuestionResponseCreateselectedOptionsInput | string[]
    isCorrect?: boolean | null
    marksObtained?: number
    timeSpent?: number | null
    answeredAt?: Date | string
    submittedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    score?: QuestionScoreUncheckedCreateNestedOneWithoutResponseInput
  }

  export type QuestionResponseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    selectedOptions?: QuestionResponseUpdateselectedOptionsInput | string[]
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marksObtained?: IntFieldUpdateOperationsInput | number
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    answeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempt?: ExamAttemptUpdateOneRequiredWithoutResponsesNestedInput
    question?: QuestionUpdateOneRequiredWithoutResponsesNestedInput
    user?: UserUpdateOneRequiredWithoutQuestionResponsesNestedInput
    score?: QuestionScoreUpdateOneWithoutResponseNestedInput
  }

  export type QuestionResponseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    attemptId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    selectedOptions?: QuestionResponseUpdateselectedOptionsInput | string[]
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marksObtained?: IntFieldUpdateOperationsInput | number
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    answeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: QuestionScoreUncheckedUpdateOneWithoutResponseNestedInput
  }

  export type QuestionResponseCreateManyInput = {
    id?: string
    attemptId: string
    questionId: string
    userId: string
    selectedOptions?: QuestionResponseCreateselectedOptionsInput | string[]
    isCorrect?: boolean | null
    marksObtained?: number
    timeSpent?: number | null
    answeredAt?: Date | string
    submittedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionResponseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    selectedOptions?: QuestionResponseUpdateselectedOptionsInput | string[]
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marksObtained?: IntFieldUpdateOperationsInput | number
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    answeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionResponseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    attemptId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    selectedOptions?: QuestionResponseUpdateselectedOptionsInput | string[]
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marksObtained?: IntFieldUpdateOperationsInput | number
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    answeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionScoreCreateInput = {
    id?: string
    isCorrect?: boolean
    marksObtained?: number
    maxMarks?: number
    accuracy?: number
    timeEfficiency?: number
    difficultyBonus?: number
    penalty?: number
    responseTime?: number
    attemptsCount?: number
    confidenceLevel?: number
    questionDifficulty: string
    scoredAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    response: QuestionResponseCreateNestedOneWithoutScoreInput
    question: QuestionCreateNestedOneWithoutScoresInput
    attempt: ExamAttemptCreateNestedOneWithoutQuestionScoresInput
    user: UserCreateNestedOneWithoutQuestionScoresInput
  }

  export type QuestionScoreUncheckedCreateInput = {
    id?: string
    responseId: string
    questionId: string
    attemptId: string
    userId: string
    isCorrect?: boolean
    marksObtained?: number
    maxMarks?: number
    accuracy?: number
    timeEfficiency?: number
    difficultyBonus?: number
    penalty?: number
    responseTime?: number
    attemptsCount?: number
    confidenceLevel?: number
    questionDifficulty: string
    scoredAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionScoreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    marksObtained?: FloatFieldUpdateOperationsInput | number
    maxMarks?: FloatFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    timeEfficiency?: FloatFieldUpdateOperationsInput | number
    difficultyBonus?: FloatFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    attemptsCount?: IntFieldUpdateOperationsInput | number
    confidenceLevel?: FloatFieldUpdateOperationsInput | number
    questionDifficulty?: StringFieldUpdateOperationsInput | string
    scoredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    response?: QuestionResponseUpdateOneRequiredWithoutScoreNestedInput
    question?: QuestionUpdateOneRequiredWithoutScoresNestedInput
    attempt?: ExamAttemptUpdateOneRequiredWithoutQuestionScoresNestedInput
    user?: UserUpdateOneRequiredWithoutQuestionScoresNestedInput
  }

  export type QuestionScoreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    responseId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    attemptId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    marksObtained?: FloatFieldUpdateOperationsInput | number
    maxMarks?: FloatFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    timeEfficiency?: FloatFieldUpdateOperationsInput | number
    difficultyBonus?: FloatFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    attemptsCount?: IntFieldUpdateOperationsInput | number
    confidenceLevel?: FloatFieldUpdateOperationsInput | number
    questionDifficulty?: StringFieldUpdateOperationsInput | string
    scoredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionScoreCreateManyInput = {
    id?: string
    responseId: string
    questionId: string
    attemptId: string
    userId: string
    isCorrect?: boolean
    marksObtained?: number
    maxMarks?: number
    accuracy?: number
    timeEfficiency?: number
    difficultyBonus?: number
    penalty?: number
    responseTime?: number
    attemptsCount?: number
    confidenceLevel?: number
    questionDifficulty: string
    scoredAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionScoreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    marksObtained?: FloatFieldUpdateOperationsInput | number
    maxMarks?: FloatFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    timeEfficiency?: FloatFieldUpdateOperationsInput | number
    difficultyBonus?: FloatFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    attemptsCount?: IntFieldUpdateOperationsInput | number
    confidenceLevel?: FloatFieldUpdateOperationsInput | number
    questionDifficulty?: StringFieldUpdateOperationsInput | string
    scoredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionScoreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    responseId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    attemptId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    marksObtained?: FloatFieldUpdateOperationsInput | number
    maxMarks?: FloatFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    timeEfficiency?: FloatFieldUpdateOperationsInput | number
    difficultyBonus?: FloatFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    attemptsCount?: IntFieldUpdateOperationsInput | number
    confidenceLevel?: FloatFieldUpdateOperationsInput | number
    questionDifficulty?: StringFieldUpdateOperationsInput | string
    scoredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamScoreCreateInput = {
    id?: string
    totalMarks?: number
    maxMarks?: number
    percentage?: number
    grade?: string | null
    correctAnswers?: number
    wrongAnswers?: number
    unanswered?: number
    totalQuestions?: number
    totalTimeSpent?: number
    averageTimePerQuestion?: number
    timeEfficiency?: number
    easyCorrect?: number
    easyTotal?: number
    mediumCorrect?: number
    mediumTotal?: number
    hardCorrect?: number
    hardTotal?: number
    accuracy?: number
    speedScore?: number
    consistencyScore?: number
    difficultyScore?: number
    percentile?: number | null
    rank?: number | null
    improvement?: number | null
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    attempt: ExamAttemptCreateNestedOneWithoutExamScoreInput
    exam: ExamCreateNestedOneWithoutExamScoresInput
    user: UserCreateNestedOneWithoutExamScoresInput
  }

  export type ExamScoreUncheckedCreateInput = {
    id?: string
    attemptId: string
    examId: string
    userId: string
    totalMarks?: number
    maxMarks?: number
    percentage?: number
    grade?: string | null
    correctAnswers?: number
    wrongAnswers?: number
    unanswered?: number
    totalQuestions?: number
    totalTimeSpent?: number
    averageTimePerQuestion?: number
    timeEfficiency?: number
    easyCorrect?: number
    easyTotal?: number
    mediumCorrect?: number
    mediumTotal?: number
    hardCorrect?: number
    hardTotal?: number
    accuracy?: number
    speedScore?: number
    consistencyScore?: number
    difficultyScore?: number
    percentile?: number | null
    rank?: number | null
    improvement?: number | null
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamScoreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalMarks?: FloatFieldUpdateOperationsInput | number
    maxMarks?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswers?: IntFieldUpdateOperationsInput | number
    wrongAnswers?: IntFieldUpdateOperationsInput | number
    unanswered?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    totalTimeSpent?: IntFieldUpdateOperationsInput | number
    averageTimePerQuestion?: FloatFieldUpdateOperationsInput | number
    timeEfficiency?: FloatFieldUpdateOperationsInput | number
    easyCorrect?: IntFieldUpdateOperationsInput | number
    easyTotal?: IntFieldUpdateOperationsInput | number
    mediumCorrect?: IntFieldUpdateOperationsInput | number
    mediumTotal?: IntFieldUpdateOperationsInput | number
    hardCorrect?: IntFieldUpdateOperationsInput | number
    hardTotal?: IntFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    speedScore?: FloatFieldUpdateOperationsInput | number
    consistencyScore?: FloatFieldUpdateOperationsInput | number
    difficultyScore?: FloatFieldUpdateOperationsInput | number
    percentile?: NullableFloatFieldUpdateOperationsInput | number | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    improvement?: NullableFloatFieldUpdateOperationsInput | number | null
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempt?: ExamAttemptUpdateOneRequiredWithoutExamScoreNestedInput
    exam?: ExamUpdateOneRequiredWithoutExamScoresNestedInput
    user?: UserUpdateOneRequiredWithoutExamScoresNestedInput
  }

  export type ExamScoreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    attemptId?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalMarks?: FloatFieldUpdateOperationsInput | number
    maxMarks?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswers?: IntFieldUpdateOperationsInput | number
    wrongAnswers?: IntFieldUpdateOperationsInput | number
    unanswered?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    totalTimeSpent?: IntFieldUpdateOperationsInput | number
    averageTimePerQuestion?: FloatFieldUpdateOperationsInput | number
    timeEfficiency?: FloatFieldUpdateOperationsInput | number
    easyCorrect?: IntFieldUpdateOperationsInput | number
    easyTotal?: IntFieldUpdateOperationsInput | number
    mediumCorrect?: IntFieldUpdateOperationsInput | number
    mediumTotal?: IntFieldUpdateOperationsInput | number
    hardCorrect?: IntFieldUpdateOperationsInput | number
    hardTotal?: IntFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    speedScore?: FloatFieldUpdateOperationsInput | number
    consistencyScore?: FloatFieldUpdateOperationsInput | number
    difficultyScore?: FloatFieldUpdateOperationsInput | number
    percentile?: NullableFloatFieldUpdateOperationsInput | number | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    improvement?: NullableFloatFieldUpdateOperationsInput | number | null
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamScoreCreateManyInput = {
    id?: string
    attemptId: string
    examId: string
    userId: string
    totalMarks?: number
    maxMarks?: number
    percentage?: number
    grade?: string | null
    correctAnswers?: number
    wrongAnswers?: number
    unanswered?: number
    totalQuestions?: number
    totalTimeSpent?: number
    averageTimePerQuestion?: number
    timeEfficiency?: number
    easyCorrect?: number
    easyTotal?: number
    mediumCorrect?: number
    mediumTotal?: number
    hardCorrect?: number
    hardTotal?: number
    accuracy?: number
    speedScore?: number
    consistencyScore?: number
    difficultyScore?: number
    percentile?: number | null
    rank?: number | null
    improvement?: number | null
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamScoreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalMarks?: FloatFieldUpdateOperationsInput | number
    maxMarks?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswers?: IntFieldUpdateOperationsInput | number
    wrongAnswers?: IntFieldUpdateOperationsInput | number
    unanswered?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    totalTimeSpent?: IntFieldUpdateOperationsInput | number
    averageTimePerQuestion?: FloatFieldUpdateOperationsInput | number
    timeEfficiency?: FloatFieldUpdateOperationsInput | number
    easyCorrect?: IntFieldUpdateOperationsInput | number
    easyTotal?: IntFieldUpdateOperationsInput | number
    mediumCorrect?: IntFieldUpdateOperationsInput | number
    mediumTotal?: IntFieldUpdateOperationsInput | number
    hardCorrect?: IntFieldUpdateOperationsInput | number
    hardTotal?: IntFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    speedScore?: FloatFieldUpdateOperationsInput | number
    consistencyScore?: FloatFieldUpdateOperationsInput | number
    difficultyScore?: FloatFieldUpdateOperationsInput | number
    percentile?: NullableFloatFieldUpdateOperationsInput | number | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    improvement?: NullableFloatFieldUpdateOperationsInput | number | null
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamScoreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    attemptId?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalMarks?: FloatFieldUpdateOperationsInput | number
    maxMarks?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswers?: IntFieldUpdateOperationsInput | number
    wrongAnswers?: IntFieldUpdateOperationsInput | number
    unanswered?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    totalTimeSpent?: IntFieldUpdateOperationsInput | number
    averageTimePerQuestion?: FloatFieldUpdateOperationsInput | number
    timeEfficiency?: FloatFieldUpdateOperationsInput | number
    easyCorrect?: IntFieldUpdateOperationsInput | number
    easyTotal?: IntFieldUpdateOperationsInput | number
    mediumCorrect?: IntFieldUpdateOperationsInput | number
    mediumTotal?: IntFieldUpdateOperationsInput | number
    hardCorrect?: IntFieldUpdateOperationsInput | number
    hardTotal?: IntFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    speedScore?: FloatFieldUpdateOperationsInput | number
    consistencyScore?: FloatFieldUpdateOperationsInput | number
    difficultyScore?: FloatFieldUpdateOperationsInput | number
    percentile?: NullableFloatFieldUpdateOperationsInput | number | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    improvement?: NullableFloatFieldUpdateOperationsInput | number | null
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPerformanceCreateInput = {
    id?: string
    totalAttempts?: number
    totalPassed?: number
    totalFailed?: number
    passRate?: number
    averageScore?: number
    highestScore?: number
    lowestScore?: number
    totalMarks?: number
    totalTimeSpent?: number
    averageTimePerExam?: number
    easyAccuracy?: number
    mediumAccuracy?: number
    hardAccuracy?: number
    improvementRate?: number
    consistencyScore?: number
    learningCurve?: number
    lastAttemptAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserPerformancesInput
    examCategory?: ExamCategoryCreateNestedOneWithoutUserPerformancesInput
  }

  export type UserPerformanceUncheckedCreateInput = {
    id?: string
    userId: string
    examCategoryId?: string | null
    totalAttempts?: number
    totalPassed?: number
    totalFailed?: number
    passRate?: number
    averageScore?: number
    highestScore?: number
    lowestScore?: number
    totalMarks?: number
    totalTimeSpent?: number
    averageTimePerExam?: number
    easyAccuracy?: number
    mediumAccuracy?: number
    hardAccuracy?: number
    improvementRate?: number
    consistencyScore?: number
    learningCurve?: number
    lastAttemptAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPerformanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAttempts?: IntFieldUpdateOperationsInput | number
    totalPassed?: IntFieldUpdateOperationsInput | number
    totalFailed?: IntFieldUpdateOperationsInput | number
    passRate?: FloatFieldUpdateOperationsInput | number
    averageScore?: FloatFieldUpdateOperationsInput | number
    highestScore?: FloatFieldUpdateOperationsInput | number
    lowestScore?: FloatFieldUpdateOperationsInput | number
    totalMarks?: FloatFieldUpdateOperationsInput | number
    totalTimeSpent?: IntFieldUpdateOperationsInput | number
    averageTimePerExam?: FloatFieldUpdateOperationsInput | number
    easyAccuracy?: FloatFieldUpdateOperationsInput | number
    mediumAccuracy?: FloatFieldUpdateOperationsInput | number
    hardAccuracy?: FloatFieldUpdateOperationsInput | number
    improvementRate?: FloatFieldUpdateOperationsInput | number
    consistencyScore?: FloatFieldUpdateOperationsInput | number
    learningCurve?: FloatFieldUpdateOperationsInput | number
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserPerformancesNestedInput
    examCategory?: ExamCategoryUpdateOneWithoutUserPerformancesNestedInput
  }

  export type UserPerformanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    examCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    totalAttempts?: IntFieldUpdateOperationsInput | number
    totalPassed?: IntFieldUpdateOperationsInput | number
    totalFailed?: IntFieldUpdateOperationsInput | number
    passRate?: FloatFieldUpdateOperationsInput | number
    averageScore?: FloatFieldUpdateOperationsInput | number
    highestScore?: FloatFieldUpdateOperationsInput | number
    lowestScore?: FloatFieldUpdateOperationsInput | number
    totalMarks?: FloatFieldUpdateOperationsInput | number
    totalTimeSpent?: IntFieldUpdateOperationsInput | number
    averageTimePerExam?: FloatFieldUpdateOperationsInput | number
    easyAccuracy?: FloatFieldUpdateOperationsInput | number
    mediumAccuracy?: FloatFieldUpdateOperationsInput | number
    hardAccuracy?: FloatFieldUpdateOperationsInput | number
    improvementRate?: FloatFieldUpdateOperationsInput | number
    consistencyScore?: FloatFieldUpdateOperationsInput | number
    learningCurve?: FloatFieldUpdateOperationsInput | number
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPerformanceCreateManyInput = {
    id?: string
    userId: string
    examCategoryId?: string | null
    totalAttempts?: number
    totalPassed?: number
    totalFailed?: number
    passRate?: number
    averageScore?: number
    highestScore?: number
    lowestScore?: number
    totalMarks?: number
    totalTimeSpent?: number
    averageTimePerExam?: number
    easyAccuracy?: number
    mediumAccuracy?: number
    hardAccuracy?: number
    improvementRate?: number
    consistencyScore?: number
    learningCurve?: number
    lastAttemptAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPerformanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAttempts?: IntFieldUpdateOperationsInput | number
    totalPassed?: IntFieldUpdateOperationsInput | number
    totalFailed?: IntFieldUpdateOperationsInput | number
    passRate?: FloatFieldUpdateOperationsInput | number
    averageScore?: FloatFieldUpdateOperationsInput | number
    highestScore?: FloatFieldUpdateOperationsInput | number
    lowestScore?: FloatFieldUpdateOperationsInput | number
    totalMarks?: FloatFieldUpdateOperationsInput | number
    totalTimeSpent?: IntFieldUpdateOperationsInput | number
    averageTimePerExam?: FloatFieldUpdateOperationsInput | number
    easyAccuracy?: FloatFieldUpdateOperationsInput | number
    mediumAccuracy?: FloatFieldUpdateOperationsInput | number
    hardAccuracy?: FloatFieldUpdateOperationsInput | number
    improvementRate?: FloatFieldUpdateOperationsInput | number
    consistencyScore?: FloatFieldUpdateOperationsInput | number
    learningCurve?: FloatFieldUpdateOperationsInput | number
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPerformanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    examCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    totalAttempts?: IntFieldUpdateOperationsInput | number
    totalPassed?: IntFieldUpdateOperationsInput | number
    totalFailed?: IntFieldUpdateOperationsInput | number
    passRate?: FloatFieldUpdateOperationsInput | number
    averageScore?: FloatFieldUpdateOperationsInput | number
    highestScore?: FloatFieldUpdateOperationsInput | number
    lowestScore?: FloatFieldUpdateOperationsInput | number
    totalMarks?: FloatFieldUpdateOperationsInput | number
    totalTimeSpent?: IntFieldUpdateOperationsInput | number
    averageTimePerExam?: FloatFieldUpdateOperationsInput | number
    easyAccuracy?: FloatFieldUpdateOperationsInput | number
    mediumAccuracy?: FloatFieldUpdateOperationsInput | number
    hardAccuracy?: FloatFieldUpdateOperationsInput | number
    improvementRate?: FloatFieldUpdateOperationsInput | number
    consistencyScore?: FloatFieldUpdateOperationsInput | number
    learningCurve?: FloatFieldUpdateOperationsInput | number
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    stripePaymentId?: string | null
    stripeRefundId?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    refundedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentsInput
    booking?: ExamBookingCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    userId: string
    bookingId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    stripePaymentId?: string | null
    stripeRefundId?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    refundedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    stripePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
    booking?: ExamBookingUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    stripePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    userId: string
    bookingId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    stripePaymentId?: string | null
    stripeRefundId?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    refundedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    stripePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    stripePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateCreateInput = {
    id?: string
    certificateNumber: string
    issuedAt?: Date | string
    expiresAt?: Date | string | null
    isRevoked?: boolean
    revokedAt?: Date | string | null
    revokedReason?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCertificatesInput
    exam: ExamCreateNestedOneWithoutCertificatesInput
    attempt: ExamAttemptCreateNestedOneWithoutCertificateInput
    revoker?: UserCreateNestedOneWithoutRevokedCertificatesInput
  }

  export type CertificateUncheckedCreateInput = {
    id?: string
    userId: string
    examId: string
    attemptId: string
    certificateNumber: string
    issuedAt?: Date | string
    expiresAt?: Date | string | null
    isRevoked?: boolean
    revokedAt?: Date | string | null
    revokedBy?: string | null
    revokedReason?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    certificateNumber?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCertificatesNestedInput
    exam?: ExamUpdateOneRequiredWithoutCertificatesNestedInput
    attempt?: ExamAttemptUpdateOneRequiredWithoutCertificateNestedInput
    revoker?: UserUpdateOneWithoutRevokedCertificatesNestedInput
  }

  export type CertificateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    attemptId?: StringFieldUpdateOperationsInput | string
    certificateNumber?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedBy?: NullableStringFieldUpdateOperationsInput | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateCreateManyInput = {
    id?: string
    userId: string
    examId: string
    attemptId: string
    certificateNumber: string
    issuedAt?: Date | string
    expiresAt?: Date | string | null
    isRevoked?: boolean
    revokedAt?: Date | string | null
    revokedBy?: string | null
    revokedReason?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    certificateNumber?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    attemptId?: StringFieldUpdateOperationsInput | string
    certificateNumber?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedBy?: NullableStringFieldUpdateOperationsInput | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudyGroupCreateInput = {
    id?: string
    name: string
    description?: string | null
    isPrivate?: boolean
    maxMembers?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedStudyGroupsInput
    members?: StudyGroupMemberCreateNestedManyWithoutGroupInput
  }

  export type StudyGroupUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    isPrivate?: boolean
    maxMembers?: number
    createdBy: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: StudyGroupMemberUncheckedCreateNestedManyWithoutGroupInput
  }

  export type StudyGroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    maxMembers?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedStudyGroupsNestedInput
    members?: StudyGroupMemberUpdateManyWithoutGroupNestedInput
  }

  export type StudyGroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    maxMembers?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: StudyGroupMemberUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type StudyGroupCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    isPrivate?: boolean
    maxMembers?: number
    createdBy: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudyGroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    maxMembers?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudyGroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    maxMembers?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudyGroupMemberCreateInput = {
    id?: string
    role?: $Enums.GroupRole
    joinedAt?: Date | string
    isActive?: boolean
    group: StudyGroupCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutStudyGroupsInput
  }

  export type StudyGroupMemberUncheckedCreateInput = {
    id?: string
    groupId: string
    userId: string
    role?: $Enums.GroupRole
    joinedAt?: Date | string
    isActive?: boolean
  }

  export type StudyGroupMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumGroupRoleFieldUpdateOperationsInput | $Enums.GroupRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    group?: StudyGroupUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutStudyGroupsNestedInput
  }

  export type StudyGroupMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumGroupRoleFieldUpdateOperationsInput | $Enums.GroupRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudyGroupMemberCreateManyInput = {
    id?: string
    groupId: string
    userId: string
    role?: $Enums.GroupRole
    joinedAt?: Date | string
    isActive?: boolean
  }

  export type StudyGroupMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumGroupRoleFieldUpdateOperationsInput | $Enums.GroupRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudyGroupMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumGroupRoleFieldUpdateOperationsInput | $Enums.GroupRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId?: string | null
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamCategoryUserCreateInput = {
    id?: string
    accessLevel?: $Enums.AccessLevel
    grantedAt?: Date | string
    examCategory: ExamCategoryCreateNestedOneWithoutUsersInput
    user: UserCreateNestedOneWithoutExamCategoriesInput
    granter: UserCreateNestedOneWithoutGrantedExamCategoriesInput
  }

  export type ExamCategoryUserUncheckedCreateInput = {
    id?: string
    examCategoryId: string
    userId: string
    accessLevel?: $Enums.AccessLevel
    grantedAt?: Date | string
    grantedBy: string
  }

  export type ExamCategoryUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examCategory?: ExamCategoryUpdateOneRequiredWithoutUsersNestedInput
    user?: UserUpdateOneRequiredWithoutExamCategoriesNestedInput
    granter?: UserUpdateOneRequiredWithoutGrantedExamCategoriesNestedInput
  }

  export type ExamCategoryUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    examCategoryId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grantedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ExamCategoryUserCreateManyInput = {
    id?: string
    examCategoryId: string
    userId: string
    accessLevel?: $Enums.AccessLevel
    grantedAt?: Date | string
    grantedBy: string
  }

  export type ExamCategoryUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamCategoryUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    examCategoryId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grantedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ExamStatisticsViewCreateInput = {
    examId: string
    examTitle: string
    totalAttempts: number
    totalBookings: number
    totalRevenue: Decimal | DecimalJsLike | number | string
    averageScore: number
    passRate: number
    averageTime: number
    lastAttemptDate?: Date | string | null
  }

  export type ExamStatisticsViewUncheckedCreateInput = {
    examId: string
    examTitle: string
    totalAttempts: number
    totalBookings: number
    totalRevenue: Decimal | DecimalJsLike | number | string
    averageScore: number
    passRate: number
    averageTime: number
    lastAttemptDate?: Date | string | null
  }

  export type ExamStatisticsViewUpdateInput = {
    examId?: StringFieldUpdateOperationsInput | string
    examTitle?: StringFieldUpdateOperationsInput | string
    totalAttempts?: IntFieldUpdateOperationsInput | number
    totalBookings?: IntFieldUpdateOperationsInput | number
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    averageScore?: FloatFieldUpdateOperationsInput | number
    passRate?: FloatFieldUpdateOperationsInput | number
    averageTime?: IntFieldUpdateOperationsInput | number
    lastAttemptDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExamStatisticsViewUncheckedUpdateInput = {
    examId?: StringFieldUpdateOperationsInput | string
    examTitle?: StringFieldUpdateOperationsInput | string
    totalAttempts?: IntFieldUpdateOperationsInput | number
    totalBookings?: IntFieldUpdateOperationsInput | number
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    averageScore?: FloatFieldUpdateOperationsInput | number
    passRate?: FloatFieldUpdateOperationsInput | number
    averageTime?: IntFieldUpdateOperationsInput | number
    lastAttemptDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExamStatisticsViewCreateManyInput = {
    examId: string
    examTitle: string
    totalAttempts: number
    totalBookings: number
    totalRevenue: Decimal | DecimalJsLike | number | string
    averageScore: number
    passRate: number
    averageTime: number
    lastAttemptDate?: Date | string | null
  }

  export type ExamStatisticsViewUpdateManyMutationInput = {
    examId?: StringFieldUpdateOperationsInput | string
    examTitle?: StringFieldUpdateOperationsInput | string
    totalAttempts?: IntFieldUpdateOperationsInput | number
    totalBookings?: IntFieldUpdateOperationsInput | number
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    averageScore?: FloatFieldUpdateOperationsInput | number
    passRate?: FloatFieldUpdateOperationsInput | number
    averageTime?: IntFieldUpdateOperationsInput | number
    lastAttemptDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ExamStatisticsViewUncheckedUpdateManyInput = {
    examId?: StringFieldUpdateOperationsInput | string
    examTitle?: StringFieldUpdateOperationsInput | string
    totalAttempts?: IntFieldUpdateOperationsInput | number
    totalBookings?: IntFieldUpdateOperationsInput | number
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    averageScore?: FloatFieldUpdateOperationsInput | number
    passRate?: FloatFieldUpdateOperationsInput | number
    averageTime?: IntFieldUpdateOperationsInput | number
    lastAttemptDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserPerformanceViewCreateInput = {
    userId: string
    userEmail: string
    totalExamsTaken: number
    totalExamsPassed: number
    averageScore: number
    totalTimeSpent: number
    certificatesEarned: number
    lastExamDate?: Date | string | null
  }

  export type UserPerformanceViewUncheckedCreateInput = {
    userId: string
    userEmail: string
    totalExamsTaken: number
    totalExamsPassed: number
    averageScore: number
    totalTimeSpent: number
    certificatesEarned: number
    lastExamDate?: Date | string | null
  }

  export type UserPerformanceViewUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    totalExamsTaken?: IntFieldUpdateOperationsInput | number
    totalExamsPassed?: IntFieldUpdateOperationsInput | number
    averageScore?: FloatFieldUpdateOperationsInput | number
    totalTimeSpent?: IntFieldUpdateOperationsInput | number
    certificatesEarned?: IntFieldUpdateOperationsInput | number
    lastExamDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserPerformanceViewUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    totalExamsTaken?: IntFieldUpdateOperationsInput | number
    totalExamsPassed?: IntFieldUpdateOperationsInput | number
    averageScore?: FloatFieldUpdateOperationsInput | number
    totalTimeSpent?: IntFieldUpdateOperationsInput | number
    certificatesEarned?: IntFieldUpdateOperationsInput | number
    lastExamDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserPerformanceViewCreateManyInput = {
    userId: string
    userEmail: string
    totalExamsTaken: number
    totalExamsPassed: number
    averageScore: number
    totalTimeSpent: number
    certificatesEarned: number
    lastExamDate?: Date | string | null
  }

  export type UserPerformanceViewUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    totalExamsTaken?: IntFieldUpdateOperationsInput | number
    totalExamsPassed?: IntFieldUpdateOperationsInput | number
    averageScore?: FloatFieldUpdateOperationsInput | number
    totalTimeSpent?: IntFieldUpdateOperationsInput | number
    certificatesEarned?: IntFieldUpdateOperationsInput | number
    lastExamDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserPerformanceViewUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    userEmail?: StringFieldUpdateOperationsInput | string
    totalExamsTaken?: IntFieldUpdateOperationsInput | number
    totalExamsPassed?: IntFieldUpdateOperationsInput | number
    averageScore?: FloatFieldUpdateOperationsInput | number
    totalTimeSpent?: IntFieldUpdateOperationsInput | number
    certificatesEarned?: IntFieldUpdateOperationsInput | number
    lastExamDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuestionAnalyticsViewCreateInput = {
    questionId: string
    questionText: string
    usageCount: number
    correctAnswerRate: number
    averageTime: number
    difficulty: $Enums.QuestionDifficulty
    examCategoryName: string
  }

  export type QuestionAnalyticsViewUncheckedCreateInput = {
    questionId: string
    questionText: string
    usageCount: number
    correctAnswerRate: number
    averageTime: number
    difficulty: $Enums.QuestionDifficulty
    examCategoryName: string
  }

  export type QuestionAnalyticsViewUpdateInput = {
    questionId?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    correctAnswerRate?: FloatFieldUpdateOperationsInput | number
    averageTime?: IntFieldUpdateOperationsInput | number
    difficulty?: EnumQuestionDifficultyFieldUpdateOperationsInput | $Enums.QuestionDifficulty
    examCategoryName?: StringFieldUpdateOperationsInput | string
  }

  export type QuestionAnalyticsViewUncheckedUpdateInput = {
    questionId?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    correctAnswerRate?: FloatFieldUpdateOperationsInput | number
    averageTime?: IntFieldUpdateOperationsInput | number
    difficulty?: EnumQuestionDifficultyFieldUpdateOperationsInput | $Enums.QuestionDifficulty
    examCategoryName?: StringFieldUpdateOperationsInput | string
  }

  export type QuestionAnalyticsViewCreateManyInput = {
    questionId: string
    questionText: string
    usageCount: number
    correctAnswerRate: number
    averageTime: number
    difficulty: $Enums.QuestionDifficulty
    examCategoryName: string
  }

  export type QuestionAnalyticsViewUpdateManyMutationInput = {
    questionId?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    correctAnswerRate?: FloatFieldUpdateOperationsInput | number
    averageTime?: IntFieldUpdateOperationsInput | number
    difficulty?: EnumQuestionDifficultyFieldUpdateOperationsInput | $Enums.QuestionDifficulty
    examCategoryName?: StringFieldUpdateOperationsInput | string
  }

  export type QuestionAnalyticsViewUncheckedUpdateManyInput = {
    questionId?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    usageCount?: IntFieldUpdateOperationsInput | number
    correctAnswerRate?: FloatFieldUpdateOperationsInput | number
    averageTime?: IntFieldUpdateOperationsInput | number
    difficulty?: EnumQuestionDifficultyFieldUpdateOperationsInput | $Enums.QuestionDifficulty
    examCategoryName?: StringFieldUpdateOperationsInput | string
  }

  export type RevenueAnalyticsViewCreateInput = {
    date: Date | string
    totalRevenue: Decimal | DecimalJsLike | number | string
    totalTransactions: number
    averageTransactionValue: Decimal | DecimalJsLike | number | string
    topExamCategory: string
    topExam: string
  }

  export type RevenueAnalyticsViewUncheckedCreateInput = {
    date: Date | string
    totalRevenue: Decimal | DecimalJsLike | number | string
    totalTransactions: number
    averageTransactionValue: Decimal | DecimalJsLike | number | string
    topExamCategory: string
    topExam: string
  }

  export type RevenueAnalyticsViewUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTransactions?: IntFieldUpdateOperationsInput | number
    averageTransactionValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    topExamCategory?: StringFieldUpdateOperationsInput | string
    topExam?: StringFieldUpdateOperationsInput | string
  }

  export type RevenueAnalyticsViewUncheckedUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTransactions?: IntFieldUpdateOperationsInput | number
    averageTransactionValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    topExamCategory?: StringFieldUpdateOperationsInput | string
    topExam?: StringFieldUpdateOperationsInput | string
  }

  export type RevenueAnalyticsViewCreateManyInput = {
    date: Date | string
    totalRevenue: Decimal | DecimalJsLike | number | string
    totalTransactions: number
    averageTransactionValue: Decimal | DecimalJsLike | number | string
    topExamCategory: string
    topExam: string
  }

  export type RevenueAnalyticsViewUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTransactions?: IntFieldUpdateOperationsInput | number
    averageTransactionValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    topExamCategory?: StringFieldUpdateOperationsInput | string
    topExam?: StringFieldUpdateOperationsInput | string
  }

  export type RevenueAnalyticsViewUncheckedUpdateManyInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    totalRevenue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalTransactions?: IntFieldUpdateOperationsInput | number
    averageTransactionValue?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    topExamCategory?: StringFieldUpdateOperationsInput | string
    topExam?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ExamBookingListRelationFilter = {
    every?: ExamBookingWhereInput
    some?: ExamBookingWhereInput
    none?: ExamBookingWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type ExamAttemptListRelationFilter = {
    every?: ExamAttemptWhereInput
    some?: ExamAttemptWhereInput
    none?: ExamAttemptWhereInput
  }

  export type QuestionResponseListRelationFilter = {
    every?: QuestionResponseWhereInput
    some?: QuestionResponseWhereInput
    none?: QuestionResponseWhereInput
  }

  export type QuestionScoreListRelationFilter = {
    every?: QuestionScoreWhereInput
    some?: QuestionScoreWhereInput
    none?: QuestionScoreWhereInput
  }

  export type ExamScoreListRelationFilter = {
    every?: ExamScoreWhereInput
    some?: ExamScoreWhereInput
    none?: ExamScoreWhereInput
  }

  export type UserPerformanceListRelationFilter = {
    every?: UserPerformanceWhereInput
    some?: UserPerformanceWhereInput
    none?: UserPerformanceWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type UserSessionListRelationFilter = {
    every?: UserSessionWhereInput
    some?: UserSessionWhereInput
    none?: UserSessionWhereInput
  }

  export type ExamCategoryUserListRelationFilter = {
    every?: ExamCategoryUserWhereInput
    some?: ExamCategoryUserWhereInput
    none?: ExamCategoryUserWhereInput
  }

  export type StudyGroupMemberListRelationFilter = {
    every?: StudyGroupMemberWhereInput
    some?: StudyGroupMemberWhereInput
    none?: StudyGroupMemberWhereInput
  }

  export type CertificateListRelationFilter = {
    every?: CertificateWhereInput
    some?: CertificateWhereInput
    none?: CertificateWhereInput
  }

  export type StudyGroupListRelationFilter = {
    every?: StudyGroupWhereInput
    some?: StudyGroupWhereInput
    none?: StudyGroupWhereInput
  }

  export type QuestionListRelationFilter = {
    every?: QuestionWhereInput
    some?: QuestionWhereInput
    none?: QuestionWhereInput
  }

  export type ExamListRelationFilter = {
    every?: ExamWhereInput
    some?: ExamWhereInput
    none?: ExamWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ExamBookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExamAttemptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionResponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionScoreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExamScoreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserPerformanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExamCategoryUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudyGroupMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CertificateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudyGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    profileImage?: SortOrder
    profilePicture?: SortOrder
    address?: SortOrder
    isActive?: SortOrder
    isEmailVerified?: SortOrder
    isPhoneVerified?: SortOrder
    emailVerificationToken?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpires?: SortOrder
    lastLoginAt?: SortOrder
    loginAttempts?: SortOrder
    lockedUntil?: SortOrder
    role?: SortOrder
    status?: SortOrder
    departmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    loginAttempts?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    profileImage?: SortOrder
    profilePicture?: SortOrder
    address?: SortOrder
    isActive?: SortOrder
    isEmailVerified?: SortOrder
    isPhoneVerified?: SortOrder
    emailVerificationToken?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpires?: SortOrder
    lastLoginAt?: SortOrder
    loginAttempts?: SortOrder
    lockedUntil?: SortOrder
    role?: SortOrder
    status?: SortOrder
    departmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    profileImage?: SortOrder
    profilePicture?: SortOrder
    address?: SortOrder
    isActive?: SortOrder
    isEmailVerified?: SortOrder
    isPhoneVerified?: SortOrder
    emailVerificationToken?: SortOrder
    passwordResetToken?: SortOrder
    passwordResetExpires?: SortOrder
    lastLoginAt?: SortOrder
    loginAttempts?: SortOrder
    lockedUntil?: SortOrder
    role?: SortOrder
    status?: SortOrder
    departmentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    loginAttempts?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionToken?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionToken?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionToken?: SortOrder
    expiresAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ExamCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamCategoryAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type ExamCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamCategorySumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type EnumQuestionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeFilter<$PrismaModel> | $Enums.QuestionType
  }

  export type EnumQuestionDifficultyFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionDifficulty | EnumQuestionDifficultyFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionDifficulty[] | ListEnumQuestionDifficultyFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionDifficulty[] | ListEnumQuestionDifficultyFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionDifficultyFilter<$PrismaModel> | $Enums.QuestionDifficulty
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ExamCategoryScalarRelationFilter = {
    is?: ExamCategoryWhereInput
    isNot?: ExamCategoryWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type QuestionOptionListRelationFilter = {
    every?: QuestionOptionWhereInput
    some?: QuestionOptionWhereInput
    none?: QuestionOptionWhereInput
  }

  export type QuestionImageListRelationFilter = {
    every?: QuestionImageWhereInput
    some?: QuestionImageWhereInput
    none?: QuestionImageWhereInput
  }

  export type QuestionTagListRelationFilter = {
    every?: QuestionTagWhereInput
    some?: QuestionTagWhereInput
    none?: QuestionTagWhereInput
  }

  export type ExamQuestionListRelationFilter = {
    every?: ExamQuestionWhereInput
    some?: ExamQuestionWhereInput
    none?: ExamQuestionWhereInput
  }

  export type QuestionOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExamQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionCountOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    type?: SortOrder
    difficulty?: SortOrder
    examCategoryId?: SortOrder
    marks?: SortOrder
    timeLimit?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    createdBy?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    usageCount?: SortOrder
    correctAnswerRate?: SortOrder
    averageTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionAvgOrderByAggregateInput = {
    marks?: SortOrder
    timeLimit?: SortOrder
    usageCount?: SortOrder
    correctAnswerRate?: SortOrder
    averageTime?: SortOrder
  }

  export type QuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    type?: SortOrder
    difficulty?: SortOrder
    examCategoryId?: SortOrder
    marks?: SortOrder
    timeLimit?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    createdBy?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    usageCount?: SortOrder
    correctAnswerRate?: SortOrder
    averageTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionMinOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    type?: SortOrder
    difficulty?: SortOrder
    examCategoryId?: SortOrder
    marks?: SortOrder
    timeLimit?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    createdBy?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    usageCount?: SortOrder
    correctAnswerRate?: SortOrder
    averageTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionSumOrderByAggregateInput = {
    marks?: SortOrder
    timeLimit?: SortOrder
    usageCount?: SortOrder
    correctAnswerRate?: SortOrder
    averageTime?: SortOrder
  }

  export type EnumQuestionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeWithAggregatesFilter<$PrismaModel> | $Enums.QuestionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionTypeFilter<$PrismaModel>
    _max?: NestedEnumQuestionTypeFilter<$PrismaModel>
  }

  export type EnumQuestionDifficultyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionDifficulty | EnumQuestionDifficultyFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionDifficulty[] | ListEnumQuestionDifficultyFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionDifficulty[] | ListEnumQuestionDifficultyFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionDifficultyWithAggregatesFilter<$PrismaModel> | $Enums.QuestionDifficulty
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionDifficultyFilter<$PrismaModel>
    _max?: NestedEnumQuestionDifficultyFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type QuestionScalarRelationFilter = {
    is?: QuestionWhereInput
    isNot?: QuestionWhereInput
  }

  export type QuestionOptionCountOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    text?: SortOrder
    isCorrect?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type QuestionOptionAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type QuestionOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    text?: SortOrder
    isCorrect?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type QuestionOptionMinOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    text?: SortOrder
    isCorrect?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type QuestionOptionSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type QuestionImageCountOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    imageUrl?: SortOrder
    altText?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type QuestionImageAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type QuestionImageMaxOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    imageUrl?: SortOrder
    altText?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type QuestionImageMinOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    imageUrl?: SortOrder
    altText?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type QuestionImageSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type QuestionTagQuestionIdTagCompoundUniqueInput = {
    questionId: string
    tag: string
  }

  export type QuestionTagCountOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    tag?: SortOrder
    createdAt?: SortOrder
  }

  export type QuestionTagMaxOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    tag?: SortOrder
    createdAt?: SortOrder
  }

  export type QuestionTagMinOrderByAggregateInput = {
    id?: SortOrder
    questionId?: SortOrder
    tag?: SortOrder
    createdAt?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ExamCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    examCategoryId?: SortOrder
    duration?: SortOrder
    totalMarks?: SortOrder
    passingMarks?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    allowRetakes?: SortOrder
    maxRetakes?: SortOrder
    showResults?: SortOrder
    showAnswers?: SortOrder
    randomizeQuestions?: SortOrder
    randomizeOptions?: SortOrder
    questionOverlapPercentage?: SortOrder
    createdBy?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    scheduledStart?: SortOrder
    scheduledEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamAvgOrderByAggregateInput = {
    duration?: SortOrder
    totalMarks?: SortOrder
    passingMarks?: SortOrder
    price?: SortOrder
    maxRetakes?: SortOrder
    questionOverlapPercentage?: SortOrder
  }

  export type ExamMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    examCategoryId?: SortOrder
    duration?: SortOrder
    totalMarks?: SortOrder
    passingMarks?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    allowRetakes?: SortOrder
    maxRetakes?: SortOrder
    showResults?: SortOrder
    showAnswers?: SortOrder
    randomizeQuestions?: SortOrder
    randomizeOptions?: SortOrder
    questionOverlapPercentage?: SortOrder
    createdBy?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    scheduledStart?: SortOrder
    scheduledEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    examCategoryId?: SortOrder
    duration?: SortOrder
    totalMarks?: SortOrder
    passingMarks?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    isActive?: SortOrder
    isPublic?: SortOrder
    allowRetakes?: SortOrder
    maxRetakes?: SortOrder
    showResults?: SortOrder
    showAnswers?: SortOrder
    randomizeQuestions?: SortOrder
    randomizeOptions?: SortOrder
    questionOverlapPercentage?: SortOrder
    createdBy?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    scheduledStart?: SortOrder
    scheduledEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamSumOrderByAggregateInput = {
    duration?: SortOrder
    totalMarks?: SortOrder
    passingMarks?: SortOrder
    price?: SortOrder
    maxRetakes?: SortOrder
    questionOverlapPercentage?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ExamScalarRelationFilter = {
    is?: ExamWhereInput
    isNot?: ExamWhereInput
  }

  export type ExamQuestionExamIdQuestionIdCompoundUniqueInput = {
    examId: string
    questionId: string
  }

  export type ExamQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    examId?: SortOrder
    questionId?: SortOrder
    order?: SortOrder
    marks?: SortOrder
    createdAt?: SortOrder
  }

  export type ExamQuestionAvgOrderByAggregateInput = {
    order?: SortOrder
    marks?: SortOrder
  }

  export type ExamQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    examId?: SortOrder
    questionId?: SortOrder
    order?: SortOrder
    marks?: SortOrder
    createdAt?: SortOrder
  }

  export type ExamQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    examId?: SortOrder
    questionId?: SortOrder
    order?: SortOrder
    marks?: SortOrder
    createdAt?: SortOrder
  }

  export type ExamQuestionSumOrderByAggregateInput = {
    order?: SortOrder
    marks?: SortOrder
  }

  export type EnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type PaymentNullableScalarRelationFilter = {
    is?: PaymentWhereInput | null
    isNot?: PaymentWhereInput | null
  }

  export type ExamBookingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    examId?: SortOrder
    bookingDate?: SortOrder
    scheduledAt?: SortOrder
    status?: SortOrder
    paymentId?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamBookingAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type ExamBookingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    examId?: SortOrder
    bookingDate?: SortOrder
    scheduledAt?: SortOrder
    status?: SortOrder
    paymentId?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamBookingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    examId?: SortOrder
    bookingDate?: SortOrder
    scheduledAt?: SortOrder
    status?: SortOrder
    paymentId?: SortOrder
    totalAmount?: SortOrder
    currency?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamBookingSumOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type EnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type EnumAttemptStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttemptStatus | EnumAttemptStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttemptStatus[] | ListEnumAttemptStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttemptStatus[] | ListEnumAttemptStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttemptStatusFilter<$PrismaModel> | $Enums.AttemptStatus
  }

  export type ExamBookingNullableScalarRelationFilter = {
    is?: ExamBookingWhereInput | null
    isNot?: ExamBookingWhereInput | null
  }

  export type ExamScoreNullableScalarRelationFilter = {
    is?: ExamScoreWhereInput | null
    isNot?: ExamScoreWhereInput | null
  }

  export type CertificateNullableScalarRelationFilter = {
    is?: CertificateWhereInput | null
    isNot?: CertificateWhereInput | null
  }

  export type ExamAttemptCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    examId?: SortOrder
    bookingId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
    totalMarks?: SortOrder
    obtainedMarks?: SortOrder
    percentage?: SortOrder
    isPassed?: SortOrder
    timeSpent?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    isCheating?: SortOrder
    cheatingReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamAttemptAvgOrderByAggregateInput = {
    totalMarks?: SortOrder
    obtainedMarks?: SortOrder
    percentage?: SortOrder
    timeSpent?: SortOrder
  }

  export type ExamAttemptMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    examId?: SortOrder
    bookingId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
    totalMarks?: SortOrder
    obtainedMarks?: SortOrder
    percentage?: SortOrder
    isPassed?: SortOrder
    timeSpent?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    isCheating?: SortOrder
    cheatingReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamAttemptMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    examId?: SortOrder
    bookingId?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    status?: SortOrder
    totalMarks?: SortOrder
    obtainedMarks?: SortOrder
    percentage?: SortOrder
    isPassed?: SortOrder
    timeSpent?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    isCheating?: SortOrder
    cheatingReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamAttemptSumOrderByAggregateInput = {
    totalMarks?: SortOrder
    obtainedMarks?: SortOrder
    percentage?: SortOrder
    timeSpent?: SortOrder
  }

  export type EnumAttemptStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttemptStatus | EnumAttemptStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttemptStatus[] | ListEnumAttemptStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttemptStatus[] | ListEnumAttemptStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttemptStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttemptStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttemptStatusFilter<$PrismaModel>
    _max?: NestedEnumAttemptStatusFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type ExamAttemptScalarRelationFilter = {
    is?: ExamAttemptWhereInput
    isNot?: ExamAttemptWhereInput
  }

  export type QuestionScoreNullableScalarRelationFilter = {
    is?: QuestionScoreWhereInput | null
    isNot?: QuestionScoreWhereInput | null
  }

  export type QuestionResponseAttemptIdQuestionIdCompoundUniqueInput = {
    attemptId: string
    questionId: string
  }

  export type QuestionResponseCountOrderByAggregateInput = {
    id?: SortOrder
    attemptId?: SortOrder
    questionId?: SortOrder
    userId?: SortOrder
    selectedOptions?: SortOrder
    isCorrect?: SortOrder
    marksObtained?: SortOrder
    timeSpent?: SortOrder
    answeredAt?: SortOrder
    submittedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionResponseAvgOrderByAggregateInput = {
    marksObtained?: SortOrder
    timeSpent?: SortOrder
  }

  export type QuestionResponseMaxOrderByAggregateInput = {
    id?: SortOrder
    attemptId?: SortOrder
    questionId?: SortOrder
    userId?: SortOrder
    isCorrect?: SortOrder
    marksObtained?: SortOrder
    timeSpent?: SortOrder
    answeredAt?: SortOrder
    submittedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionResponseMinOrderByAggregateInput = {
    id?: SortOrder
    attemptId?: SortOrder
    questionId?: SortOrder
    userId?: SortOrder
    isCorrect?: SortOrder
    marksObtained?: SortOrder
    timeSpent?: SortOrder
    answeredAt?: SortOrder
    submittedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionResponseSumOrderByAggregateInput = {
    marksObtained?: SortOrder
    timeSpent?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type QuestionResponseScalarRelationFilter = {
    is?: QuestionResponseWhereInput
    isNot?: QuestionResponseWhereInput
  }

  export type QuestionScoreCountOrderByAggregateInput = {
    id?: SortOrder
    responseId?: SortOrder
    questionId?: SortOrder
    attemptId?: SortOrder
    userId?: SortOrder
    isCorrect?: SortOrder
    marksObtained?: SortOrder
    maxMarks?: SortOrder
    accuracy?: SortOrder
    timeEfficiency?: SortOrder
    difficultyBonus?: SortOrder
    penalty?: SortOrder
    responseTime?: SortOrder
    attemptsCount?: SortOrder
    confidenceLevel?: SortOrder
    questionDifficulty?: SortOrder
    scoredAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionScoreAvgOrderByAggregateInput = {
    marksObtained?: SortOrder
    maxMarks?: SortOrder
    accuracy?: SortOrder
    timeEfficiency?: SortOrder
    difficultyBonus?: SortOrder
    penalty?: SortOrder
    responseTime?: SortOrder
    attemptsCount?: SortOrder
    confidenceLevel?: SortOrder
  }

  export type QuestionScoreMaxOrderByAggregateInput = {
    id?: SortOrder
    responseId?: SortOrder
    questionId?: SortOrder
    attemptId?: SortOrder
    userId?: SortOrder
    isCorrect?: SortOrder
    marksObtained?: SortOrder
    maxMarks?: SortOrder
    accuracy?: SortOrder
    timeEfficiency?: SortOrder
    difficultyBonus?: SortOrder
    penalty?: SortOrder
    responseTime?: SortOrder
    attemptsCount?: SortOrder
    confidenceLevel?: SortOrder
    questionDifficulty?: SortOrder
    scoredAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionScoreMinOrderByAggregateInput = {
    id?: SortOrder
    responseId?: SortOrder
    questionId?: SortOrder
    attemptId?: SortOrder
    userId?: SortOrder
    isCorrect?: SortOrder
    marksObtained?: SortOrder
    maxMarks?: SortOrder
    accuracy?: SortOrder
    timeEfficiency?: SortOrder
    difficultyBonus?: SortOrder
    penalty?: SortOrder
    responseTime?: SortOrder
    attemptsCount?: SortOrder
    confidenceLevel?: SortOrder
    questionDifficulty?: SortOrder
    scoredAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionScoreSumOrderByAggregateInput = {
    marksObtained?: SortOrder
    maxMarks?: SortOrder
    accuracy?: SortOrder
    timeEfficiency?: SortOrder
    difficultyBonus?: SortOrder
    penalty?: SortOrder
    responseTime?: SortOrder
    attemptsCount?: SortOrder
    confidenceLevel?: SortOrder
  }

  export type ExamScoreCountOrderByAggregateInput = {
    id?: SortOrder
    attemptId?: SortOrder
    examId?: SortOrder
    userId?: SortOrder
    totalMarks?: SortOrder
    maxMarks?: SortOrder
    percentage?: SortOrder
    grade?: SortOrder
    correctAnswers?: SortOrder
    wrongAnswers?: SortOrder
    unanswered?: SortOrder
    totalQuestions?: SortOrder
    totalTimeSpent?: SortOrder
    averageTimePerQuestion?: SortOrder
    timeEfficiency?: SortOrder
    easyCorrect?: SortOrder
    easyTotal?: SortOrder
    mediumCorrect?: SortOrder
    mediumTotal?: SortOrder
    hardCorrect?: SortOrder
    hardTotal?: SortOrder
    accuracy?: SortOrder
    speedScore?: SortOrder
    consistencyScore?: SortOrder
    difficultyScore?: SortOrder
    percentile?: SortOrder
    rank?: SortOrder
    improvement?: SortOrder
    calculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamScoreAvgOrderByAggregateInput = {
    totalMarks?: SortOrder
    maxMarks?: SortOrder
    percentage?: SortOrder
    correctAnswers?: SortOrder
    wrongAnswers?: SortOrder
    unanswered?: SortOrder
    totalQuestions?: SortOrder
    totalTimeSpent?: SortOrder
    averageTimePerQuestion?: SortOrder
    timeEfficiency?: SortOrder
    easyCorrect?: SortOrder
    easyTotal?: SortOrder
    mediumCorrect?: SortOrder
    mediumTotal?: SortOrder
    hardCorrect?: SortOrder
    hardTotal?: SortOrder
    accuracy?: SortOrder
    speedScore?: SortOrder
    consistencyScore?: SortOrder
    difficultyScore?: SortOrder
    percentile?: SortOrder
    rank?: SortOrder
    improvement?: SortOrder
  }

  export type ExamScoreMaxOrderByAggregateInput = {
    id?: SortOrder
    attemptId?: SortOrder
    examId?: SortOrder
    userId?: SortOrder
    totalMarks?: SortOrder
    maxMarks?: SortOrder
    percentage?: SortOrder
    grade?: SortOrder
    correctAnswers?: SortOrder
    wrongAnswers?: SortOrder
    unanswered?: SortOrder
    totalQuestions?: SortOrder
    totalTimeSpent?: SortOrder
    averageTimePerQuestion?: SortOrder
    timeEfficiency?: SortOrder
    easyCorrect?: SortOrder
    easyTotal?: SortOrder
    mediumCorrect?: SortOrder
    mediumTotal?: SortOrder
    hardCorrect?: SortOrder
    hardTotal?: SortOrder
    accuracy?: SortOrder
    speedScore?: SortOrder
    consistencyScore?: SortOrder
    difficultyScore?: SortOrder
    percentile?: SortOrder
    rank?: SortOrder
    improvement?: SortOrder
    calculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamScoreMinOrderByAggregateInput = {
    id?: SortOrder
    attemptId?: SortOrder
    examId?: SortOrder
    userId?: SortOrder
    totalMarks?: SortOrder
    maxMarks?: SortOrder
    percentage?: SortOrder
    grade?: SortOrder
    correctAnswers?: SortOrder
    wrongAnswers?: SortOrder
    unanswered?: SortOrder
    totalQuestions?: SortOrder
    totalTimeSpent?: SortOrder
    averageTimePerQuestion?: SortOrder
    timeEfficiency?: SortOrder
    easyCorrect?: SortOrder
    easyTotal?: SortOrder
    mediumCorrect?: SortOrder
    mediumTotal?: SortOrder
    hardCorrect?: SortOrder
    hardTotal?: SortOrder
    accuracy?: SortOrder
    speedScore?: SortOrder
    consistencyScore?: SortOrder
    difficultyScore?: SortOrder
    percentile?: SortOrder
    rank?: SortOrder
    improvement?: SortOrder
    calculatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamScoreSumOrderByAggregateInput = {
    totalMarks?: SortOrder
    maxMarks?: SortOrder
    percentage?: SortOrder
    correctAnswers?: SortOrder
    wrongAnswers?: SortOrder
    unanswered?: SortOrder
    totalQuestions?: SortOrder
    totalTimeSpent?: SortOrder
    averageTimePerQuestion?: SortOrder
    timeEfficiency?: SortOrder
    easyCorrect?: SortOrder
    easyTotal?: SortOrder
    mediumCorrect?: SortOrder
    mediumTotal?: SortOrder
    hardCorrect?: SortOrder
    hardTotal?: SortOrder
    accuracy?: SortOrder
    speedScore?: SortOrder
    consistencyScore?: SortOrder
    difficultyScore?: SortOrder
    percentile?: SortOrder
    rank?: SortOrder
    improvement?: SortOrder
  }

  export type ExamCategoryNullableScalarRelationFilter = {
    is?: ExamCategoryWhereInput | null
    isNot?: ExamCategoryWhereInput | null
  }

  export type UserPerformanceUserIdExamCategoryIdCompoundUniqueInput = {
    userId: string
    examCategoryId: string
  }

  export type UserPerformanceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    examCategoryId?: SortOrder
    totalAttempts?: SortOrder
    totalPassed?: SortOrder
    totalFailed?: SortOrder
    passRate?: SortOrder
    averageScore?: SortOrder
    highestScore?: SortOrder
    lowestScore?: SortOrder
    totalMarks?: SortOrder
    totalTimeSpent?: SortOrder
    averageTimePerExam?: SortOrder
    easyAccuracy?: SortOrder
    mediumAccuracy?: SortOrder
    hardAccuracy?: SortOrder
    improvementRate?: SortOrder
    consistencyScore?: SortOrder
    learningCurve?: SortOrder
    lastAttemptAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPerformanceAvgOrderByAggregateInput = {
    totalAttempts?: SortOrder
    totalPassed?: SortOrder
    totalFailed?: SortOrder
    passRate?: SortOrder
    averageScore?: SortOrder
    highestScore?: SortOrder
    lowestScore?: SortOrder
    totalMarks?: SortOrder
    totalTimeSpent?: SortOrder
    averageTimePerExam?: SortOrder
    easyAccuracy?: SortOrder
    mediumAccuracy?: SortOrder
    hardAccuracy?: SortOrder
    improvementRate?: SortOrder
    consistencyScore?: SortOrder
    learningCurve?: SortOrder
  }

  export type UserPerformanceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    examCategoryId?: SortOrder
    totalAttempts?: SortOrder
    totalPassed?: SortOrder
    totalFailed?: SortOrder
    passRate?: SortOrder
    averageScore?: SortOrder
    highestScore?: SortOrder
    lowestScore?: SortOrder
    totalMarks?: SortOrder
    totalTimeSpent?: SortOrder
    averageTimePerExam?: SortOrder
    easyAccuracy?: SortOrder
    mediumAccuracy?: SortOrder
    hardAccuracy?: SortOrder
    improvementRate?: SortOrder
    consistencyScore?: SortOrder
    learningCurve?: SortOrder
    lastAttemptAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPerformanceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    examCategoryId?: SortOrder
    totalAttempts?: SortOrder
    totalPassed?: SortOrder
    totalFailed?: SortOrder
    passRate?: SortOrder
    averageScore?: SortOrder
    highestScore?: SortOrder
    lowestScore?: SortOrder
    totalMarks?: SortOrder
    totalTimeSpent?: SortOrder
    averageTimePerExam?: SortOrder
    easyAccuracy?: SortOrder
    mediumAccuracy?: SortOrder
    hardAccuracy?: SortOrder
    improvementRate?: SortOrder
    consistencyScore?: SortOrder
    learningCurve?: SortOrder
    lastAttemptAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPerformanceSumOrderByAggregateInput = {
    totalAttempts?: SortOrder
    totalPassed?: SortOrder
    totalFailed?: SortOrder
    passRate?: SortOrder
    averageScore?: SortOrder
    highestScore?: SortOrder
    lowestScore?: SortOrder
    totalMarks?: SortOrder
    totalTimeSpent?: SortOrder
    averageTimePerExam?: SortOrder
    easyAccuracy?: SortOrder
    mediumAccuracy?: SortOrder
    hardAccuracy?: SortOrder
    improvementRate?: SortOrder
    consistencyScore?: SortOrder
    learningCurve?: SortOrder
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    stripePaymentId?: SortOrder
    stripeRefundId?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    refundedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    stripePaymentId?: SortOrder
    stripeRefundId?: SortOrder
    description?: SortOrder
    refundedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    stripePaymentId?: SortOrder
    stripeRefundId?: SortOrder
    description?: SortOrder
    refundedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type CertificateCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    examId?: SortOrder
    attemptId?: SortOrder
    certificateNumber?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    isRevoked?: SortOrder
    revokedAt?: SortOrder
    revokedBy?: SortOrder
    revokedReason?: SortOrder
    pdfUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CertificateMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    examId?: SortOrder
    attemptId?: SortOrder
    certificateNumber?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    isRevoked?: SortOrder
    revokedAt?: SortOrder
    revokedBy?: SortOrder
    revokedReason?: SortOrder
    pdfUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CertificateMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    examId?: SortOrder
    attemptId?: SortOrder
    certificateNumber?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    isRevoked?: SortOrder
    revokedAt?: SortOrder
    revokedBy?: SortOrder
    revokedReason?: SortOrder
    pdfUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type StudyGroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isPrivate?: SortOrder
    maxMembers?: SortOrder
    createdBy?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudyGroupAvgOrderByAggregateInput = {
    maxMembers?: SortOrder
  }

  export type StudyGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isPrivate?: SortOrder
    maxMembers?: SortOrder
    createdBy?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudyGroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isPrivate?: SortOrder
    maxMembers?: SortOrder
    createdBy?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudyGroupSumOrderByAggregateInput = {
    maxMembers?: SortOrder
  }

  export type EnumGroupRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupRole | EnumGroupRoleFieldRefInput<$PrismaModel>
    in?: $Enums.GroupRole[] | ListEnumGroupRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.GroupRole[] | ListEnumGroupRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupRoleFilter<$PrismaModel> | $Enums.GroupRole
  }

  export type StudyGroupScalarRelationFilter = {
    is?: StudyGroupWhereInput
    isNot?: StudyGroupWhereInput
  }

  export type StudyGroupMemberGroupIdUserIdCompoundUniqueInput = {
    groupId: string
    userId: string
  }

  export type StudyGroupMemberCountOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    isActive?: SortOrder
  }

  export type StudyGroupMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    isActive?: SortOrder
  }

  export type StudyGroupMemberMinOrderByAggregateInput = {
    id?: SortOrder
    groupId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    isActive?: SortOrder
  }

  export type EnumGroupRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupRole | EnumGroupRoleFieldRefInput<$PrismaModel>
    in?: $Enums.GroupRole[] | ListEnumGroupRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.GroupRole[] | ListEnumGroupRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupRoleWithAggregatesFilter<$PrismaModel> | $Enums.GroupRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGroupRoleFilter<$PrismaModel>
    _max?: NestedEnumGroupRoleFilter<$PrismaModel>
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumAccessLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessLevel | EnumAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessLevelFilter<$PrismaModel> | $Enums.AccessLevel
  }

  export type ExamCategoryUserExamCategoryIdUserIdCompoundUniqueInput = {
    examCategoryId: string
    userId: string
  }

  export type ExamCategoryUserCountOrderByAggregateInput = {
    id?: SortOrder
    examCategoryId?: SortOrder
    userId?: SortOrder
    accessLevel?: SortOrder
    grantedAt?: SortOrder
    grantedBy?: SortOrder
  }

  export type ExamCategoryUserMaxOrderByAggregateInput = {
    id?: SortOrder
    examCategoryId?: SortOrder
    userId?: SortOrder
    accessLevel?: SortOrder
    grantedAt?: SortOrder
    grantedBy?: SortOrder
  }

  export type ExamCategoryUserMinOrderByAggregateInput = {
    id?: SortOrder
    examCategoryId?: SortOrder
    userId?: SortOrder
    accessLevel?: SortOrder
    grantedAt?: SortOrder
    grantedBy?: SortOrder
  }

  export type EnumAccessLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessLevel | EnumAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessLevelWithAggregatesFilter<$PrismaModel> | $Enums.AccessLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccessLevelFilter<$PrismaModel>
    _max?: NestedEnumAccessLevelFilter<$PrismaModel>
  }

  export type ExamStatisticsViewCountOrderByAggregateInput = {
    examId?: SortOrder
    examTitle?: SortOrder
    totalAttempts?: SortOrder
    totalBookings?: SortOrder
    totalRevenue?: SortOrder
    averageScore?: SortOrder
    passRate?: SortOrder
    averageTime?: SortOrder
    lastAttemptDate?: SortOrder
  }

  export type ExamStatisticsViewAvgOrderByAggregateInput = {
    totalAttempts?: SortOrder
    totalBookings?: SortOrder
    totalRevenue?: SortOrder
    averageScore?: SortOrder
    passRate?: SortOrder
    averageTime?: SortOrder
  }

  export type ExamStatisticsViewMaxOrderByAggregateInput = {
    examId?: SortOrder
    examTitle?: SortOrder
    totalAttempts?: SortOrder
    totalBookings?: SortOrder
    totalRevenue?: SortOrder
    averageScore?: SortOrder
    passRate?: SortOrder
    averageTime?: SortOrder
    lastAttemptDate?: SortOrder
  }

  export type ExamStatisticsViewMinOrderByAggregateInput = {
    examId?: SortOrder
    examTitle?: SortOrder
    totalAttempts?: SortOrder
    totalBookings?: SortOrder
    totalRevenue?: SortOrder
    averageScore?: SortOrder
    passRate?: SortOrder
    averageTime?: SortOrder
    lastAttemptDate?: SortOrder
  }

  export type ExamStatisticsViewSumOrderByAggregateInput = {
    totalAttempts?: SortOrder
    totalBookings?: SortOrder
    totalRevenue?: SortOrder
    averageScore?: SortOrder
    passRate?: SortOrder
    averageTime?: SortOrder
  }

  export type UserPerformanceViewCountOrderByAggregateInput = {
    userId?: SortOrder
    userEmail?: SortOrder
    totalExamsTaken?: SortOrder
    totalExamsPassed?: SortOrder
    averageScore?: SortOrder
    totalTimeSpent?: SortOrder
    certificatesEarned?: SortOrder
    lastExamDate?: SortOrder
  }

  export type UserPerformanceViewAvgOrderByAggregateInput = {
    totalExamsTaken?: SortOrder
    totalExamsPassed?: SortOrder
    averageScore?: SortOrder
    totalTimeSpent?: SortOrder
    certificatesEarned?: SortOrder
  }

  export type UserPerformanceViewMaxOrderByAggregateInput = {
    userId?: SortOrder
    userEmail?: SortOrder
    totalExamsTaken?: SortOrder
    totalExamsPassed?: SortOrder
    averageScore?: SortOrder
    totalTimeSpent?: SortOrder
    certificatesEarned?: SortOrder
    lastExamDate?: SortOrder
  }

  export type UserPerformanceViewMinOrderByAggregateInput = {
    userId?: SortOrder
    userEmail?: SortOrder
    totalExamsTaken?: SortOrder
    totalExamsPassed?: SortOrder
    averageScore?: SortOrder
    totalTimeSpent?: SortOrder
    certificatesEarned?: SortOrder
    lastExamDate?: SortOrder
  }

  export type UserPerformanceViewSumOrderByAggregateInput = {
    totalExamsTaken?: SortOrder
    totalExamsPassed?: SortOrder
    averageScore?: SortOrder
    totalTimeSpent?: SortOrder
    certificatesEarned?: SortOrder
  }

  export type QuestionAnalyticsViewCountOrderByAggregateInput = {
    questionId?: SortOrder
    questionText?: SortOrder
    usageCount?: SortOrder
    correctAnswerRate?: SortOrder
    averageTime?: SortOrder
    difficulty?: SortOrder
    examCategoryName?: SortOrder
  }

  export type QuestionAnalyticsViewAvgOrderByAggregateInput = {
    usageCount?: SortOrder
    correctAnswerRate?: SortOrder
    averageTime?: SortOrder
  }

  export type QuestionAnalyticsViewMaxOrderByAggregateInput = {
    questionId?: SortOrder
    questionText?: SortOrder
    usageCount?: SortOrder
    correctAnswerRate?: SortOrder
    averageTime?: SortOrder
    difficulty?: SortOrder
    examCategoryName?: SortOrder
  }

  export type QuestionAnalyticsViewMinOrderByAggregateInput = {
    questionId?: SortOrder
    questionText?: SortOrder
    usageCount?: SortOrder
    correctAnswerRate?: SortOrder
    averageTime?: SortOrder
    difficulty?: SortOrder
    examCategoryName?: SortOrder
  }

  export type QuestionAnalyticsViewSumOrderByAggregateInput = {
    usageCount?: SortOrder
    correctAnswerRate?: SortOrder
    averageTime?: SortOrder
  }

  export type RevenueAnalyticsViewCountOrderByAggregateInput = {
    date?: SortOrder
    totalRevenue?: SortOrder
    totalTransactions?: SortOrder
    averageTransactionValue?: SortOrder
    topExamCategory?: SortOrder
    topExam?: SortOrder
  }

  export type RevenueAnalyticsViewAvgOrderByAggregateInput = {
    totalRevenue?: SortOrder
    totalTransactions?: SortOrder
    averageTransactionValue?: SortOrder
  }

  export type RevenueAnalyticsViewMaxOrderByAggregateInput = {
    date?: SortOrder
    totalRevenue?: SortOrder
    totalTransactions?: SortOrder
    averageTransactionValue?: SortOrder
    topExamCategory?: SortOrder
    topExam?: SortOrder
  }

  export type RevenueAnalyticsViewMinOrderByAggregateInput = {
    date?: SortOrder
    totalRevenue?: SortOrder
    totalTransactions?: SortOrder
    averageTransactionValue?: SortOrder
    topExamCategory?: SortOrder
    topExam?: SortOrder
  }

  export type RevenueAnalyticsViewSumOrderByAggregateInput = {
    totalRevenue?: SortOrder
    totalTransactions?: SortOrder
    averageTransactionValue?: SortOrder
  }

  export type ExamBookingCreateNestedManyWithoutUserInput = {
    create?: XOR<ExamBookingCreateWithoutUserInput, ExamBookingUncheckedCreateWithoutUserInput> | ExamBookingCreateWithoutUserInput[] | ExamBookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExamBookingCreateOrConnectWithoutUserInput | ExamBookingCreateOrConnectWithoutUserInput[]
    createMany?: ExamBookingCreateManyUserInputEnvelope
    connect?: ExamBookingWhereUniqueInput | ExamBookingWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ExamAttemptCreateNestedManyWithoutUserInput = {
    create?: XOR<ExamAttemptCreateWithoutUserInput, ExamAttemptUncheckedCreateWithoutUserInput> | ExamAttemptCreateWithoutUserInput[] | ExamAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutUserInput | ExamAttemptCreateOrConnectWithoutUserInput[]
    createMany?: ExamAttemptCreateManyUserInputEnvelope
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
  }

  export type QuestionResponseCreateNestedManyWithoutUserInput = {
    create?: XOR<QuestionResponseCreateWithoutUserInput, QuestionResponseUncheckedCreateWithoutUserInput> | QuestionResponseCreateWithoutUserInput[] | QuestionResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuestionResponseCreateOrConnectWithoutUserInput | QuestionResponseCreateOrConnectWithoutUserInput[]
    createMany?: QuestionResponseCreateManyUserInputEnvelope
    connect?: QuestionResponseWhereUniqueInput | QuestionResponseWhereUniqueInput[]
  }

  export type QuestionScoreCreateNestedManyWithoutUserInput = {
    create?: XOR<QuestionScoreCreateWithoutUserInput, QuestionScoreUncheckedCreateWithoutUserInput> | QuestionScoreCreateWithoutUserInput[] | QuestionScoreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuestionScoreCreateOrConnectWithoutUserInput | QuestionScoreCreateOrConnectWithoutUserInput[]
    createMany?: QuestionScoreCreateManyUserInputEnvelope
    connect?: QuestionScoreWhereUniqueInput | QuestionScoreWhereUniqueInput[]
  }

  export type ExamScoreCreateNestedManyWithoutUserInput = {
    create?: XOR<ExamScoreCreateWithoutUserInput, ExamScoreUncheckedCreateWithoutUserInput> | ExamScoreCreateWithoutUserInput[] | ExamScoreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExamScoreCreateOrConnectWithoutUserInput | ExamScoreCreateOrConnectWithoutUserInput[]
    createMany?: ExamScoreCreateManyUserInputEnvelope
    connect?: ExamScoreWhereUniqueInput | ExamScoreWhereUniqueInput[]
  }

  export type UserPerformanceCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPerformanceCreateWithoutUserInput, UserPerformanceUncheckedCreateWithoutUserInput> | UserPerformanceCreateWithoutUserInput[] | UserPerformanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPerformanceCreateOrConnectWithoutUserInput | UserPerformanceCreateOrConnectWithoutUserInput[]
    createMany?: UserPerformanceCreateManyUserInputEnvelope
    connect?: UserPerformanceWhereUniqueInput | UserPerformanceWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type UserSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type ExamCategoryUserCreateNestedManyWithoutUserInput = {
    create?: XOR<ExamCategoryUserCreateWithoutUserInput, ExamCategoryUserUncheckedCreateWithoutUserInput> | ExamCategoryUserCreateWithoutUserInput[] | ExamCategoryUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExamCategoryUserCreateOrConnectWithoutUserInput | ExamCategoryUserCreateOrConnectWithoutUserInput[]
    createMany?: ExamCategoryUserCreateManyUserInputEnvelope
    connect?: ExamCategoryUserWhereUniqueInput | ExamCategoryUserWhereUniqueInput[]
  }

  export type StudyGroupMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<StudyGroupMemberCreateWithoutUserInput, StudyGroupMemberUncheckedCreateWithoutUserInput> | StudyGroupMemberCreateWithoutUserInput[] | StudyGroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudyGroupMemberCreateOrConnectWithoutUserInput | StudyGroupMemberCreateOrConnectWithoutUserInput[]
    createMany?: StudyGroupMemberCreateManyUserInputEnvelope
    connect?: StudyGroupMemberWhereUniqueInput | StudyGroupMemberWhereUniqueInput[]
  }

  export type CertificateCreateNestedManyWithoutUserInput = {
    create?: XOR<CertificateCreateWithoutUserInput, CertificateUncheckedCreateWithoutUserInput> | CertificateCreateWithoutUserInput[] | CertificateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutUserInput | CertificateCreateOrConnectWithoutUserInput[]
    createMany?: CertificateCreateManyUserInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type ExamCategoryUserCreateNestedManyWithoutGranterInput = {
    create?: XOR<ExamCategoryUserCreateWithoutGranterInput, ExamCategoryUserUncheckedCreateWithoutGranterInput> | ExamCategoryUserCreateWithoutGranterInput[] | ExamCategoryUserUncheckedCreateWithoutGranterInput[]
    connectOrCreate?: ExamCategoryUserCreateOrConnectWithoutGranterInput | ExamCategoryUserCreateOrConnectWithoutGranterInput[]
    createMany?: ExamCategoryUserCreateManyGranterInputEnvelope
    connect?: ExamCategoryUserWhereUniqueInput | ExamCategoryUserWhereUniqueInput[]
  }

  export type StudyGroupCreateNestedManyWithoutCreatorInput = {
    create?: XOR<StudyGroupCreateWithoutCreatorInput, StudyGroupUncheckedCreateWithoutCreatorInput> | StudyGroupCreateWithoutCreatorInput[] | StudyGroupUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: StudyGroupCreateOrConnectWithoutCreatorInput | StudyGroupCreateOrConnectWithoutCreatorInput[]
    createMany?: StudyGroupCreateManyCreatorInputEnvelope
    connect?: StudyGroupWhereUniqueInput | StudyGroupWhereUniqueInput[]
  }

  export type QuestionCreateNestedManyWithoutCreatorInput = {
    create?: XOR<QuestionCreateWithoutCreatorInput, QuestionUncheckedCreateWithoutCreatorInput> | QuestionCreateWithoutCreatorInput[] | QuestionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutCreatorInput | QuestionCreateOrConnectWithoutCreatorInput[]
    createMany?: QuestionCreateManyCreatorInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type QuestionCreateNestedManyWithoutApproverInput = {
    create?: XOR<QuestionCreateWithoutApproverInput, QuestionUncheckedCreateWithoutApproverInput> | QuestionCreateWithoutApproverInput[] | QuestionUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutApproverInput | QuestionCreateOrConnectWithoutApproverInput[]
    createMany?: QuestionCreateManyApproverInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type ExamCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ExamCreateWithoutCreatorInput, ExamUncheckedCreateWithoutCreatorInput> | ExamCreateWithoutCreatorInput[] | ExamUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutCreatorInput | ExamCreateOrConnectWithoutCreatorInput[]
    createMany?: ExamCreateManyCreatorInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type ExamCreateNestedManyWithoutApproverInput = {
    create?: XOR<ExamCreateWithoutApproverInput, ExamUncheckedCreateWithoutApproverInput> | ExamCreateWithoutApproverInput[] | ExamUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutApproverInput | ExamCreateOrConnectWithoutApproverInput[]
    createMany?: ExamCreateManyApproverInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type CertificateCreateNestedManyWithoutRevokerInput = {
    create?: XOR<CertificateCreateWithoutRevokerInput, CertificateUncheckedCreateWithoutRevokerInput> | CertificateCreateWithoutRevokerInput[] | CertificateUncheckedCreateWithoutRevokerInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutRevokerInput | CertificateCreateOrConnectWithoutRevokerInput[]
    createMany?: CertificateCreateManyRevokerInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type ExamBookingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ExamBookingCreateWithoutUserInput, ExamBookingUncheckedCreateWithoutUserInput> | ExamBookingCreateWithoutUserInput[] | ExamBookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExamBookingCreateOrConnectWithoutUserInput | ExamBookingCreateOrConnectWithoutUserInput[]
    createMany?: ExamBookingCreateManyUserInputEnvelope
    connect?: ExamBookingWhereUniqueInput | ExamBookingWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ExamAttemptUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ExamAttemptCreateWithoutUserInput, ExamAttemptUncheckedCreateWithoutUserInput> | ExamAttemptCreateWithoutUserInput[] | ExamAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutUserInput | ExamAttemptCreateOrConnectWithoutUserInput[]
    createMany?: ExamAttemptCreateManyUserInputEnvelope
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
  }

  export type QuestionResponseUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<QuestionResponseCreateWithoutUserInput, QuestionResponseUncheckedCreateWithoutUserInput> | QuestionResponseCreateWithoutUserInput[] | QuestionResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuestionResponseCreateOrConnectWithoutUserInput | QuestionResponseCreateOrConnectWithoutUserInput[]
    createMany?: QuestionResponseCreateManyUserInputEnvelope
    connect?: QuestionResponseWhereUniqueInput | QuestionResponseWhereUniqueInput[]
  }

  export type QuestionScoreUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<QuestionScoreCreateWithoutUserInput, QuestionScoreUncheckedCreateWithoutUserInput> | QuestionScoreCreateWithoutUserInput[] | QuestionScoreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuestionScoreCreateOrConnectWithoutUserInput | QuestionScoreCreateOrConnectWithoutUserInput[]
    createMany?: QuestionScoreCreateManyUserInputEnvelope
    connect?: QuestionScoreWhereUniqueInput | QuestionScoreWhereUniqueInput[]
  }

  export type ExamScoreUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ExamScoreCreateWithoutUserInput, ExamScoreUncheckedCreateWithoutUserInput> | ExamScoreCreateWithoutUserInput[] | ExamScoreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExamScoreCreateOrConnectWithoutUserInput | ExamScoreCreateOrConnectWithoutUserInput[]
    createMany?: ExamScoreCreateManyUserInputEnvelope
    connect?: ExamScoreWhereUniqueInput | ExamScoreWhereUniqueInput[]
  }

  export type UserPerformanceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPerformanceCreateWithoutUserInput, UserPerformanceUncheckedCreateWithoutUserInput> | UserPerformanceCreateWithoutUserInput[] | UserPerformanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPerformanceCreateOrConnectWithoutUserInput | UserPerformanceCreateOrConnectWithoutUserInput[]
    createMany?: UserPerformanceCreateManyUserInputEnvelope
    connect?: UserPerformanceWhereUniqueInput | UserPerformanceWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type UserSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type ExamCategoryUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ExamCategoryUserCreateWithoutUserInput, ExamCategoryUserUncheckedCreateWithoutUserInput> | ExamCategoryUserCreateWithoutUserInput[] | ExamCategoryUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExamCategoryUserCreateOrConnectWithoutUserInput | ExamCategoryUserCreateOrConnectWithoutUserInput[]
    createMany?: ExamCategoryUserCreateManyUserInputEnvelope
    connect?: ExamCategoryUserWhereUniqueInput | ExamCategoryUserWhereUniqueInput[]
  }

  export type StudyGroupMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<StudyGroupMemberCreateWithoutUserInput, StudyGroupMemberUncheckedCreateWithoutUserInput> | StudyGroupMemberCreateWithoutUserInput[] | StudyGroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudyGroupMemberCreateOrConnectWithoutUserInput | StudyGroupMemberCreateOrConnectWithoutUserInput[]
    createMany?: StudyGroupMemberCreateManyUserInputEnvelope
    connect?: StudyGroupMemberWhereUniqueInput | StudyGroupMemberWhereUniqueInput[]
  }

  export type CertificateUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CertificateCreateWithoutUserInput, CertificateUncheckedCreateWithoutUserInput> | CertificateCreateWithoutUserInput[] | CertificateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutUserInput | CertificateCreateOrConnectWithoutUserInput[]
    createMany?: CertificateCreateManyUserInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type ExamCategoryUserUncheckedCreateNestedManyWithoutGranterInput = {
    create?: XOR<ExamCategoryUserCreateWithoutGranterInput, ExamCategoryUserUncheckedCreateWithoutGranterInput> | ExamCategoryUserCreateWithoutGranterInput[] | ExamCategoryUserUncheckedCreateWithoutGranterInput[]
    connectOrCreate?: ExamCategoryUserCreateOrConnectWithoutGranterInput | ExamCategoryUserCreateOrConnectWithoutGranterInput[]
    createMany?: ExamCategoryUserCreateManyGranterInputEnvelope
    connect?: ExamCategoryUserWhereUniqueInput | ExamCategoryUserWhereUniqueInput[]
  }

  export type StudyGroupUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<StudyGroupCreateWithoutCreatorInput, StudyGroupUncheckedCreateWithoutCreatorInput> | StudyGroupCreateWithoutCreatorInput[] | StudyGroupUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: StudyGroupCreateOrConnectWithoutCreatorInput | StudyGroupCreateOrConnectWithoutCreatorInput[]
    createMany?: StudyGroupCreateManyCreatorInputEnvelope
    connect?: StudyGroupWhereUniqueInput | StudyGroupWhereUniqueInput[]
  }

  export type QuestionUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<QuestionCreateWithoutCreatorInput, QuestionUncheckedCreateWithoutCreatorInput> | QuestionCreateWithoutCreatorInput[] | QuestionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutCreatorInput | QuestionCreateOrConnectWithoutCreatorInput[]
    createMany?: QuestionCreateManyCreatorInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type QuestionUncheckedCreateNestedManyWithoutApproverInput = {
    create?: XOR<QuestionCreateWithoutApproverInput, QuestionUncheckedCreateWithoutApproverInput> | QuestionCreateWithoutApproverInput[] | QuestionUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutApproverInput | QuestionCreateOrConnectWithoutApproverInput[]
    createMany?: QuestionCreateManyApproverInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type ExamUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ExamCreateWithoutCreatorInput, ExamUncheckedCreateWithoutCreatorInput> | ExamCreateWithoutCreatorInput[] | ExamUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutCreatorInput | ExamCreateOrConnectWithoutCreatorInput[]
    createMany?: ExamCreateManyCreatorInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type ExamUncheckedCreateNestedManyWithoutApproverInput = {
    create?: XOR<ExamCreateWithoutApproverInput, ExamUncheckedCreateWithoutApproverInput> | ExamCreateWithoutApproverInput[] | ExamUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutApproverInput | ExamCreateOrConnectWithoutApproverInput[]
    createMany?: ExamCreateManyApproverInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type CertificateUncheckedCreateNestedManyWithoutRevokerInput = {
    create?: XOR<CertificateCreateWithoutRevokerInput, CertificateUncheckedCreateWithoutRevokerInput> | CertificateCreateWithoutRevokerInput[] | CertificateUncheckedCreateWithoutRevokerInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutRevokerInput | CertificateCreateOrConnectWithoutRevokerInput[]
    createMany?: CertificateCreateManyRevokerInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableEnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ExamBookingUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExamBookingCreateWithoutUserInput, ExamBookingUncheckedCreateWithoutUserInput> | ExamBookingCreateWithoutUserInput[] | ExamBookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExamBookingCreateOrConnectWithoutUserInput | ExamBookingCreateOrConnectWithoutUserInput[]
    upsert?: ExamBookingUpsertWithWhereUniqueWithoutUserInput | ExamBookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExamBookingCreateManyUserInputEnvelope
    set?: ExamBookingWhereUniqueInput | ExamBookingWhereUniqueInput[]
    disconnect?: ExamBookingWhereUniqueInput | ExamBookingWhereUniqueInput[]
    delete?: ExamBookingWhereUniqueInput | ExamBookingWhereUniqueInput[]
    connect?: ExamBookingWhereUniqueInput | ExamBookingWhereUniqueInput[]
    update?: ExamBookingUpdateWithWhereUniqueWithoutUserInput | ExamBookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExamBookingUpdateManyWithWhereWithoutUserInput | ExamBookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExamBookingScalarWhereInput | ExamBookingScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ExamAttemptUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExamAttemptCreateWithoutUserInput, ExamAttemptUncheckedCreateWithoutUserInput> | ExamAttemptCreateWithoutUserInput[] | ExamAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutUserInput | ExamAttemptCreateOrConnectWithoutUserInput[]
    upsert?: ExamAttemptUpsertWithWhereUniqueWithoutUserInput | ExamAttemptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExamAttemptCreateManyUserInputEnvelope
    set?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    disconnect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    delete?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    update?: ExamAttemptUpdateWithWhereUniqueWithoutUserInput | ExamAttemptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExamAttemptUpdateManyWithWhereWithoutUserInput | ExamAttemptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExamAttemptScalarWhereInput | ExamAttemptScalarWhereInput[]
  }

  export type QuestionResponseUpdateManyWithoutUserNestedInput = {
    create?: XOR<QuestionResponseCreateWithoutUserInput, QuestionResponseUncheckedCreateWithoutUserInput> | QuestionResponseCreateWithoutUserInput[] | QuestionResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuestionResponseCreateOrConnectWithoutUserInput | QuestionResponseCreateOrConnectWithoutUserInput[]
    upsert?: QuestionResponseUpsertWithWhereUniqueWithoutUserInput | QuestionResponseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QuestionResponseCreateManyUserInputEnvelope
    set?: QuestionResponseWhereUniqueInput | QuestionResponseWhereUniqueInput[]
    disconnect?: QuestionResponseWhereUniqueInput | QuestionResponseWhereUniqueInput[]
    delete?: QuestionResponseWhereUniqueInput | QuestionResponseWhereUniqueInput[]
    connect?: QuestionResponseWhereUniqueInput | QuestionResponseWhereUniqueInput[]
    update?: QuestionResponseUpdateWithWhereUniqueWithoutUserInput | QuestionResponseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QuestionResponseUpdateManyWithWhereWithoutUserInput | QuestionResponseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QuestionResponseScalarWhereInput | QuestionResponseScalarWhereInput[]
  }

  export type QuestionScoreUpdateManyWithoutUserNestedInput = {
    create?: XOR<QuestionScoreCreateWithoutUserInput, QuestionScoreUncheckedCreateWithoutUserInput> | QuestionScoreCreateWithoutUserInput[] | QuestionScoreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuestionScoreCreateOrConnectWithoutUserInput | QuestionScoreCreateOrConnectWithoutUserInput[]
    upsert?: QuestionScoreUpsertWithWhereUniqueWithoutUserInput | QuestionScoreUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QuestionScoreCreateManyUserInputEnvelope
    set?: QuestionScoreWhereUniqueInput | QuestionScoreWhereUniqueInput[]
    disconnect?: QuestionScoreWhereUniqueInput | QuestionScoreWhereUniqueInput[]
    delete?: QuestionScoreWhereUniqueInput | QuestionScoreWhereUniqueInput[]
    connect?: QuestionScoreWhereUniqueInput | QuestionScoreWhereUniqueInput[]
    update?: QuestionScoreUpdateWithWhereUniqueWithoutUserInput | QuestionScoreUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QuestionScoreUpdateManyWithWhereWithoutUserInput | QuestionScoreUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QuestionScoreScalarWhereInput | QuestionScoreScalarWhereInput[]
  }

  export type ExamScoreUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExamScoreCreateWithoutUserInput, ExamScoreUncheckedCreateWithoutUserInput> | ExamScoreCreateWithoutUserInput[] | ExamScoreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExamScoreCreateOrConnectWithoutUserInput | ExamScoreCreateOrConnectWithoutUserInput[]
    upsert?: ExamScoreUpsertWithWhereUniqueWithoutUserInput | ExamScoreUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExamScoreCreateManyUserInputEnvelope
    set?: ExamScoreWhereUniqueInput | ExamScoreWhereUniqueInput[]
    disconnect?: ExamScoreWhereUniqueInput | ExamScoreWhereUniqueInput[]
    delete?: ExamScoreWhereUniqueInput | ExamScoreWhereUniqueInput[]
    connect?: ExamScoreWhereUniqueInput | ExamScoreWhereUniqueInput[]
    update?: ExamScoreUpdateWithWhereUniqueWithoutUserInput | ExamScoreUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExamScoreUpdateManyWithWhereWithoutUserInput | ExamScoreUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExamScoreScalarWhereInput | ExamScoreScalarWhereInput[]
  }

  export type UserPerformanceUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPerformanceCreateWithoutUserInput, UserPerformanceUncheckedCreateWithoutUserInput> | UserPerformanceCreateWithoutUserInput[] | UserPerformanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPerformanceCreateOrConnectWithoutUserInput | UserPerformanceCreateOrConnectWithoutUserInput[]
    upsert?: UserPerformanceUpsertWithWhereUniqueWithoutUserInput | UserPerformanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPerformanceCreateManyUserInputEnvelope
    set?: UserPerformanceWhereUniqueInput | UserPerformanceWhereUniqueInput[]
    disconnect?: UserPerformanceWhereUniqueInput | UserPerformanceWhereUniqueInput[]
    delete?: UserPerformanceWhereUniqueInput | UserPerformanceWhereUniqueInput[]
    connect?: UserPerformanceWhereUniqueInput | UserPerformanceWhereUniqueInput[]
    update?: UserPerformanceUpdateWithWhereUniqueWithoutUserInput | UserPerformanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPerformanceUpdateManyWithWhereWithoutUserInput | UserPerformanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPerformanceScalarWhereInput | UserPerformanceScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type UserSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type ExamCategoryUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExamCategoryUserCreateWithoutUserInput, ExamCategoryUserUncheckedCreateWithoutUserInput> | ExamCategoryUserCreateWithoutUserInput[] | ExamCategoryUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExamCategoryUserCreateOrConnectWithoutUserInput | ExamCategoryUserCreateOrConnectWithoutUserInput[]
    upsert?: ExamCategoryUserUpsertWithWhereUniqueWithoutUserInput | ExamCategoryUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExamCategoryUserCreateManyUserInputEnvelope
    set?: ExamCategoryUserWhereUniqueInput | ExamCategoryUserWhereUniqueInput[]
    disconnect?: ExamCategoryUserWhereUniqueInput | ExamCategoryUserWhereUniqueInput[]
    delete?: ExamCategoryUserWhereUniqueInput | ExamCategoryUserWhereUniqueInput[]
    connect?: ExamCategoryUserWhereUniqueInput | ExamCategoryUserWhereUniqueInput[]
    update?: ExamCategoryUserUpdateWithWhereUniqueWithoutUserInput | ExamCategoryUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExamCategoryUserUpdateManyWithWhereWithoutUserInput | ExamCategoryUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExamCategoryUserScalarWhereInput | ExamCategoryUserScalarWhereInput[]
  }

  export type StudyGroupMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<StudyGroupMemberCreateWithoutUserInput, StudyGroupMemberUncheckedCreateWithoutUserInput> | StudyGroupMemberCreateWithoutUserInput[] | StudyGroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudyGroupMemberCreateOrConnectWithoutUserInput | StudyGroupMemberCreateOrConnectWithoutUserInput[]
    upsert?: StudyGroupMemberUpsertWithWhereUniqueWithoutUserInput | StudyGroupMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StudyGroupMemberCreateManyUserInputEnvelope
    set?: StudyGroupMemberWhereUniqueInput | StudyGroupMemberWhereUniqueInput[]
    disconnect?: StudyGroupMemberWhereUniqueInput | StudyGroupMemberWhereUniqueInput[]
    delete?: StudyGroupMemberWhereUniqueInput | StudyGroupMemberWhereUniqueInput[]
    connect?: StudyGroupMemberWhereUniqueInput | StudyGroupMemberWhereUniqueInput[]
    update?: StudyGroupMemberUpdateWithWhereUniqueWithoutUserInput | StudyGroupMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StudyGroupMemberUpdateManyWithWhereWithoutUserInput | StudyGroupMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StudyGroupMemberScalarWhereInput | StudyGroupMemberScalarWhereInput[]
  }

  export type CertificateUpdateManyWithoutUserNestedInput = {
    create?: XOR<CertificateCreateWithoutUserInput, CertificateUncheckedCreateWithoutUserInput> | CertificateCreateWithoutUserInput[] | CertificateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutUserInput | CertificateCreateOrConnectWithoutUserInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutUserInput | CertificateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CertificateCreateManyUserInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutUserInput | CertificateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutUserInput | CertificateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type ExamCategoryUserUpdateManyWithoutGranterNestedInput = {
    create?: XOR<ExamCategoryUserCreateWithoutGranterInput, ExamCategoryUserUncheckedCreateWithoutGranterInput> | ExamCategoryUserCreateWithoutGranterInput[] | ExamCategoryUserUncheckedCreateWithoutGranterInput[]
    connectOrCreate?: ExamCategoryUserCreateOrConnectWithoutGranterInput | ExamCategoryUserCreateOrConnectWithoutGranterInput[]
    upsert?: ExamCategoryUserUpsertWithWhereUniqueWithoutGranterInput | ExamCategoryUserUpsertWithWhereUniqueWithoutGranterInput[]
    createMany?: ExamCategoryUserCreateManyGranterInputEnvelope
    set?: ExamCategoryUserWhereUniqueInput | ExamCategoryUserWhereUniqueInput[]
    disconnect?: ExamCategoryUserWhereUniqueInput | ExamCategoryUserWhereUniqueInput[]
    delete?: ExamCategoryUserWhereUniqueInput | ExamCategoryUserWhereUniqueInput[]
    connect?: ExamCategoryUserWhereUniqueInput | ExamCategoryUserWhereUniqueInput[]
    update?: ExamCategoryUserUpdateWithWhereUniqueWithoutGranterInput | ExamCategoryUserUpdateWithWhereUniqueWithoutGranterInput[]
    updateMany?: ExamCategoryUserUpdateManyWithWhereWithoutGranterInput | ExamCategoryUserUpdateManyWithWhereWithoutGranterInput[]
    deleteMany?: ExamCategoryUserScalarWhereInput | ExamCategoryUserScalarWhereInput[]
  }

  export type StudyGroupUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<StudyGroupCreateWithoutCreatorInput, StudyGroupUncheckedCreateWithoutCreatorInput> | StudyGroupCreateWithoutCreatorInput[] | StudyGroupUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: StudyGroupCreateOrConnectWithoutCreatorInput | StudyGroupCreateOrConnectWithoutCreatorInput[]
    upsert?: StudyGroupUpsertWithWhereUniqueWithoutCreatorInput | StudyGroupUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: StudyGroupCreateManyCreatorInputEnvelope
    set?: StudyGroupWhereUniqueInput | StudyGroupWhereUniqueInput[]
    disconnect?: StudyGroupWhereUniqueInput | StudyGroupWhereUniqueInput[]
    delete?: StudyGroupWhereUniqueInput | StudyGroupWhereUniqueInput[]
    connect?: StudyGroupWhereUniqueInput | StudyGroupWhereUniqueInput[]
    update?: StudyGroupUpdateWithWhereUniqueWithoutCreatorInput | StudyGroupUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: StudyGroupUpdateManyWithWhereWithoutCreatorInput | StudyGroupUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: StudyGroupScalarWhereInput | StudyGroupScalarWhereInput[]
  }

  export type QuestionUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<QuestionCreateWithoutCreatorInput, QuestionUncheckedCreateWithoutCreatorInput> | QuestionCreateWithoutCreatorInput[] | QuestionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutCreatorInput | QuestionCreateOrConnectWithoutCreatorInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutCreatorInput | QuestionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: QuestionCreateManyCreatorInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutCreatorInput | QuestionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutCreatorInput | QuestionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type QuestionUpdateManyWithoutApproverNestedInput = {
    create?: XOR<QuestionCreateWithoutApproverInput, QuestionUncheckedCreateWithoutApproverInput> | QuestionCreateWithoutApproverInput[] | QuestionUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutApproverInput | QuestionCreateOrConnectWithoutApproverInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutApproverInput | QuestionUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: QuestionCreateManyApproverInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutApproverInput | QuestionUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutApproverInput | QuestionUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type ExamUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ExamCreateWithoutCreatorInput, ExamUncheckedCreateWithoutCreatorInput> | ExamCreateWithoutCreatorInput[] | ExamUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutCreatorInput | ExamCreateOrConnectWithoutCreatorInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutCreatorInput | ExamUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ExamCreateManyCreatorInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutCreatorInput | ExamUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutCreatorInput | ExamUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type ExamUpdateManyWithoutApproverNestedInput = {
    create?: XOR<ExamCreateWithoutApproverInput, ExamUncheckedCreateWithoutApproverInput> | ExamCreateWithoutApproverInput[] | ExamUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutApproverInput | ExamCreateOrConnectWithoutApproverInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutApproverInput | ExamUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: ExamCreateManyApproverInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutApproverInput | ExamUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutApproverInput | ExamUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type CertificateUpdateManyWithoutRevokerNestedInput = {
    create?: XOR<CertificateCreateWithoutRevokerInput, CertificateUncheckedCreateWithoutRevokerInput> | CertificateCreateWithoutRevokerInput[] | CertificateUncheckedCreateWithoutRevokerInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutRevokerInput | CertificateCreateOrConnectWithoutRevokerInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutRevokerInput | CertificateUpsertWithWhereUniqueWithoutRevokerInput[]
    createMany?: CertificateCreateManyRevokerInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutRevokerInput | CertificateUpdateWithWhereUniqueWithoutRevokerInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutRevokerInput | CertificateUpdateManyWithWhereWithoutRevokerInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type ExamBookingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExamBookingCreateWithoutUserInput, ExamBookingUncheckedCreateWithoutUserInput> | ExamBookingCreateWithoutUserInput[] | ExamBookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExamBookingCreateOrConnectWithoutUserInput | ExamBookingCreateOrConnectWithoutUserInput[]
    upsert?: ExamBookingUpsertWithWhereUniqueWithoutUserInput | ExamBookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExamBookingCreateManyUserInputEnvelope
    set?: ExamBookingWhereUniqueInput | ExamBookingWhereUniqueInput[]
    disconnect?: ExamBookingWhereUniqueInput | ExamBookingWhereUniqueInput[]
    delete?: ExamBookingWhereUniqueInput | ExamBookingWhereUniqueInput[]
    connect?: ExamBookingWhereUniqueInput | ExamBookingWhereUniqueInput[]
    update?: ExamBookingUpdateWithWhereUniqueWithoutUserInput | ExamBookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExamBookingUpdateManyWithWhereWithoutUserInput | ExamBookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExamBookingScalarWhereInput | ExamBookingScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput> | PaymentCreateWithoutUserInput[] | PaymentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutUserInput | PaymentCreateOrConnectWithoutUserInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutUserInput | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentCreateManyUserInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutUserInput | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutUserInput | PaymentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ExamAttemptUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExamAttemptCreateWithoutUserInput, ExamAttemptUncheckedCreateWithoutUserInput> | ExamAttemptCreateWithoutUserInput[] | ExamAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutUserInput | ExamAttemptCreateOrConnectWithoutUserInput[]
    upsert?: ExamAttemptUpsertWithWhereUniqueWithoutUserInput | ExamAttemptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExamAttemptCreateManyUserInputEnvelope
    set?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    disconnect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    delete?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    update?: ExamAttemptUpdateWithWhereUniqueWithoutUserInput | ExamAttemptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExamAttemptUpdateManyWithWhereWithoutUserInput | ExamAttemptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExamAttemptScalarWhereInput | ExamAttemptScalarWhereInput[]
  }

  export type QuestionResponseUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<QuestionResponseCreateWithoutUserInput, QuestionResponseUncheckedCreateWithoutUserInput> | QuestionResponseCreateWithoutUserInput[] | QuestionResponseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuestionResponseCreateOrConnectWithoutUserInput | QuestionResponseCreateOrConnectWithoutUserInput[]
    upsert?: QuestionResponseUpsertWithWhereUniqueWithoutUserInput | QuestionResponseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QuestionResponseCreateManyUserInputEnvelope
    set?: QuestionResponseWhereUniqueInput | QuestionResponseWhereUniqueInput[]
    disconnect?: QuestionResponseWhereUniqueInput | QuestionResponseWhereUniqueInput[]
    delete?: QuestionResponseWhereUniqueInput | QuestionResponseWhereUniqueInput[]
    connect?: QuestionResponseWhereUniqueInput | QuestionResponseWhereUniqueInput[]
    update?: QuestionResponseUpdateWithWhereUniqueWithoutUserInput | QuestionResponseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QuestionResponseUpdateManyWithWhereWithoutUserInput | QuestionResponseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QuestionResponseScalarWhereInput | QuestionResponseScalarWhereInput[]
  }

  export type QuestionScoreUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<QuestionScoreCreateWithoutUserInput, QuestionScoreUncheckedCreateWithoutUserInput> | QuestionScoreCreateWithoutUserInput[] | QuestionScoreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuestionScoreCreateOrConnectWithoutUserInput | QuestionScoreCreateOrConnectWithoutUserInput[]
    upsert?: QuestionScoreUpsertWithWhereUniqueWithoutUserInput | QuestionScoreUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QuestionScoreCreateManyUserInputEnvelope
    set?: QuestionScoreWhereUniqueInput | QuestionScoreWhereUniqueInput[]
    disconnect?: QuestionScoreWhereUniqueInput | QuestionScoreWhereUniqueInput[]
    delete?: QuestionScoreWhereUniqueInput | QuestionScoreWhereUniqueInput[]
    connect?: QuestionScoreWhereUniqueInput | QuestionScoreWhereUniqueInput[]
    update?: QuestionScoreUpdateWithWhereUniqueWithoutUserInput | QuestionScoreUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QuestionScoreUpdateManyWithWhereWithoutUserInput | QuestionScoreUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QuestionScoreScalarWhereInput | QuestionScoreScalarWhereInput[]
  }

  export type ExamScoreUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExamScoreCreateWithoutUserInput, ExamScoreUncheckedCreateWithoutUserInput> | ExamScoreCreateWithoutUserInput[] | ExamScoreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExamScoreCreateOrConnectWithoutUserInput | ExamScoreCreateOrConnectWithoutUserInput[]
    upsert?: ExamScoreUpsertWithWhereUniqueWithoutUserInput | ExamScoreUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExamScoreCreateManyUserInputEnvelope
    set?: ExamScoreWhereUniqueInput | ExamScoreWhereUniqueInput[]
    disconnect?: ExamScoreWhereUniqueInput | ExamScoreWhereUniqueInput[]
    delete?: ExamScoreWhereUniqueInput | ExamScoreWhereUniqueInput[]
    connect?: ExamScoreWhereUniqueInput | ExamScoreWhereUniqueInput[]
    update?: ExamScoreUpdateWithWhereUniqueWithoutUserInput | ExamScoreUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExamScoreUpdateManyWithWhereWithoutUserInput | ExamScoreUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExamScoreScalarWhereInput | ExamScoreScalarWhereInput[]
  }

  export type UserPerformanceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPerformanceCreateWithoutUserInput, UserPerformanceUncheckedCreateWithoutUserInput> | UserPerformanceCreateWithoutUserInput[] | UserPerformanceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPerformanceCreateOrConnectWithoutUserInput | UserPerformanceCreateOrConnectWithoutUserInput[]
    upsert?: UserPerformanceUpsertWithWhereUniqueWithoutUserInput | UserPerformanceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPerformanceCreateManyUserInputEnvelope
    set?: UserPerformanceWhereUniqueInput | UserPerformanceWhereUniqueInput[]
    disconnect?: UserPerformanceWhereUniqueInput | UserPerformanceWhereUniqueInput[]
    delete?: UserPerformanceWhereUniqueInput | UserPerformanceWhereUniqueInput[]
    connect?: UserPerformanceWhereUniqueInput | UserPerformanceWhereUniqueInput[]
    update?: UserPerformanceUpdateWithWhereUniqueWithoutUserInput | UserPerformanceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPerformanceUpdateManyWithWhereWithoutUserInput | UserPerformanceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPerformanceScalarWhereInput | UserPerformanceScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type UserSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type ExamCategoryUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExamCategoryUserCreateWithoutUserInput, ExamCategoryUserUncheckedCreateWithoutUserInput> | ExamCategoryUserCreateWithoutUserInput[] | ExamCategoryUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExamCategoryUserCreateOrConnectWithoutUserInput | ExamCategoryUserCreateOrConnectWithoutUserInput[]
    upsert?: ExamCategoryUserUpsertWithWhereUniqueWithoutUserInput | ExamCategoryUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExamCategoryUserCreateManyUserInputEnvelope
    set?: ExamCategoryUserWhereUniqueInput | ExamCategoryUserWhereUniqueInput[]
    disconnect?: ExamCategoryUserWhereUniqueInput | ExamCategoryUserWhereUniqueInput[]
    delete?: ExamCategoryUserWhereUniqueInput | ExamCategoryUserWhereUniqueInput[]
    connect?: ExamCategoryUserWhereUniqueInput | ExamCategoryUserWhereUniqueInput[]
    update?: ExamCategoryUserUpdateWithWhereUniqueWithoutUserInput | ExamCategoryUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExamCategoryUserUpdateManyWithWhereWithoutUserInput | ExamCategoryUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExamCategoryUserScalarWhereInput | ExamCategoryUserScalarWhereInput[]
  }

  export type StudyGroupMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<StudyGroupMemberCreateWithoutUserInput, StudyGroupMemberUncheckedCreateWithoutUserInput> | StudyGroupMemberCreateWithoutUserInput[] | StudyGroupMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: StudyGroupMemberCreateOrConnectWithoutUserInput | StudyGroupMemberCreateOrConnectWithoutUserInput[]
    upsert?: StudyGroupMemberUpsertWithWhereUniqueWithoutUserInput | StudyGroupMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: StudyGroupMemberCreateManyUserInputEnvelope
    set?: StudyGroupMemberWhereUniqueInput | StudyGroupMemberWhereUniqueInput[]
    disconnect?: StudyGroupMemberWhereUniqueInput | StudyGroupMemberWhereUniqueInput[]
    delete?: StudyGroupMemberWhereUniqueInput | StudyGroupMemberWhereUniqueInput[]
    connect?: StudyGroupMemberWhereUniqueInput | StudyGroupMemberWhereUniqueInput[]
    update?: StudyGroupMemberUpdateWithWhereUniqueWithoutUserInput | StudyGroupMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: StudyGroupMemberUpdateManyWithWhereWithoutUserInput | StudyGroupMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: StudyGroupMemberScalarWhereInput | StudyGroupMemberScalarWhereInput[]
  }

  export type CertificateUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CertificateCreateWithoutUserInput, CertificateUncheckedCreateWithoutUserInput> | CertificateCreateWithoutUserInput[] | CertificateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutUserInput | CertificateCreateOrConnectWithoutUserInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutUserInput | CertificateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CertificateCreateManyUserInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutUserInput | CertificateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutUserInput | CertificateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type ExamCategoryUserUncheckedUpdateManyWithoutGranterNestedInput = {
    create?: XOR<ExamCategoryUserCreateWithoutGranterInput, ExamCategoryUserUncheckedCreateWithoutGranterInput> | ExamCategoryUserCreateWithoutGranterInput[] | ExamCategoryUserUncheckedCreateWithoutGranterInput[]
    connectOrCreate?: ExamCategoryUserCreateOrConnectWithoutGranterInput | ExamCategoryUserCreateOrConnectWithoutGranterInput[]
    upsert?: ExamCategoryUserUpsertWithWhereUniqueWithoutGranterInput | ExamCategoryUserUpsertWithWhereUniqueWithoutGranterInput[]
    createMany?: ExamCategoryUserCreateManyGranterInputEnvelope
    set?: ExamCategoryUserWhereUniqueInput | ExamCategoryUserWhereUniqueInput[]
    disconnect?: ExamCategoryUserWhereUniqueInput | ExamCategoryUserWhereUniqueInput[]
    delete?: ExamCategoryUserWhereUniqueInput | ExamCategoryUserWhereUniqueInput[]
    connect?: ExamCategoryUserWhereUniqueInput | ExamCategoryUserWhereUniqueInput[]
    update?: ExamCategoryUserUpdateWithWhereUniqueWithoutGranterInput | ExamCategoryUserUpdateWithWhereUniqueWithoutGranterInput[]
    updateMany?: ExamCategoryUserUpdateManyWithWhereWithoutGranterInput | ExamCategoryUserUpdateManyWithWhereWithoutGranterInput[]
    deleteMany?: ExamCategoryUserScalarWhereInput | ExamCategoryUserScalarWhereInput[]
  }

  export type StudyGroupUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<StudyGroupCreateWithoutCreatorInput, StudyGroupUncheckedCreateWithoutCreatorInput> | StudyGroupCreateWithoutCreatorInput[] | StudyGroupUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: StudyGroupCreateOrConnectWithoutCreatorInput | StudyGroupCreateOrConnectWithoutCreatorInput[]
    upsert?: StudyGroupUpsertWithWhereUniqueWithoutCreatorInput | StudyGroupUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: StudyGroupCreateManyCreatorInputEnvelope
    set?: StudyGroupWhereUniqueInput | StudyGroupWhereUniqueInput[]
    disconnect?: StudyGroupWhereUniqueInput | StudyGroupWhereUniqueInput[]
    delete?: StudyGroupWhereUniqueInput | StudyGroupWhereUniqueInput[]
    connect?: StudyGroupWhereUniqueInput | StudyGroupWhereUniqueInput[]
    update?: StudyGroupUpdateWithWhereUniqueWithoutCreatorInput | StudyGroupUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: StudyGroupUpdateManyWithWhereWithoutCreatorInput | StudyGroupUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: StudyGroupScalarWhereInput | StudyGroupScalarWhereInput[]
  }

  export type QuestionUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<QuestionCreateWithoutCreatorInput, QuestionUncheckedCreateWithoutCreatorInput> | QuestionCreateWithoutCreatorInput[] | QuestionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutCreatorInput | QuestionCreateOrConnectWithoutCreatorInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutCreatorInput | QuestionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: QuestionCreateManyCreatorInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutCreatorInput | QuestionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutCreatorInput | QuestionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type QuestionUncheckedUpdateManyWithoutApproverNestedInput = {
    create?: XOR<QuestionCreateWithoutApproverInput, QuestionUncheckedCreateWithoutApproverInput> | QuestionCreateWithoutApproverInput[] | QuestionUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutApproverInput | QuestionCreateOrConnectWithoutApproverInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutApproverInput | QuestionUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: QuestionCreateManyApproverInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutApproverInput | QuestionUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutApproverInput | QuestionUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type ExamUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ExamCreateWithoutCreatorInput, ExamUncheckedCreateWithoutCreatorInput> | ExamCreateWithoutCreatorInput[] | ExamUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutCreatorInput | ExamCreateOrConnectWithoutCreatorInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutCreatorInput | ExamUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ExamCreateManyCreatorInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutCreatorInput | ExamUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutCreatorInput | ExamUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type ExamUncheckedUpdateManyWithoutApproverNestedInput = {
    create?: XOR<ExamCreateWithoutApproverInput, ExamUncheckedCreateWithoutApproverInput> | ExamCreateWithoutApproverInput[] | ExamUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutApproverInput | ExamCreateOrConnectWithoutApproverInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutApproverInput | ExamUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: ExamCreateManyApproverInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutApproverInput | ExamUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutApproverInput | ExamUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type CertificateUncheckedUpdateManyWithoutRevokerNestedInput = {
    create?: XOR<CertificateCreateWithoutRevokerInput, CertificateUncheckedCreateWithoutRevokerInput> | CertificateCreateWithoutRevokerInput[] | CertificateUncheckedCreateWithoutRevokerInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutRevokerInput | CertificateCreateOrConnectWithoutRevokerInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutRevokerInput | CertificateUpsertWithWhereUniqueWithoutRevokerInput[]
    createMany?: CertificateCreateManyRevokerInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutRevokerInput | CertificateUpdateWithWhereUniqueWithoutRevokerInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutRevokerInput | CertificateUpdateManyWithWhereWithoutRevokerInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUserSessionsInput = {
    create?: XOR<UserCreateWithoutUserSessionsInput, UserUncheckedCreateWithoutUserSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserSessionsNestedInput = {
    create?: XOR<UserCreateWithoutUserSessionsInput, UserUncheckedCreateWithoutUserSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserSessionsInput
    upsert?: UserUpsertWithoutUserSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserSessionsInput, UserUpdateWithoutUserSessionsInput>, UserUncheckedUpdateWithoutUserSessionsInput>
  }

  export type ExamCreateNestedManyWithoutExamCategoryInput = {
    create?: XOR<ExamCreateWithoutExamCategoryInput, ExamUncheckedCreateWithoutExamCategoryInput> | ExamCreateWithoutExamCategoryInput[] | ExamUncheckedCreateWithoutExamCategoryInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutExamCategoryInput | ExamCreateOrConnectWithoutExamCategoryInput[]
    createMany?: ExamCreateManyExamCategoryInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type QuestionCreateNestedManyWithoutExamCategoryInput = {
    create?: XOR<QuestionCreateWithoutExamCategoryInput, QuestionUncheckedCreateWithoutExamCategoryInput> | QuestionCreateWithoutExamCategoryInput[] | QuestionUncheckedCreateWithoutExamCategoryInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutExamCategoryInput | QuestionCreateOrConnectWithoutExamCategoryInput[]
    createMany?: QuestionCreateManyExamCategoryInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type ExamCategoryUserCreateNestedManyWithoutExamCategoryInput = {
    create?: XOR<ExamCategoryUserCreateWithoutExamCategoryInput, ExamCategoryUserUncheckedCreateWithoutExamCategoryInput> | ExamCategoryUserCreateWithoutExamCategoryInput[] | ExamCategoryUserUncheckedCreateWithoutExamCategoryInput[]
    connectOrCreate?: ExamCategoryUserCreateOrConnectWithoutExamCategoryInput | ExamCategoryUserCreateOrConnectWithoutExamCategoryInput[]
    createMany?: ExamCategoryUserCreateManyExamCategoryInputEnvelope
    connect?: ExamCategoryUserWhereUniqueInput | ExamCategoryUserWhereUniqueInput[]
  }

  export type UserPerformanceCreateNestedManyWithoutExamCategoryInput = {
    create?: XOR<UserPerformanceCreateWithoutExamCategoryInput, UserPerformanceUncheckedCreateWithoutExamCategoryInput> | UserPerformanceCreateWithoutExamCategoryInput[] | UserPerformanceUncheckedCreateWithoutExamCategoryInput[]
    connectOrCreate?: UserPerformanceCreateOrConnectWithoutExamCategoryInput | UserPerformanceCreateOrConnectWithoutExamCategoryInput[]
    createMany?: UserPerformanceCreateManyExamCategoryInputEnvelope
    connect?: UserPerformanceWhereUniqueInput | UserPerformanceWhereUniqueInput[]
  }

  export type ExamUncheckedCreateNestedManyWithoutExamCategoryInput = {
    create?: XOR<ExamCreateWithoutExamCategoryInput, ExamUncheckedCreateWithoutExamCategoryInput> | ExamCreateWithoutExamCategoryInput[] | ExamUncheckedCreateWithoutExamCategoryInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutExamCategoryInput | ExamCreateOrConnectWithoutExamCategoryInput[]
    createMany?: ExamCreateManyExamCategoryInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type QuestionUncheckedCreateNestedManyWithoutExamCategoryInput = {
    create?: XOR<QuestionCreateWithoutExamCategoryInput, QuestionUncheckedCreateWithoutExamCategoryInput> | QuestionCreateWithoutExamCategoryInput[] | QuestionUncheckedCreateWithoutExamCategoryInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutExamCategoryInput | QuestionCreateOrConnectWithoutExamCategoryInput[]
    createMany?: QuestionCreateManyExamCategoryInputEnvelope
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
  }

  export type ExamCategoryUserUncheckedCreateNestedManyWithoutExamCategoryInput = {
    create?: XOR<ExamCategoryUserCreateWithoutExamCategoryInput, ExamCategoryUserUncheckedCreateWithoutExamCategoryInput> | ExamCategoryUserCreateWithoutExamCategoryInput[] | ExamCategoryUserUncheckedCreateWithoutExamCategoryInput[]
    connectOrCreate?: ExamCategoryUserCreateOrConnectWithoutExamCategoryInput | ExamCategoryUserCreateOrConnectWithoutExamCategoryInput[]
    createMany?: ExamCategoryUserCreateManyExamCategoryInputEnvelope
    connect?: ExamCategoryUserWhereUniqueInput | ExamCategoryUserWhereUniqueInput[]
  }

  export type UserPerformanceUncheckedCreateNestedManyWithoutExamCategoryInput = {
    create?: XOR<UserPerformanceCreateWithoutExamCategoryInput, UserPerformanceUncheckedCreateWithoutExamCategoryInput> | UserPerformanceCreateWithoutExamCategoryInput[] | UserPerformanceUncheckedCreateWithoutExamCategoryInput[]
    connectOrCreate?: UserPerformanceCreateOrConnectWithoutExamCategoryInput | UserPerformanceCreateOrConnectWithoutExamCategoryInput[]
    createMany?: UserPerformanceCreateManyExamCategoryInputEnvelope
    connect?: UserPerformanceWhereUniqueInput | UserPerformanceWhereUniqueInput[]
  }

  export type ExamUpdateManyWithoutExamCategoryNestedInput = {
    create?: XOR<ExamCreateWithoutExamCategoryInput, ExamUncheckedCreateWithoutExamCategoryInput> | ExamCreateWithoutExamCategoryInput[] | ExamUncheckedCreateWithoutExamCategoryInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutExamCategoryInput | ExamCreateOrConnectWithoutExamCategoryInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutExamCategoryInput | ExamUpsertWithWhereUniqueWithoutExamCategoryInput[]
    createMany?: ExamCreateManyExamCategoryInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutExamCategoryInput | ExamUpdateWithWhereUniqueWithoutExamCategoryInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutExamCategoryInput | ExamUpdateManyWithWhereWithoutExamCategoryInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type QuestionUpdateManyWithoutExamCategoryNestedInput = {
    create?: XOR<QuestionCreateWithoutExamCategoryInput, QuestionUncheckedCreateWithoutExamCategoryInput> | QuestionCreateWithoutExamCategoryInput[] | QuestionUncheckedCreateWithoutExamCategoryInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutExamCategoryInput | QuestionCreateOrConnectWithoutExamCategoryInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutExamCategoryInput | QuestionUpsertWithWhereUniqueWithoutExamCategoryInput[]
    createMany?: QuestionCreateManyExamCategoryInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutExamCategoryInput | QuestionUpdateWithWhereUniqueWithoutExamCategoryInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutExamCategoryInput | QuestionUpdateManyWithWhereWithoutExamCategoryInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type ExamCategoryUserUpdateManyWithoutExamCategoryNestedInput = {
    create?: XOR<ExamCategoryUserCreateWithoutExamCategoryInput, ExamCategoryUserUncheckedCreateWithoutExamCategoryInput> | ExamCategoryUserCreateWithoutExamCategoryInput[] | ExamCategoryUserUncheckedCreateWithoutExamCategoryInput[]
    connectOrCreate?: ExamCategoryUserCreateOrConnectWithoutExamCategoryInput | ExamCategoryUserCreateOrConnectWithoutExamCategoryInput[]
    upsert?: ExamCategoryUserUpsertWithWhereUniqueWithoutExamCategoryInput | ExamCategoryUserUpsertWithWhereUniqueWithoutExamCategoryInput[]
    createMany?: ExamCategoryUserCreateManyExamCategoryInputEnvelope
    set?: ExamCategoryUserWhereUniqueInput | ExamCategoryUserWhereUniqueInput[]
    disconnect?: ExamCategoryUserWhereUniqueInput | ExamCategoryUserWhereUniqueInput[]
    delete?: ExamCategoryUserWhereUniqueInput | ExamCategoryUserWhereUniqueInput[]
    connect?: ExamCategoryUserWhereUniqueInput | ExamCategoryUserWhereUniqueInput[]
    update?: ExamCategoryUserUpdateWithWhereUniqueWithoutExamCategoryInput | ExamCategoryUserUpdateWithWhereUniqueWithoutExamCategoryInput[]
    updateMany?: ExamCategoryUserUpdateManyWithWhereWithoutExamCategoryInput | ExamCategoryUserUpdateManyWithWhereWithoutExamCategoryInput[]
    deleteMany?: ExamCategoryUserScalarWhereInput | ExamCategoryUserScalarWhereInput[]
  }

  export type UserPerformanceUpdateManyWithoutExamCategoryNestedInput = {
    create?: XOR<UserPerformanceCreateWithoutExamCategoryInput, UserPerformanceUncheckedCreateWithoutExamCategoryInput> | UserPerformanceCreateWithoutExamCategoryInput[] | UserPerformanceUncheckedCreateWithoutExamCategoryInput[]
    connectOrCreate?: UserPerformanceCreateOrConnectWithoutExamCategoryInput | UserPerformanceCreateOrConnectWithoutExamCategoryInput[]
    upsert?: UserPerformanceUpsertWithWhereUniqueWithoutExamCategoryInput | UserPerformanceUpsertWithWhereUniqueWithoutExamCategoryInput[]
    createMany?: UserPerformanceCreateManyExamCategoryInputEnvelope
    set?: UserPerformanceWhereUniqueInput | UserPerformanceWhereUniqueInput[]
    disconnect?: UserPerformanceWhereUniqueInput | UserPerformanceWhereUniqueInput[]
    delete?: UserPerformanceWhereUniqueInput | UserPerformanceWhereUniqueInput[]
    connect?: UserPerformanceWhereUniqueInput | UserPerformanceWhereUniqueInput[]
    update?: UserPerformanceUpdateWithWhereUniqueWithoutExamCategoryInput | UserPerformanceUpdateWithWhereUniqueWithoutExamCategoryInput[]
    updateMany?: UserPerformanceUpdateManyWithWhereWithoutExamCategoryInput | UserPerformanceUpdateManyWithWhereWithoutExamCategoryInput[]
    deleteMany?: UserPerformanceScalarWhereInput | UserPerformanceScalarWhereInput[]
  }

  export type ExamUncheckedUpdateManyWithoutExamCategoryNestedInput = {
    create?: XOR<ExamCreateWithoutExamCategoryInput, ExamUncheckedCreateWithoutExamCategoryInput> | ExamCreateWithoutExamCategoryInput[] | ExamUncheckedCreateWithoutExamCategoryInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutExamCategoryInput | ExamCreateOrConnectWithoutExamCategoryInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutExamCategoryInput | ExamUpsertWithWhereUniqueWithoutExamCategoryInput[]
    createMany?: ExamCreateManyExamCategoryInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutExamCategoryInput | ExamUpdateWithWhereUniqueWithoutExamCategoryInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutExamCategoryInput | ExamUpdateManyWithWhereWithoutExamCategoryInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type QuestionUncheckedUpdateManyWithoutExamCategoryNestedInput = {
    create?: XOR<QuestionCreateWithoutExamCategoryInput, QuestionUncheckedCreateWithoutExamCategoryInput> | QuestionCreateWithoutExamCategoryInput[] | QuestionUncheckedCreateWithoutExamCategoryInput[]
    connectOrCreate?: QuestionCreateOrConnectWithoutExamCategoryInput | QuestionCreateOrConnectWithoutExamCategoryInput[]
    upsert?: QuestionUpsertWithWhereUniqueWithoutExamCategoryInput | QuestionUpsertWithWhereUniqueWithoutExamCategoryInput[]
    createMany?: QuestionCreateManyExamCategoryInputEnvelope
    set?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    disconnect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    delete?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    connect?: QuestionWhereUniqueInput | QuestionWhereUniqueInput[]
    update?: QuestionUpdateWithWhereUniqueWithoutExamCategoryInput | QuestionUpdateWithWhereUniqueWithoutExamCategoryInput[]
    updateMany?: QuestionUpdateManyWithWhereWithoutExamCategoryInput | QuestionUpdateManyWithWhereWithoutExamCategoryInput[]
    deleteMany?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
  }

  export type ExamCategoryUserUncheckedUpdateManyWithoutExamCategoryNestedInput = {
    create?: XOR<ExamCategoryUserCreateWithoutExamCategoryInput, ExamCategoryUserUncheckedCreateWithoutExamCategoryInput> | ExamCategoryUserCreateWithoutExamCategoryInput[] | ExamCategoryUserUncheckedCreateWithoutExamCategoryInput[]
    connectOrCreate?: ExamCategoryUserCreateOrConnectWithoutExamCategoryInput | ExamCategoryUserCreateOrConnectWithoutExamCategoryInput[]
    upsert?: ExamCategoryUserUpsertWithWhereUniqueWithoutExamCategoryInput | ExamCategoryUserUpsertWithWhereUniqueWithoutExamCategoryInput[]
    createMany?: ExamCategoryUserCreateManyExamCategoryInputEnvelope
    set?: ExamCategoryUserWhereUniqueInput | ExamCategoryUserWhereUniqueInput[]
    disconnect?: ExamCategoryUserWhereUniqueInput | ExamCategoryUserWhereUniqueInput[]
    delete?: ExamCategoryUserWhereUniqueInput | ExamCategoryUserWhereUniqueInput[]
    connect?: ExamCategoryUserWhereUniqueInput | ExamCategoryUserWhereUniqueInput[]
    update?: ExamCategoryUserUpdateWithWhereUniqueWithoutExamCategoryInput | ExamCategoryUserUpdateWithWhereUniqueWithoutExamCategoryInput[]
    updateMany?: ExamCategoryUserUpdateManyWithWhereWithoutExamCategoryInput | ExamCategoryUserUpdateManyWithWhereWithoutExamCategoryInput[]
    deleteMany?: ExamCategoryUserScalarWhereInput | ExamCategoryUserScalarWhereInput[]
  }

  export type UserPerformanceUncheckedUpdateManyWithoutExamCategoryNestedInput = {
    create?: XOR<UserPerformanceCreateWithoutExamCategoryInput, UserPerformanceUncheckedCreateWithoutExamCategoryInput> | UserPerformanceCreateWithoutExamCategoryInput[] | UserPerformanceUncheckedCreateWithoutExamCategoryInput[]
    connectOrCreate?: UserPerformanceCreateOrConnectWithoutExamCategoryInput | UserPerformanceCreateOrConnectWithoutExamCategoryInput[]
    upsert?: UserPerformanceUpsertWithWhereUniqueWithoutExamCategoryInput | UserPerformanceUpsertWithWhereUniqueWithoutExamCategoryInput[]
    createMany?: UserPerformanceCreateManyExamCategoryInputEnvelope
    set?: UserPerformanceWhereUniqueInput | UserPerformanceWhereUniqueInput[]
    disconnect?: UserPerformanceWhereUniqueInput | UserPerformanceWhereUniqueInput[]
    delete?: UserPerformanceWhereUniqueInput | UserPerformanceWhereUniqueInput[]
    connect?: UserPerformanceWhereUniqueInput | UserPerformanceWhereUniqueInput[]
    update?: UserPerformanceUpdateWithWhereUniqueWithoutExamCategoryInput | UserPerformanceUpdateWithWhereUniqueWithoutExamCategoryInput[]
    updateMany?: UserPerformanceUpdateManyWithWhereWithoutExamCategoryInput | UserPerformanceUpdateManyWithWhereWithoutExamCategoryInput[]
    deleteMany?: UserPerformanceScalarWhereInput | UserPerformanceScalarWhereInput[]
  }

  export type ExamCategoryCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<ExamCategoryCreateWithoutQuestionsInput, ExamCategoryUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: ExamCategoryCreateOrConnectWithoutQuestionsInput
    connect?: ExamCategoryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedQuestionsInput = {
    create?: XOR<UserCreateWithoutCreatedQuestionsInput, UserUncheckedCreateWithoutCreatedQuestionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedQuestionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApprovedQuestionsInput = {
    create?: XOR<UserCreateWithoutApprovedQuestionsInput, UserUncheckedCreateWithoutApprovedQuestionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedQuestionsInput
    connect?: UserWhereUniqueInput
  }

  export type QuestionOptionCreateNestedManyWithoutQuestionInput = {
    create?: XOR<QuestionOptionCreateWithoutQuestionInput, QuestionOptionUncheckedCreateWithoutQuestionInput> | QuestionOptionCreateWithoutQuestionInput[] | QuestionOptionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuestionOptionCreateOrConnectWithoutQuestionInput | QuestionOptionCreateOrConnectWithoutQuestionInput[]
    createMany?: QuestionOptionCreateManyQuestionInputEnvelope
    connect?: QuestionOptionWhereUniqueInput | QuestionOptionWhereUniqueInput[]
  }

  export type QuestionImageCreateNestedManyWithoutQuestionInput = {
    create?: XOR<QuestionImageCreateWithoutQuestionInput, QuestionImageUncheckedCreateWithoutQuestionInput> | QuestionImageCreateWithoutQuestionInput[] | QuestionImageUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuestionImageCreateOrConnectWithoutQuestionInput | QuestionImageCreateOrConnectWithoutQuestionInput[]
    createMany?: QuestionImageCreateManyQuestionInputEnvelope
    connect?: QuestionImageWhereUniqueInput | QuestionImageWhereUniqueInput[]
  }

  export type QuestionTagCreateNestedManyWithoutQuestionInput = {
    create?: XOR<QuestionTagCreateWithoutQuestionInput, QuestionTagUncheckedCreateWithoutQuestionInput> | QuestionTagCreateWithoutQuestionInput[] | QuestionTagUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuestionTagCreateOrConnectWithoutQuestionInput | QuestionTagCreateOrConnectWithoutQuestionInput[]
    createMany?: QuestionTagCreateManyQuestionInputEnvelope
    connect?: QuestionTagWhereUniqueInput | QuestionTagWhereUniqueInput[]
  }

  export type ExamQuestionCreateNestedManyWithoutQuestionInput = {
    create?: XOR<ExamQuestionCreateWithoutQuestionInput, ExamQuestionUncheckedCreateWithoutQuestionInput> | ExamQuestionCreateWithoutQuestionInput[] | ExamQuestionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: ExamQuestionCreateOrConnectWithoutQuestionInput | ExamQuestionCreateOrConnectWithoutQuestionInput[]
    createMany?: ExamQuestionCreateManyQuestionInputEnvelope
    connect?: ExamQuestionWhereUniqueInput | ExamQuestionWhereUniqueInput[]
  }

  export type QuestionResponseCreateNestedManyWithoutQuestionInput = {
    create?: XOR<QuestionResponseCreateWithoutQuestionInput, QuestionResponseUncheckedCreateWithoutQuestionInput> | QuestionResponseCreateWithoutQuestionInput[] | QuestionResponseUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuestionResponseCreateOrConnectWithoutQuestionInput | QuestionResponseCreateOrConnectWithoutQuestionInput[]
    createMany?: QuestionResponseCreateManyQuestionInputEnvelope
    connect?: QuestionResponseWhereUniqueInput | QuestionResponseWhereUniqueInput[]
  }

  export type QuestionScoreCreateNestedManyWithoutQuestionInput = {
    create?: XOR<QuestionScoreCreateWithoutQuestionInput, QuestionScoreUncheckedCreateWithoutQuestionInput> | QuestionScoreCreateWithoutQuestionInput[] | QuestionScoreUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuestionScoreCreateOrConnectWithoutQuestionInput | QuestionScoreCreateOrConnectWithoutQuestionInput[]
    createMany?: QuestionScoreCreateManyQuestionInputEnvelope
    connect?: QuestionScoreWhereUniqueInput | QuestionScoreWhereUniqueInput[]
  }

  export type QuestionOptionUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<QuestionOptionCreateWithoutQuestionInput, QuestionOptionUncheckedCreateWithoutQuestionInput> | QuestionOptionCreateWithoutQuestionInput[] | QuestionOptionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuestionOptionCreateOrConnectWithoutQuestionInput | QuestionOptionCreateOrConnectWithoutQuestionInput[]
    createMany?: QuestionOptionCreateManyQuestionInputEnvelope
    connect?: QuestionOptionWhereUniqueInput | QuestionOptionWhereUniqueInput[]
  }

  export type QuestionImageUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<QuestionImageCreateWithoutQuestionInput, QuestionImageUncheckedCreateWithoutQuestionInput> | QuestionImageCreateWithoutQuestionInput[] | QuestionImageUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuestionImageCreateOrConnectWithoutQuestionInput | QuestionImageCreateOrConnectWithoutQuestionInput[]
    createMany?: QuestionImageCreateManyQuestionInputEnvelope
    connect?: QuestionImageWhereUniqueInput | QuestionImageWhereUniqueInput[]
  }

  export type QuestionTagUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<QuestionTagCreateWithoutQuestionInput, QuestionTagUncheckedCreateWithoutQuestionInput> | QuestionTagCreateWithoutQuestionInput[] | QuestionTagUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuestionTagCreateOrConnectWithoutQuestionInput | QuestionTagCreateOrConnectWithoutQuestionInput[]
    createMany?: QuestionTagCreateManyQuestionInputEnvelope
    connect?: QuestionTagWhereUniqueInput | QuestionTagWhereUniqueInput[]
  }

  export type ExamQuestionUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<ExamQuestionCreateWithoutQuestionInput, ExamQuestionUncheckedCreateWithoutQuestionInput> | ExamQuestionCreateWithoutQuestionInput[] | ExamQuestionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: ExamQuestionCreateOrConnectWithoutQuestionInput | ExamQuestionCreateOrConnectWithoutQuestionInput[]
    createMany?: ExamQuestionCreateManyQuestionInputEnvelope
    connect?: ExamQuestionWhereUniqueInput | ExamQuestionWhereUniqueInput[]
  }

  export type QuestionResponseUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<QuestionResponseCreateWithoutQuestionInput, QuestionResponseUncheckedCreateWithoutQuestionInput> | QuestionResponseCreateWithoutQuestionInput[] | QuestionResponseUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuestionResponseCreateOrConnectWithoutQuestionInput | QuestionResponseCreateOrConnectWithoutQuestionInput[]
    createMany?: QuestionResponseCreateManyQuestionInputEnvelope
    connect?: QuestionResponseWhereUniqueInput | QuestionResponseWhereUniqueInput[]
  }

  export type QuestionScoreUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<QuestionScoreCreateWithoutQuestionInput, QuestionScoreUncheckedCreateWithoutQuestionInput> | QuestionScoreCreateWithoutQuestionInput[] | QuestionScoreUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuestionScoreCreateOrConnectWithoutQuestionInput | QuestionScoreCreateOrConnectWithoutQuestionInput[]
    createMany?: QuestionScoreCreateManyQuestionInputEnvelope
    connect?: QuestionScoreWhereUniqueInput | QuestionScoreWhereUniqueInput[]
  }

  export type EnumQuestionTypeFieldUpdateOperationsInput = {
    set?: $Enums.QuestionType
  }

  export type EnumQuestionDifficultyFieldUpdateOperationsInput = {
    set?: $Enums.QuestionDifficulty
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ExamCategoryUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<ExamCategoryCreateWithoutQuestionsInput, ExamCategoryUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: ExamCategoryCreateOrConnectWithoutQuestionsInput
    upsert?: ExamCategoryUpsertWithoutQuestionsInput
    connect?: ExamCategoryWhereUniqueInput
    update?: XOR<XOR<ExamCategoryUpdateToOneWithWhereWithoutQuestionsInput, ExamCategoryUpdateWithoutQuestionsInput>, ExamCategoryUncheckedUpdateWithoutQuestionsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedQuestionsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedQuestionsInput, UserUncheckedCreateWithoutCreatedQuestionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedQuestionsInput
    upsert?: UserUpsertWithoutCreatedQuestionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedQuestionsInput, UserUpdateWithoutCreatedQuestionsInput>, UserUncheckedUpdateWithoutCreatedQuestionsInput>
  }

  export type UserUpdateOneWithoutApprovedQuestionsNestedInput = {
    create?: XOR<UserCreateWithoutApprovedQuestionsInput, UserUncheckedCreateWithoutApprovedQuestionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedQuestionsInput
    upsert?: UserUpsertWithoutApprovedQuestionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovedQuestionsInput, UserUpdateWithoutApprovedQuestionsInput>, UserUncheckedUpdateWithoutApprovedQuestionsInput>
  }

  export type QuestionOptionUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<QuestionOptionCreateWithoutQuestionInput, QuestionOptionUncheckedCreateWithoutQuestionInput> | QuestionOptionCreateWithoutQuestionInput[] | QuestionOptionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuestionOptionCreateOrConnectWithoutQuestionInput | QuestionOptionCreateOrConnectWithoutQuestionInput[]
    upsert?: QuestionOptionUpsertWithWhereUniqueWithoutQuestionInput | QuestionOptionUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: QuestionOptionCreateManyQuestionInputEnvelope
    set?: QuestionOptionWhereUniqueInput | QuestionOptionWhereUniqueInput[]
    disconnect?: QuestionOptionWhereUniqueInput | QuestionOptionWhereUniqueInput[]
    delete?: QuestionOptionWhereUniqueInput | QuestionOptionWhereUniqueInput[]
    connect?: QuestionOptionWhereUniqueInput | QuestionOptionWhereUniqueInput[]
    update?: QuestionOptionUpdateWithWhereUniqueWithoutQuestionInput | QuestionOptionUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: QuestionOptionUpdateManyWithWhereWithoutQuestionInput | QuestionOptionUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: QuestionOptionScalarWhereInput | QuestionOptionScalarWhereInput[]
  }

  export type QuestionImageUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<QuestionImageCreateWithoutQuestionInput, QuestionImageUncheckedCreateWithoutQuestionInput> | QuestionImageCreateWithoutQuestionInput[] | QuestionImageUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuestionImageCreateOrConnectWithoutQuestionInput | QuestionImageCreateOrConnectWithoutQuestionInput[]
    upsert?: QuestionImageUpsertWithWhereUniqueWithoutQuestionInput | QuestionImageUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: QuestionImageCreateManyQuestionInputEnvelope
    set?: QuestionImageWhereUniqueInput | QuestionImageWhereUniqueInput[]
    disconnect?: QuestionImageWhereUniqueInput | QuestionImageWhereUniqueInput[]
    delete?: QuestionImageWhereUniqueInput | QuestionImageWhereUniqueInput[]
    connect?: QuestionImageWhereUniqueInput | QuestionImageWhereUniqueInput[]
    update?: QuestionImageUpdateWithWhereUniqueWithoutQuestionInput | QuestionImageUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: QuestionImageUpdateManyWithWhereWithoutQuestionInput | QuestionImageUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: QuestionImageScalarWhereInput | QuestionImageScalarWhereInput[]
  }

  export type QuestionTagUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<QuestionTagCreateWithoutQuestionInput, QuestionTagUncheckedCreateWithoutQuestionInput> | QuestionTagCreateWithoutQuestionInput[] | QuestionTagUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuestionTagCreateOrConnectWithoutQuestionInput | QuestionTagCreateOrConnectWithoutQuestionInput[]
    upsert?: QuestionTagUpsertWithWhereUniqueWithoutQuestionInput | QuestionTagUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: QuestionTagCreateManyQuestionInputEnvelope
    set?: QuestionTagWhereUniqueInput | QuestionTagWhereUniqueInput[]
    disconnect?: QuestionTagWhereUniqueInput | QuestionTagWhereUniqueInput[]
    delete?: QuestionTagWhereUniqueInput | QuestionTagWhereUniqueInput[]
    connect?: QuestionTagWhereUniqueInput | QuestionTagWhereUniqueInput[]
    update?: QuestionTagUpdateWithWhereUniqueWithoutQuestionInput | QuestionTagUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: QuestionTagUpdateManyWithWhereWithoutQuestionInput | QuestionTagUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: QuestionTagScalarWhereInput | QuestionTagScalarWhereInput[]
  }

  export type ExamQuestionUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<ExamQuestionCreateWithoutQuestionInput, ExamQuestionUncheckedCreateWithoutQuestionInput> | ExamQuestionCreateWithoutQuestionInput[] | ExamQuestionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: ExamQuestionCreateOrConnectWithoutQuestionInput | ExamQuestionCreateOrConnectWithoutQuestionInput[]
    upsert?: ExamQuestionUpsertWithWhereUniqueWithoutQuestionInput | ExamQuestionUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: ExamQuestionCreateManyQuestionInputEnvelope
    set?: ExamQuestionWhereUniqueInput | ExamQuestionWhereUniqueInput[]
    disconnect?: ExamQuestionWhereUniqueInput | ExamQuestionWhereUniqueInput[]
    delete?: ExamQuestionWhereUniqueInput | ExamQuestionWhereUniqueInput[]
    connect?: ExamQuestionWhereUniqueInput | ExamQuestionWhereUniqueInput[]
    update?: ExamQuestionUpdateWithWhereUniqueWithoutQuestionInput | ExamQuestionUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: ExamQuestionUpdateManyWithWhereWithoutQuestionInput | ExamQuestionUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: ExamQuestionScalarWhereInput | ExamQuestionScalarWhereInput[]
  }

  export type QuestionResponseUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<QuestionResponseCreateWithoutQuestionInput, QuestionResponseUncheckedCreateWithoutQuestionInput> | QuestionResponseCreateWithoutQuestionInput[] | QuestionResponseUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuestionResponseCreateOrConnectWithoutQuestionInput | QuestionResponseCreateOrConnectWithoutQuestionInput[]
    upsert?: QuestionResponseUpsertWithWhereUniqueWithoutQuestionInput | QuestionResponseUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: QuestionResponseCreateManyQuestionInputEnvelope
    set?: QuestionResponseWhereUniqueInput | QuestionResponseWhereUniqueInput[]
    disconnect?: QuestionResponseWhereUniqueInput | QuestionResponseWhereUniqueInput[]
    delete?: QuestionResponseWhereUniqueInput | QuestionResponseWhereUniqueInput[]
    connect?: QuestionResponseWhereUniqueInput | QuestionResponseWhereUniqueInput[]
    update?: QuestionResponseUpdateWithWhereUniqueWithoutQuestionInput | QuestionResponseUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: QuestionResponseUpdateManyWithWhereWithoutQuestionInput | QuestionResponseUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: QuestionResponseScalarWhereInput | QuestionResponseScalarWhereInput[]
  }

  export type QuestionScoreUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<QuestionScoreCreateWithoutQuestionInput, QuestionScoreUncheckedCreateWithoutQuestionInput> | QuestionScoreCreateWithoutQuestionInput[] | QuestionScoreUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuestionScoreCreateOrConnectWithoutQuestionInput | QuestionScoreCreateOrConnectWithoutQuestionInput[]
    upsert?: QuestionScoreUpsertWithWhereUniqueWithoutQuestionInput | QuestionScoreUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: QuestionScoreCreateManyQuestionInputEnvelope
    set?: QuestionScoreWhereUniqueInput | QuestionScoreWhereUniqueInput[]
    disconnect?: QuestionScoreWhereUniqueInput | QuestionScoreWhereUniqueInput[]
    delete?: QuestionScoreWhereUniqueInput | QuestionScoreWhereUniqueInput[]
    connect?: QuestionScoreWhereUniqueInput | QuestionScoreWhereUniqueInput[]
    update?: QuestionScoreUpdateWithWhereUniqueWithoutQuestionInput | QuestionScoreUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: QuestionScoreUpdateManyWithWhereWithoutQuestionInput | QuestionScoreUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: QuestionScoreScalarWhereInput | QuestionScoreScalarWhereInput[]
  }

  export type QuestionOptionUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<QuestionOptionCreateWithoutQuestionInput, QuestionOptionUncheckedCreateWithoutQuestionInput> | QuestionOptionCreateWithoutQuestionInput[] | QuestionOptionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuestionOptionCreateOrConnectWithoutQuestionInput | QuestionOptionCreateOrConnectWithoutQuestionInput[]
    upsert?: QuestionOptionUpsertWithWhereUniqueWithoutQuestionInput | QuestionOptionUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: QuestionOptionCreateManyQuestionInputEnvelope
    set?: QuestionOptionWhereUniqueInput | QuestionOptionWhereUniqueInput[]
    disconnect?: QuestionOptionWhereUniqueInput | QuestionOptionWhereUniqueInput[]
    delete?: QuestionOptionWhereUniqueInput | QuestionOptionWhereUniqueInput[]
    connect?: QuestionOptionWhereUniqueInput | QuestionOptionWhereUniqueInput[]
    update?: QuestionOptionUpdateWithWhereUniqueWithoutQuestionInput | QuestionOptionUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: QuestionOptionUpdateManyWithWhereWithoutQuestionInput | QuestionOptionUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: QuestionOptionScalarWhereInput | QuestionOptionScalarWhereInput[]
  }

  export type QuestionImageUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<QuestionImageCreateWithoutQuestionInput, QuestionImageUncheckedCreateWithoutQuestionInput> | QuestionImageCreateWithoutQuestionInput[] | QuestionImageUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuestionImageCreateOrConnectWithoutQuestionInput | QuestionImageCreateOrConnectWithoutQuestionInput[]
    upsert?: QuestionImageUpsertWithWhereUniqueWithoutQuestionInput | QuestionImageUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: QuestionImageCreateManyQuestionInputEnvelope
    set?: QuestionImageWhereUniqueInput | QuestionImageWhereUniqueInput[]
    disconnect?: QuestionImageWhereUniqueInput | QuestionImageWhereUniqueInput[]
    delete?: QuestionImageWhereUniqueInput | QuestionImageWhereUniqueInput[]
    connect?: QuestionImageWhereUniqueInput | QuestionImageWhereUniqueInput[]
    update?: QuestionImageUpdateWithWhereUniqueWithoutQuestionInput | QuestionImageUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: QuestionImageUpdateManyWithWhereWithoutQuestionInput | QuestionImageUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: QuestionImageScalarWhereInput | QuestionImageScalarWhereInput[]
  }

  export type QuestionTagUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<QuestionTagCreateWithoutQuestionInput, QuestionTagUncheckedCreateWithoutQuestionInput> | QuestionTagCreateWithoutQuestionInput[] | QuestionTagUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuestionTagCreateOrConnectWithoutQuestionInput | QuestionTagCreateOrConnectWithoutQuestionInput[]
    upsert?: QuestionTagUpsertWithWhereUniqueWithoutQuestionInput | QuestionTagUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: QuestionTagCreateManyQuestionInputEnvelope
    set?: QuestionTagWhereUniqueInput | QuestionTagWhereUniqueInput[]
    disconnect?: QuestionTagWhereUniqueInput | QuestionTagWhereUniqueInput[]
    delete?: QuestionTagWhereUniqueInput | QuestionTagWhereUniqueInput[]
    connect?: QuestionTagWhereUniqueInput | QuestionTagWhereUniqueInput[]
    update?: QuestionTagUpdateWithWhereUniqueWithoutQuestionInput | QuestionTagUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: QuestionTagUpdateManyWithWhereWithoutQuestionInput | QuestionTagUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: QuestionTagScalarWhereInput | QuestionTagScalarWhereInput[]
  }

  export type ExamQuestionUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<ExamQuestionCreateWithoutQuestionInput, ExamQuestionUncheckedCreateWithoutQuestionInput> | ExamQuestionCreateWithoutQuestionInput[] | ExamQuestionUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: ExamQuestionCreateOrConnectWithoutQuestionInput | ExamQuestionCreateOrConnectWithoutQuestionInput[]
    upsert?: ExamQuestionUpsertWithWhereUniqueWithoutQuestionInput | ExamQuestionUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: ExamQuestionCreateManyQuestionInputEnvelope
    set?: ExamQuestionWhereUniqueInput | ExamQuestionWhereUniqueInput[]
    disconnect?: ExamQuestionWhereUniqueInput | ExamQuestionWhereUniqueInput[]
    delete?: ExamQuestionWhereUniqueInput | ExamQuestionWhereUniqueInput[]
    connect?: ExamQuestionWhereUniqueInput | ExamQuestionWhereUniqueInput[]
    update?: ExamQuestionUpdateWithWhereUniqueWithoutQuestionInput | ExamQuestionUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: ExamQuestionUpdateManyWithWhereWithoutQuestionInput | ExamQuestionUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: ExamQuestionScalarWhereInput | ExamQuestionScalarWhereInput[]
  }

  export type QuestionResponseUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<QuestionResponseCreateWithoutQuestionInput, QuestionResponseUncheckedCreateWithoutQuestionInput> | QuestionResponseCreateWithoutQuestionInput[] | QuestionResponseUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuestionResponseCreateOrConnectWithoutQuestionInput | QuestionResponseCreateOrConnectWithoutQuestionInput[]
    upsert?: QuestionResponseUpsertWithWhereUniqueWithoutQuestionInput | QuestionResponseUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: QuestionResponseCreateManyQuestionInputEnvelope
    set?: QuestionResponseWhereUniqueInput | QuestionResponseWhereUniqueInput[]
    disconnect?: QuestionResponseWhereUniqueInput | QuestionResponseWhereUniqueInput[]
    delete?: QuestionResponseWhereUniqueInput | QuestionResponseWhereUniqueInput[]
    connect?: QuestionResponseWhereUniqueInput | QuestionResponseWhereUniqueInput[]
    update?: QuestionResponseUpdateWithWhereUniqueWithoutQuestionInput | QuestionResponseUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: QuestionResponseUpdateManyWithWhereWithoutQuestionInput | QuestionResponseUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: QuestionResponseScalarWhereInput | QuestionResponseScalarWhereInput[]
  }

  export type QuestionScoreUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<QuestionScoreCreateWithoutQuestionInput, QuestionScoreUncheckedCreateWithoutQuestionInput> | QuestionScoreCreateWithoutQuestionInput[] | QuestionScoreUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuestionScoreCreateOrConnectWithoutQuestionInput | QuestionScoreCreateOrConnectWithoutQuestionInput[]
    upsert?: QuestionScoreUpsertWithWhereUniqueWithoutQuestionInput | QuestionScoreUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: QuestionScoreCreateManyQuestionInputEnvelope
    set?: QuestionScoreWhereUniqueInput | QuestionScoreWhereUniqueInput[]
    disconnect?: QuestionScoreWhereUniqueInput | QuestionScoreWhereUniqueInput[]
    delete?: QuestionScoreWhereUniqueInput | QuestionScoreWhereUniqueInput[]
    connect?: QuestionScoreWhereUniqueInput | QuestionScoreWhereUniqueInput[]
    update?: QuestionScoreUpdateWithWhereUniqueWithoutQuestionInput | QuestionScoreUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: QuestionScoreUpdateManyWithWhereWithoutQuestionInput | QuestionScoreUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: QuestionScoreScalarWhereInput | QuestionScoreScalarWhereInput[]
  }

  export type QuestionCreateNestedOneWithoutOptionsInput = {
    create?: XOR<QuestionCreateWithoutOptionsInput, QuestionUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutOptionsInput
    connect?: QuestionWhereUniqueInput
  }

  export type QuestionUpdateOneRequiredWithoutOptionsNestedInput = {
    create?: XOR<QuestionCreateWithoutOptionsInput, QuestionUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutOptionsInput
    upsert?: QuestionUpsertWithoutOptionsInput
    connect?: QuestionWhereUniqueInput
    update?: XOR<XOR<QuestionUpdateToOneWithWhereWithoutOptionsInput, QuestionUpdateWithoutOptionsInput>, QuestionUncheckedUpdateWithoutOptionsInput>
  }

  export type QuestionCreateNestedOneWithoutImagesInput = {
    create?: XOR<QuestionCreateWithoutImagesInput, QuestionUncheckedCreateWithoutImagesInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutImagesInput
    connect?: QuestionWhereUniqueInput
  }

  export type QuestionUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<QuestionCreateWithoutImagesInput, QuestionUncheckedCreateWithoutImagesInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutImagesInput
    upsert?: QuestionUpsertWithoutImagesInput
    connect?: QuestionWhereUniqueInput
    update?: XOR<XOR<QuestionUpdateToOneWithWhereWithoutImagesInput, QuestionUpdateWithoutImagesInput>, QuestionUncheckedUpdateWithoutImagesInput>
  }

  export type QuestionCreateNestedOneWithoutTagsInput = {
    create?: XOR<QuestionCreateWithoutTagsInput, QuestionUncheckedCreateWithoutTagsInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutTagsInput
    connect?: QuestionWhereUniqueInput
  }

  export type QuestionUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<QuestionCreateWithoutTagsInput, QuestionUncheckedCreateWithoutTagsInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutTagsInput
    upsert?: QuestionUpsertWithoutTagsInput
    connect?: QuestionWhereUniqueInput
    update?: XOR<XOR<QuestionUpdateToOneWithWhereWithoutTagsInput, QuestionUpdateWithoutTagsInput>, QuestionUncheckedUpdateWithoutTagsInput>
  }

  export type ExamCategoryCreateNestedOneWithoutExamsInput = {
    create?: XOR<ExamCategoryCreateWithoutExamsInput, ExamCategoryUncheckedCreateWithoutExamsInput>
    connectOrCreate?: ExamCategoryCreateOrConnectWithoutExamsInput
    connect?: ExamCategoryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedExamsInput = {
    create?: XOR<UserCreateWithoutCreatedExamsInput, UserUncheckedCreateWithoutCreatedExamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedExamsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApprovedExamsInput = {
    create?: XOR<UserCreateWithoutApprovedExamsInput, UserUncheckedCreateWithoutApprovedExamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedExamsInput
    connect?: UserWhereUniqueInput
  }

  export type ExamQuestionCreateNestedManyWithoutExamInput = {
    create?: XOR<ExamQuestionCreateWithoutExamInput, ExamQuestionUncheckedCreateWithoutExamInput> | ExamQuestionCreateWithoutExamInput[] | ExamQuestionUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamQuestionCreateOrConnectWithoutExamInput | ExamQuestionCreateOrConnectWithoutExamInput[]
    createMany?: ExamQuestionCreateManyExamInputEnvelope
    connect?: ExamQuestionWhereUniqueInput | ExamQuestionWhereUniqueInput[]
  }

  export type ExamBookingCreateNestedManyWithoutExamInput = {
    create?: XOR<ExamBookingCreateWithoutExamInput, ExamBookingUncheckedCreateWithoutExamInput> | ExamBookingCreateWithoutExamInput[] | ExamBookingUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamBookingCreateOrConnectWithoutExamInput | ExamBookingCreateOrConnectWithoutExamInput[]
    createMany?: ExamBookingCreateManyExamInputEnvelope
    connect?: ExamBookingWhereUniqueInput | ExamBookingWhereUniqueInput[]
  }

  export type ExamAttemptCreateNestedManyWithoutExamInput = {
    create?: XOR<ExamAttemptCreateWithoutExamInput, ExamAttemptUncheckedCreateWithoutExamInput> | ExamAttemptCreateWithoutExamInput[] | ExamAttemptUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutExamInput | ExamAttemptCreateOrConnectWithoutExamInput[]
    createMany?: ExamAttemptCreateManyExamInputEnvelope
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
  }

  export type ExamScoreCreateNestedManyWithoutExamInput = {
    create?: XOR<ExamScoreCreateWithoutExamInput, ExamScoreUncheckedCreateWithoutExamInput> | ExamScoreCreateWithoutExamInput[] | ExamScoreUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamScoreCreateOrConnectWithoutExamInput | ExamScoreCreateOrConnectWithoutExamInput[]
    createMany?: ExamScoreCreateManyExamInputEnvelope
    connect?: ExamScoreWhereUniqueInput | ExamScoreWhereUniqueInput[]
  }

  export type CertificateCreateNestedManyWithoutExamInput = {
    create?: XOR<CertificateCreateWithoutExamInput, CertificateUncheckedCreateWithoutExamInput> | CertificateCreateWithoutExamInput[] | CertificateUncheckedCreateWithoutExamInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutExamInput | CertificateCreateOrConnectWithoutExamInput[]
    createMany?: CertificateCreateManyExamInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type ExamQuestionUncheckedCreateNestedManyWithoutExamInput = {
    create?: XOR<ExamQuestionCreateWithoutExamInput, ExamQuestionUncheckedCreateWithoutExamInput> | ExamQuestionCreateWithoutExamInput[] | ExamQuestionUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamQuestionCreateOrConnectWithoutExamInput | ExamQuestionCreateOrConnectWithoutExamInput[]
    createMany?: ExamQuestionCreateManyExamInputEnvelope
    connect?: ExamQuestionWhereUniqueInput | ExamQuestionWhereUniqueInput[]
  }

  export type ExamBookingUncheckedCreateNestedManyWithoutExamInput = {
    create?: XOR<ExamBookingCreateWithoutExamInput, ExamBookingUncheckedCreateWithoutExamInput> | ExamBookingCreateWithoutExamInput[] | ExamBookingUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamBookingCreateOrConnectWithoutExamInput | ExamBookingCreateOrConnectWithoutExamInput[]
    createMany?: ExamBookingCreateManyExamInputEnvelope
    connect?: ExamBookingWhereUniqueInput | ExamBookingWhereUniqueInput[]
  }

  export type ExamAttemptUncheckedCreateNestedManyWithoutExamInput = {
    create?: XOR<ExamAttemptCreateWithoutExamInput, ExamAttemptUncheckedCreateWithoutExamInput> | ExamAttemptCreateWithoutExamInput[] | ExamAttemptUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutExamInput | ExamAttemptCreateOrConnectWithoutExamInput[]
    createMany?: ExamAttemptCreateManyExamInputEnvelope
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
  }

  export type ExamScoreUncheckedCreateNestedManyWithoutExamInput = {
    create?: XOR<ExamScoreCreateWithoutExamInput, ExamScoreUncheckedCreateWithoutExamInput> | ExamScoreCreateWithoutExamInput[] | ExamScoreUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamScoreCreateOrConnectWithoutExamInput | ExamScoreCreateOrConnectWithoutExamInput[]
    createMany?: ExamScoreCreateManyExamInputEnvelope
    connect?: ExamScoreWhereUniqueInput | ExamScoreWhereUniqueInput[]
  }

  export type CertificateUncheckedCreateNestedManyWithoutExamInput = {
    create?: XOR<CertificateCreateWithoutExamInput, CertificateUncheckedCreateWithoutExamInput> | CertificateCreateWithoutExamInput[] | CertificateUncheckedCreateWithoutExamInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutExamInput | CertificateCreateOrConnectWithoutExamInput[]
    createMany?: CertificateCreateManyExamInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ExamCategoryUpdateOneRequiredWithoutExamsNestedInput = {
    create?: XOR<ExamCategoryCreateWithoutExamsInput, ExamCategoryUncheckedCreateWithoutExamsInput>
    connectOrCreate?: ExamCategoryCreateOrConnectWithoutExamsInput
    upsert?: ExamCategoryUpsertWithoutExamsInput
    connect?: ExamCategoryWhereUniqueInput
    update?: XOR<XOR<ExamCategoryUpdateToOneWithWhereWithoutExamsInput, ExamCategoryUpdateWithoutExamsInput>, ExamCategoryUncheckedUpdateWithoutExamsInput>
  }

  export type UserUpdateOneRequiredWithoutCreatedExamsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedExamsInput, UserUncheckedCreateWithoutCreatedExamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedExamsInput
    upsert?: UserUpsertWithoutCreatedExamsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedExamsInput, UserUpdateWithoutCreatedExamsInput>, UserUncheckedUpdateWithoutCreatedExamsInput>
  }

  export type UserUpdateOneWithoutApprovedExamsNestedInput = {
    create?: XOR<UserCreateWithoutApprovedExamsInput, UserUncheckedCreateWithoutApprovedExamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovedExamsInput
    upsert?: UserUpsertWithoutApprovedExamsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovedExamsInput, UserUpdateWithoutApprovedExamsInput>, UserUncheckedUpdateWithoutApprovedExamsInput>
  }

  export type ExamQuestionUpdateManyWithoutExamNestedInput = {
    create?: XOR<ExamQuestionCreateWithoutExamInput, ExamQuestionUncheckedCreateWithoutExamInput> | ExamQuestionCreateWithoutExamInput[] | ExamQuestionUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamQuestionCreateOrConnectWithoutExamInput | ExamQuestionCreateOrConnectWithoutExamInput[]
    upsert?: ExamQuestionUpsertWithWhereUniqueWithoutExamInput | ExamQuestionUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: ExamQuestionCreateManyExamInputEnvelope
    set?: ExamQuestionWhereUniqueInput | ExamQuestionWhereUniqueInput[]
    disconnect?: ExamQuestionWhereUniqueInput | ExamQuestionWhereUniqueInput[]
    delete?: ExamQuestionWhereUniqueInput | ExamQuestionWhereUniqueInput[]
    connect?: ExamQuestionWhereUniqueInput | ExamQuestionWhereUniqueInput[]
    update?: ExamQuestionUpdateWithWhereUniqueWithoutExamInput | ExamQuestionUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: ExamQuestionUpdateManyWithWhereWithoutExamInput | ExamQuestionUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: ExamQuestionScalarWhereInput | ExamQuestionScalarWhereInput[]
  }

  export type ExamBookingUpdateManyWithoutExamNestedInput = {
    create?: XOR<ExamBookingCreateWithoutExamInput, ExamBookingUncheckedCreateWithoutExamInput> | ExamBookingCreateWithoutExamInput[] | ExamBookingUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamBookingCreateOrConnectWithoutExamInput | ExamBookingCreateOrConnectWithoutExamInput[]
    upsert?: ExamBookingUpsertWithWhereUniqueWithoutExamInput | ExamBookingUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: ExamBookingCreateManyExamInputEnvelope
    set?: ExamBookingWhereUniqueInput | ExamBookingWhereUniqueInput[]
    disconnect?: ExamBookingWhereUniqueInput | ExamBookingWhereUniqueInput[]
    delete?: ExamBookingWhereUniqueInput | ExamBookingWhereUniqueInput[]
    connect?: ExamBookingWhereUniqueInput | ExamBookingWhereUniqueInput[]
    update?: ExamBookingUpdateWithWhereUniqueWithoutExamInput | ExamBookingUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: ExamBookingUpdateManyWithWhereWithoutExamInput | ExamBookingUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: ExamBookingScalarWhereInput | ExamBookingScalarWhereInput[]
  }

  export type ExamAttemptUpdateManyWithoutExamNestedInput = {
    create?: XOR<ExamAttemptCreateWithoutExamInput, ExamAttemptUncheckedCreateWithoutExamInput> | ExamAttemptCreateWithoutExamInput[] | ExamAttemptUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutExamInput | ExamAttemptCreateOrConnectWithoutExamInput[]
    upsert?: ExamAttemptUpsertWithWhereUniqueWithoutExamInput | ExamAttemptUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: ExamAttemptCreateManyExamInputEnvelope
    set?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    disconnect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    delete?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    update?: ExamAttemptUpdateWithWhereUniqueWithoutExamInput | ExamAttemptUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: ExamAttemptUpdateManyWithWhereWithoutExamInput | ExamAttemptUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: ExamAttemptScalarWhereInput | ExamAttemptScalarWhereInput[]
  }

  export type ExamScoreUpdateManyWithoutExamNestedInput = {
    create?: XOR<ExamScoreCreateWithoutExamInput, ExamScoreUncheckedCreateWithoutExamInput> | ExamScoreCreateWithoutExamInput[] | ExamScoreUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamScoreCreateOrConnectWithoutExamInput | ExamScoreCreateOrConnectWithoutExamInput[]
    upsert?: ExamScoreUpsertWithWhereUniqueWithoutExamInput | ExamScoreUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: ExamScoreCreateManyExamInputEnvelope
    set?: ExamScoreWhereUniqueInput | ExamScoreWhereUniqueInput[]
    disconnect?: ExamScoreWhereUniqueInput | ExamScoreWhereUniqueInput[]
    delete?: ExamScoreWhereUniqueInput | ExamScoreWhereUniqueInput[]
    connect?: ExamScoreWhereUniqueInput | ExamScoreWhereUniqueInput[]
    update?: ExamScoreUpdateWithWhereUniqueWithoutExamInput | ExamScoreUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: ExamScoreUpdateManyWithWhereWithoutExamInput | ExamScoreUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: ExamScoreScalarWhereInput | ExamScoreScalarWhereInput[]
  }

  export type CertificateUpdateManyWithoutExamNestedInput = {
    create?: XOR<CertificateCreateWithoutExamInput, CertificateUncheckedCreateWithoutExamInput> | CertificateCreateWithoutExamInput[] | CertificateUncheckedCreateWithoutExamInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutExamInput | CertificateCreateOrConnectWithoutExamInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutExamInput | CertificateUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: CertificateCreateManyExamInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutExamInput | CertificateUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutExamInput | CertificateUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type ExamQuestionUncheckedUpdateManyWithoutExamNestedInput = {
    create?: XOR<ExamQuestionCreateWithoutExamInput, ExamQuestionUncheckedCreateWithoutExamInput> | ExamQuestionCreateWithoutExamInput[] | ExamQuestionUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamQuestionCreateOrConnectWithoutExamInput | ExamQuestionCreateOrConnectWithoutExamInput[]
    upsert?: ExamQuestionUpsertWithWhereUniqueWithoutExamInput | ExamQuestionUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: ExamQuestionCreateManyExamInputEnvelope
    set?: ExamQuestionWhereUniqueInput | ExamQuestionWhereUniqueInput[]
    disconnect?: ExamQuestionWhereUniqueInput | ExamQuestionWhereUniqueInput[]
    delete?: ExamQuestionWhereUniqueInput | ExamQuestionWhereUniqueInput[]
    connect?: ExamQuestionWhereUniqueInput | ExamQuestionWhereUniqueInput[]
    update?: ExamQuestionUpdateWithWhereUniqueWithoutExamInput | ExamQuestionUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: ExamQuestionUpdateManyWithWhereWithoutExamInput | ExamQuestionUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: ExamQuestionScalarWhereInput | ExamQuestionScalarWhereInput[]
  }

  export type ExamBookingUncheckedUpdateManyWithoutExamNestedInput = {
    create?: XOR<ExamBookingCreateWithoutExamInput, ExamBookingUncheckedCreateWithoutExamInput> | ExamBookingCreateWithoutExamInput[] | ExamBookingUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamBookingCreateOrConnectWithoutExamInput | ExamBookingCreateOrConnectWithoutExamInput[]
    upsert?: ExamBookingUpsertWithWhereUniqueWithoutExamInput | ExamBookingUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: ExamBookingCreateManyExamInputEnvelope
    set?: ExamBookingWhereUniqueInput | ExamBookingWhereUniqueInput[]
    disconnect?: ExamBookingWhereUniqueInput | ExamBookingWhereUniqueInput[]
    delete?: ExamBookingWhereUniqueInput | ExamBookingWhereUniqueInput[]
    connect?: ExamBookingWhereUniqueInput | ExamBookingWhereUniqueInput[]
    update?: ExamBookingUpdateWithWhereUniqueWithoutExamInput | ExamBookingUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: ExamBookingUpdateManyWithWhereWithoutExamInput | ExamBookingUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: ExamBookingScalarWhereInput | ExamBookingScalarWhereInput[]
  }

  export type ExamAttemptUncheckedUpdateManyWithoutExamNestedInput = {
    create?: XOR<ExamAttemptCreateWithoutExamInput, ExamAttemptUncheckedCreateWithoutExamInput> | ExamAttemptCreateWithoutExamInput[] | ExamAttemptUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutExamInput | ExamAttemptCreateOrConnectWithoutExamInput[]
    upsert?: ExamAttemptUpsertWithWhereUniqueWithoutExamInput | ExamAttemptUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: ExamAttemptCreateManyExamInputEnvelope
    set?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    disconnect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    delete?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    update?: ExamAttemptUpdateWithWhereUniqueWithoutExamInput | ExamAttemptUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: ExamAttemptUpdateManyWithWhereWithoutExamInput | ExamAttemptUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: ExamAttemptScalarWhereInput | ExamAttemptScalarWhereInput[]
  }

  export type ExamScoreUncheckedUpdateManyWithoutExamNestedInput = {
    create?: XOR<ExamScoreCreateWithoutExamInput, ExamScoreUncheckedCreateWithoutExamInput> | ExamScoreCreateWithoutExamInput[] | ExamScoreUncheckedCreateWithoutExamInput[]
    connectOrCreate?: ExamScoreCreateOrConnectWithoutExamInput | ExamScoreCreateOrConnectWithoutExamInput[]
    upsert?: ExamScoreUpsertWithWhereUniqueWithoutExamInput | ExamScoreUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: ExamScoreCreateManyExamInputEnvelope
    set?: ExamScoreWhereUniqueInput | ExamScoreWhereUniqueInput[]
    disconnect?: ExamScoreWhereUniqueInput | ExamScoreWhereUniqueInput[]
    delete?: ExamScoreWhereUniqueInput | ExamScoreWhereUniqueInput[]
    connect?: ExamScoreWhereUniqueInput | ExamScoreWhereUniqueInput[]
    update?: ExamScoreUpdateWithWhereUniqueWithoutExamInput | ExamScoreUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: ExamScoreUpdateManyWithWhereWithoutExamInput | ExamScoreUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: ExamScoreScalarWhereInput | ExamScoreScalarWhereInput[]
  }

  export type CertificateUncheckedUpdateManyWithoutExamNestedInput = {
    create?: XOR<CertificateCreateWithoutExamInput, CertificateUncheckedCreateWithoutExamInput> | CertificateCreateWithoutExamInput[] | CertificateUncheckedCreateWithoutExamInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutExamInput | CertificateCreateOrConnectWithoutExamInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutExamInput | CertificateUpsertWithWhereUniqueWithoutExamInput[]
    createMany?: CertificateCreateManyExamInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutExamInput | CertificateUpdateWithWhereUniqueWithoutExamInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutExamInput | CertificateUpdateManyWithWhereWithoutExamInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type ExamCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<ExamCreateWithoutQuestionsInput, ExamUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: ExamCreateOrConnectWithoutQuestionsInput
    connect?: ExamWhereUniqueInput
  }

  export type QuestionCreateNestedOneWithoutExamQuestionsInput = {
    create?: XOR<QuestionCreateWithoutExamQuestionsInput, QuestionUncheckedCreateWithoutExamQuestionsInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutExamQuestionsInput
    connect?: QuestionWhereUniqueInput
  }

  export type ExamUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<ExamCreateWithoutQuestionsInput, ExamUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: ExamCreateOrConnectWithoutQuestionsInput
    upsert?: ExamUpsertWithoutQuestionsInput
    connect?: ExamWhereUniqueInput
    update?: XOR<XOR<ExamUpdateToOneWithWhereWithoutQuestionsInput, ExamUpdateWithoutQuestionsInput>, ExamUncheckedUpdateWithoutQuestionsInput>
  }

  export type QuestionUpdateOneRequiredWithoutExamQuestionsNestedInput = {
    create?: XOR<QuestionCreateWithoutExamQuestionsInput, QuestionUncheckedCreateWithoutExamQuestionsInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutExamQuestionsInput
    upsert?: QuestionUpsertWithoutExamQuestionsInput
    connect?: QuestionWhereUniqueInput
    update?: XOR<XOR<QuestionUpdateToOneWithWhereWithoutExamQuestionsInput, QuestionUpdateWithoutExamQuestionsInput>, QuestionUncheckedUpdateWithoutExamQuestionsInput>
  }

  export type UserCreateNestedOneWithoutExamBookingsInput = {
    create?: XOR<UserCreateWithoutExamBookingsInput, UserUncheckedCreateWithoutExamBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExamBookingsInput
    connect?: UserWhereUniqueInput
  }

  export type ExamCreateNestedOneWithoutBookingsInput = {
    create?: XOR<ExamCreateWithoutBookingsInput, ExamUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ExamCreateOrConnectWithoutBookingsInput
    connect?: ExamWhereUniqueInput
  }

  export type PaymentCreateNestedOneWithoutBookingInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput
    connect?: PaymentWhereUniqueInput
  }

  export type ExamAttemptCreateNestedManyWithoutBookingInput = {
    create?: XOR<ExamAttemptCreateWithoutBookingInput, ExamAttemptUncheckedCreateWithoutBookingInput> | ExamAttemptCreateWithoutBookingInput[] | ExamAttemptUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutBookingInput | ExamAttemptCreateOrConnectWithoutBookingInput[]
    createMany?: ExamAttemptCreateManyBookingInputEnvelope
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedOneWithoutBookingInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput
    connect?: PaymentWhereUniqueInput
  }

  export type ExamAttemptUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<ExamAttemptCreateWithoutBookingInput, ExamAttemptUncheckedCreateWithoutBookingInput> | ExamAttemptCreateWithoutBookingInput[] | ExamAttemptUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutBookingInput | ExamAttemptCreateOrConnectWithoutBookingInput[]
    createMany?: ExamAttemptCreateManyBookingInputEnvelope
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
  }

  export type EnumBookingStatusFieldUpdateOperationsInput = {
    set?: $Enums.BookingStatus
  }

  export type UserUpdateOneRequiredWithoutExamBookingsNestedInput = {
    create?: XOR<UserCreateWithoutExamBookingsInput, UserUncheckedCreateWithoutExamBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExamBookingsInput
    upsert?: UserUpsertWithoutExamBookingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExamBookingsInput, UserUpdateWithoutExamBookingsInput>, UserUncheckedUpdateWithoutExamBookingsInput>
  }

  export type ExamUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<ExamCreateWithoutBookingsInput, ExamUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ExamCreateOrConnectWithoutBookingsInput
    upsert?: ExamUpsertWithoutBookingsInput
    connect?: ExamWhereUniqueInput
    update?: XOR<XOR<ExamUpdateToOneWithWhereWithoutBookingsInput, ExamUpdateWithoutBookingsInput>, ExamUncheckedUpdateWithoutBookingsInput>
  }

  export type PaymentUpdateOneWithoutBookingNestedInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput
    upsert?: PaymentUpsertWithoutBookingInput
    disconnect?: PaymentWhereInput | boolean
    delete?: PaymentWhereInput | boolean
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutBookingInput, PaymentUpdateWithoutBookingInput>, PaymentUncheckedUpdateWithoutBookingInput>
  }

  export type ExamAttemptUpdateManyWithoutBookingNestedInput = {
    create?: XOR<ExamAttemptCreateWithoutBookingInput, ExamAttemptUncheckedCreateWithoutBookingInput> | ExamAttemptCreateWithoutBookingInput[] | ExamAttemptUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutBookingInput | ExamAttemptCreateOrConnectWithoutBookingInput[]
    upsert?: ExamAttemptUpsertWithWhereUniqueWithoutBookingInput | ExamAttemptUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: ExamAttemptCreateManyBookingInputEnvelope
    set?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    disconnect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    delete?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    update?: ExamAttemptUpdateWithWhereUniqueWithoutBookingInput | ExamAttemptUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: ExamAttemptUpdateManyWithWhereWithoutBookingInput | ExamAttemptUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: ExamAttemptScalarWhereInput | ExamAttemptScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateOneWithoutBookingNestedInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput
    upsert?: PaymentUpsertWithoutBookingInput
    disconnect?: PaymentWhereInput | boolean
    delete?: PaymentWhereInput | boolean
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutBookingInput, PaymentUpdateWithoutBookingInput>, PaymentUncheckedUpdateWithoutBookingInput>
  }

  export type ExamAttemptUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<ExamAttemptCreateWithoutBookingInput, ExamAttemptUncheckedCreateWithoutBookingInput> | ExamAttemptCreateWithoutBookingInput[] | ExamAttemptUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutBookingInput | ExamAttemptCreateOrConnectWithoutBookingInput[]
    upsert?: ExamAttemptUpsertWithWhereUniqueWithoutBookingInput | ExamAttemptUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: ExamAttemptCreateManyBookingInputEnvelope
    set?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    disconnect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    delete?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    connect?: ExamAttemptWhereUniqueInput | ExamAttemptWhereUniqueInput[]
    update?: ExamAttemptUpdateWithWhereUniqueWithoutBookingInput | ExamAttemptUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: ExamAttemptUpdateManyWithWhereWithoutBookingInput | ExamAttemptUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: ExamAttemptScalarWhereInput | ExamAttemptScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutExamAttemptsInput = {
    create?: XOR<UserCreateWithoutExamAttemptsInput, UserUncheckedCreateWithoutExamAttemptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExamAttemptsInput
    connect?: UserWhereUniqueInput
  }

  export type ExamCreateNestedOneWithoutAttemptsInput = {
    create?: XOR<ExamCreateWithoutAttemptsInput, ExamUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: ExamCreateOrConnectWithoutAttemptsInput
    connect?: ExamWhereUniqueInput
  }

  export type ExamBookingCreateNestedOneWithoutAttemptsInput = {
    create?: XOR<ExamBookingCreateWithoutAttemptsInput, ExamBookingUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: ExamBookingCreateOrConnectWithoutAttemptsInput
    connect?: ExamBookingWhereUniqueInput
  }

  export type QuestionResponseCreateNestedManyWithoutAttemptInput = {
    create?: XOR<QuestionResponseCreateWithoutAttemptInput, QuestionResponseUncheckedCreateWithoutAttemptInput> | QuestionResponseCreateWithoutAttemptInput[] | QuestionResponseUncheckedCreateWithoutAttemptInput[]
    connectOrCreate?: QuestionResponseCreateOrConnectWithoutAttemptInput | QuestionResponseCreateOrConnectWithoutAttemptInput[]
    createMany?: QuestionResponseCreateManyAttemptInputEnvelope
    connect?: QuestionResponseWhereUniqueInput | QuestionResponseWhereUniqueInput[]
  }

  export type QuestionScoreCreateNestedManyWithoutAttemptInput = {
    create?: XOR<QuestionScoreCreateWithoutAttemptInput, QuestionScoreUncheckedCreateWithoutAttemptInput> | QuestionScoreCreateWithoutAttemptInput[] | QuestionScoreUncheckedCreateWithoutAttemptInput[]
    connectOrCreate?: QuestionScoreCreateOrConnectWithoutAttemptInput | QuestionScoreCreateOrConnectWithoutAttemptInput[]
    createMany?: QuestionScoreCreateManyAttemptInputEnvelope
    connect?: QuestionScoreWhereUniqueInput | QuestionScoreWhereUniqueInput[]
  }

  export type ExamScoreCreateNestedOneWithoutAttemptInput = {
    create?: XOR<ExamScoreCreateWithoutAttemptInput, ExamScoreUncheckedCreateWithoutAttemptInput>
    connectOrCreate?: ExamScoreCreateOrConnectWithoutAttemptInput
    connect?: ExamScoreWhereUniqueInput
  }

  export type CertificateCreateNestedOneWithoutAttemptInput = {
    create?: XOR<CertificateCreateWithoutAttemptInput, CertificateUncheckedCreateWithoutAttemptInput>
    connectOrCreate?: CertificateCreateOrConnectWithoutAttemptInput
    connect?: CertificateWhereUniqueInput
  }

  export type QuestionResponseUncheckedCreateNestedManyWithoutAttemptInput = {
    create?: XOR<QuestionResponseCreateWithoutAttemptInput, QuestionResponseUncheckedCreateWithoutAttemptInput> | QuestionResponseCreateWithoutAttemptInput[] | QuestionResponseUncheckedCreateWithoutAttemptInput[]
    connectOrCreate?: QuestionResponseCreateOrConnectWithoutAttemptInput | QuestionResponseCreateOrConnectWithoutAttemptInput[]
    createMany?: QuestionResponseCreateManyAttemptInputEnvelope
    connect?: QuestionResponseWhereUniqueInput | QuestionResponseWhereUniqueInput[]
  }

  export type QuestionScoreUncheckedCreateNestedManyWithoutAttemptInput = {
    create?: XOR<QuestionScoreCreateWithoutAttemptInput, QuestionScoreUncheckedCreateWithoutAttemptInput> | QuestionScoreCreateWithoutAttemptInput[] | QuestionScoreUncheckedCreateWithoutAttemptInput[]
    connectOrCreate?: QuestionScoreCreateOrConnectWithoutAttemptInput | QuestionScoreCreateOrConnectWithoutAttemptInput[]
    createMany?: QuestionScoreCreateManyAttemptInputEnvelope
    connect?: QuestionScoreWhereUniqueInput | QuestionScoreWhereUniqueInput[]
  }

  export type ExamScoreUncheckedCreateNestedOneWithoutAttemptInput = {
    create?: XOR<ExamScoreCreateWithoutAttemptInput, ExamScoreUncheckedCreateWithoutAttemptInput>
    connectOrCreate?: ExamScoreCreateOrConnectWithoutAttemptInput
    connect?: ExamScoreWhereUniqueInput
  }

  export type CertificateUncheckedCreateNestedOneWithoutAttemptInput = {
    create?: XOR<CertificateCreateWithoutAttemptInput, CertificateUncheckedCreateWithoutAttemptInput>
    connectOrCreate?: CertificateCreateOrConnectWithoutAttemptInput
    connect?: CertificateWhereUniqueInput
  }

  export type EnumAttemptStatusFieldUpdateOperationsInput = {
    set?: $Enums.AttemptStatus
  }

  export type UserUpdateOneRequiredWithoutExamAttemptsNestedInput = {
    create?: XOR<UserCreateWithoutExamAttemptsInput, UserUncheckedCreateWithoutExamAttemptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExamAttemptsInput
    upsert?: UserUpsertWithoutExamAttemptsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExamAttemptsInput, UserUpdateWithoutExamAttemptsInput>, UserUncheckedUpdateWithoutExamAttemptsInput>
  }

  export type ExamUpdateOneRequiredWithoutAttemptsNestedInput = {
    create?: XOR<ExamCreateWithoutAttemptsInput, ExamUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: ExamCreateOrConnectWithoutAttemptsInput
    upsert?: ExamUpsertWithoutAttemptsInput
    connect?: ExamWhereUniqueInput
    update?: XOR<XOR<ExamUpdateToOneWithWhereWithoutAttemptsInput, ExamUpdateWithoutAttemptsInput>, ExamUncheckedUpdateWithoutAttemptsInput>
  }

  export type ExamBookingUpdateOneWithoutAttemptsNestedInput = {
    create?: XOR<ExamBookingCreateWithoutAttemptsInput, ExamBookingUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: ExamBookingCreateOrConnectWithoutAttemptsInput
    upsert?: ExamBookingUpsertWithoutAttemptsInput
    disconnect?: ExamBookingWhereInput | boolean
    delete?: ExamBookingWhereInput | boolean
    connect?: ExamBookingWhereUniqueInput
    update?: XOR<XOR<ExamBookingUpdateToOneWithWhereWithoutAttemptsInput, ExamBookingUpdateWithoutAttemptsInput>, ExamBookingUncheckedUpdateWithoutAttemptsInput>
  }

  export type QuestionResponseUpdateManyWithoutAttemptNestedInput = {
    create?: XOR<QuestionResponseCreateWithoutAttemptInput, QuestionResponseUncheckedCreateWithoutAttemptInput> | QuestionResponseCreateWithoutAttemptInput[] | QuestionResponseUncheckedCreateWithoutAttemptInput[]
    connectOrCreate?: QuestionResponseCreateOrConnectWithoutAttemptInput | QuestionResponseCreateOrConnectWithoutAttemptInput[]
    upsert?: QuestionResponseUpsertWithWhereUniqueWithoutAttemptInput | QuestionResponseUpsertWithWhereUniqueWithoutAttemptInput[]
    createMany?: QuestionResponseCreateManyAttemptInputEnvelope
    set?: QuestionResponseWhereUniqueInput | QuestionResponseWhereUniqueInput[]
    disconnect?: QuestionResponseWhereUniqueInput | QuestionResponseWhereUniqueInput[]
    delete?: QuestionResponseWhereUniqueInput | QuestionResponseWhereUniqueInput[]
    connect?: QuestionResponseWhereUniqueInput | QuestionResponseWhereUniqueInput[]
    update?: QuestionResponseUpdateWithWhereUniqueWithoutAttemptInput | QuestionResponseUpdateWithWhereUniqueWithoutAttemptInput[]
    updateMany?: QuestionResponseUpdateManyWithWhereWithoutAttemptInput | QuestionResponseUpdateManyWithWhereWithoutAttemptInput[]
    deleteMany?: QuestionResponseScalarWhereInput | QuestionResponseScalarWhereInput[]
  }

  export type QuestionScoreUpdateManyWithoutAttemptNestedInput = {
    create?: XOR<QuestionScoreCreateWithoutAttemptInput, QuestionScoreUncheckedCreateWithoutAttemptInput> | QuestionScoreCreateWithoutAttemptInput[] | QuestionScoreUncheckedCreateWithoutAttemptInput[]
    connectOrCreate?: QuestionScoreCreateOrConnectWithoutAttemptInput | QuestionScoreCreateOrConnectWithoutAttemptInput[]
    upsert?: QuestionScoreUpsertWithWhereUniqueWithoutAttemptInput | QuestionScoreUpsertWithWhereUniqueWithoutAttemptInput[]
    createMany?: QuestionScoreCreateManyAttemptInputEnvelope
    set?: QuestionScoreWhereUniqueInput | QuestionScoreWhereUniqueInput[]
    disconnect?: QuestionScoreWhereUniqueInput | QuestionScoreWhereUniqueInput[]
    delete?: QuestionScoreWhereUniqueInput | QuestionScoreWhereUniqueInput[]
    connect?: QuestionScoreWhereUniqueInput | QuestionScoreWhereUniqueInput[]
    update?: QuestionScoreUpdateWithWhereUniqueWithoutAttemptInput | QuestionScoreUpdateWithWhereUniqueWithoutAttemptInput[]
    updateMany?: QuestionScoreUpdateManyWithWhereWithoutAttemptInput | QuestionScoreUpdateManyWithWhereWithoutAttemptInput[]
    deleteMany?: QuestionScoreScalarWhereInput | QuestionScoreScalarWhereInput[]
  }

  export type ExamScoreUpdateOneWithoutAttemptNestedInput = {
    create?: XOR<ExamScoreCreateWithoutAttemptInput, ExamScoreUncheckedCreateWithoutAttemptInput>
    connectOrCreate?: ExamScoreCreateOrConnectWithoutAttemptInput
    upsert?: ExamScoreUpsertWithoutAttemptInput
    disconnect?: ExamScoreWhereInput | boolean
    delete?: ExamScoreWhereInput | boolean
    connect?: ExamScoreWhereUniqueInput
    update?: XOR<XOR<ExamScoreUpdateToOneWithWhereWithoutAttemptInput, ExamScoreUpdateWithoutAttemptInput>, ExamScoreUncheckedUpdateWithoutAttemptInput>
  }

  export type CertificateUpdateOneWithoutAttemptNestedInput = {
    create?: XOR<CertificateCreateWithoutAttemptInput, CertificateUncheckedCreateWithoutAttemptInput>
    connectOrCreate?: CertificateCreateOrConnectWithoutAttemptInput
    upsert?: CertificateUpsertWithoutAttemptInput
    disconnect?: CertificateWhereInput | boolean
    delete?: CertificateWhereInput | boolean
    connect?: CertificateWhereUniqueInput
    update?: XOR<XOR<CertificateUpdateToOneWithWhereWithoutAttemptInput, CertificateUpdateWithoutAttemptInput>, CertificateUncheckedUpdateWithoutAttemptInput>
  }

  export type QuestionResponseUncheckedUpdateManyWithoutAttemptNestedInput = {
    create?: XOR<QuestionResponseCreateWithoutAttemptInput, QuestionResponseUncheckedCreateWithoutAttemptInput> | QuestionResponseCreateWithoutAttemptInput[] | QuestionResponseUncheckedCreateWithoutAttemptInput[]
    connectOrCreate?: QuestionResponseCreateOrConnectWithoutAttemptInput | QuestionResponseCreateOrConnectWithoutAttemptInput[]
    upsert?: QuestionResponseUpsertWithWhereUniqueWithoutAttemptInput | QuestionResponseUpsertWithWhereUniqueWithoutAttemptInput[]
    createMany?: QuestionResponseCreateManyAttemptInputEnvelope
    set?: QuestionResponseWhereUniqueInput | QuestionResponseWhereUniqueInput[]
    disconnect?: QuestionResponseWhereUniqueInput | QuestionResponseWhereUniqueInput[]
    delete?: QuestionResponseWhereUniqueInput | QuestionResponseWhereUniqueInput[]
    connect?: QuestionResponseWhereUniqueInput | QuestionResponseWhereUniqueInput[]
    update?: QuestionResponseUpdateWithWhereUniqueWithoutAttemptInput | QuestionResponseUpdateWithWhereUniqueWithoutAttemptInput[]
    updateMany?: QuestionResponseUpdateManyWithWhereWithoutAttemptInput | QuestionResponseUpdateManyWithWhereWithoutAttemptInput[]
    deleteMany?: QuestionResponseScalarWhereInput | QuestionResponseScalarWhereInput[]
  }

  export type QuestionScoreUncheckedUpdateManyWithoutAttemptNestedInput = {
    create?: XOR<QuestionScoreCreateWithoutAttemptInput, QuestionScoreUncheckedCreateWithoutAttemptInput> | QuestionScoreCreateWithoutAttemptInput[] | QuestionScoreUncheckedCreateWithoutAttemptInput[]
    connectOrCreate?: QuestionScoreCreateOrConnectWithoutAttemptInput | QuestionScoreCreateOrConnectWithoutAttemptInput[]
    upsert?: QuestionScoreUpsertWithWhereUniqueWithoutAttemptInput | QuestionScoreUpsertWithWhereUniqueWithoutAttemptInput[]
    createMany?: QuestionScoreCreateManyAttemptInputEnvelope
    set?: QuestionScoreWhereUniqueInput | QuestionScoreWhereUniqueInput[]
    disconnect?: QuestionScoreWhereUniqueInput | QuestionScoreWhereUniqueInput[]
    delete?: QuestionScoreWhereUniqueInput | QuestionScoreWhereUniqueInput[]
    connect?: QuestionScoreWhereUniqueInput | QuestionScoreWhereUniqueInput[]
    update?: QuestionScoreUpdateWithWhereUniqueWithoutAttemptInput | QuestionScoreUpdateWithWhereUniqueWithoutAttemptInput[]
    updateMany?: QuestionScoreUpdateManyWithWhereWithoutAttemptInput | QuestionScoreUpdateManyWithWhereWithoutAttemptInput[]
    deleteMany?: QuestionScoreScalarWhereInput | QuestionScoreScalarWhereInput[]
  }

  export type ExamScoreUncheckedUpdateOneWithoutAttemptNestedInput = {
    create?: XOR<ExamScoreCreateWithoutAttemptInput, ExamScoreUncheckedCreateWithoutAttemptInput>
    connectOrCreate?: ExamScoreCreateOrConnectWithoutAttemptInput
    upsert?: ExamScoreUpsertWithoutAttemptInput
    disconnect?: ExamScoreWhereInput | boolean
    delete?: ExamScoreWhereInput | boolean
    connect?: ExamScoreWhereUniqueInput
    update?: XOR<XOR<ExamScoreUpdateToOneWithWhereWithoutAttemptInput, ExamScoreUpdateWithoutAttemptInput>, ExamScoreUncheckedUpdateWithoutAttemptInput>
  }

  export type CertificateUncheckedUpdateOneWithoutAttemptNestedInput = {
    create?: XOR<CertificateCreateWithoutAttemptInput, CertificateUncheckedCreateWithoutAttemptInput>
    connectOrCreate?: CertificateCreateOrConnectWithoutAttemptInput
    upsert?: CertificateUpsertWithoutAttemptInput
    disconnect?: CertificateWhereInput | boolean
    delete?: CertificateWhereInput | boolean
    connect?: CertificateWhereUniqueInput
    update?: XOR<XOR<CertificateUpdateToOneWithWhereWithoutAttemptInput, CertificateUpdateWithoutAttemptInput>, CertificateUncheckedUpdateWithoutAttemptInput>
  }

  export type QuestionResponseCreateselectedOptionsInput = {
    set: string[]
  }

  export type ExamAttemptCreateNestedOneWithoutResponsesInput = {
    create?: XOR<ExamAttemptCreateWithoutResponsesInput, ExamAttemptUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutResponsesInput
    connect?: ExamAttemptWhereUniqueInput
  }

  export type QuestionCreateNestedOneWithoutResponsesInput = {
    create?: XOR<QuestionCreateWithoutResponsesInput, QuestionUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutResponsesInput
    connect?: QuestionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutQuestionResponsesInput = {
    create?: XOR<UserCreateWithoutQuestionResponsesInput, UserUncheckedCreateWithoutQuestionResponsesInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuestionResponsesInput
    connect?: UserWhereUniqueInput
  }

  export type QuestionScoreCreateNestedOneWithoutResponseInput = {
    create?: XOR<QuestionScoreCreateWithoutResponseInput, QuestionScoreUncheckedCreateWithoutResponseInput>
    connectOrCreate?: QuestionScoreCreateOrConnectWithoutResponseInput
    connect?: QuestionScoreWhereUniqueInput
  }

  export type QuestionScoreUncheckedCreateNestedOneWithoutResponseInput = {
    create?: XOR<QuestionScoreCreateWithoutResponseInput, QuestionScoreUncheckedCreateWithoutResponseInput>
    connectOrCreate?: QuestionScoreCreateOrConnectWithoutResponseInput
    connect?: QuestionScoreWhereUniqueInput
  }

  export type QuestionResponseUpdateselectedOptionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type ExamAttemptUpdateOneRequiredWithoutResponsesNestedInput = {
    create?: XOR<ExamAttemptCreateWithoutResponsesInput, ExamAttemptUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutResponsesInput
    upsert?: ExamAttemptUpsertWithoutResponsesInput
    connect?: ExamAttemptWhereUniqueInput
    update?: XOR<XOR<ExamAttemptUpdateToOneWithWhereWithoutResponsesInput, ExamAttemptUpdateWithoutResponsesInput>, ExamAttemptUncheckedUpdateWithoutResponsesInput>
  }

  export type QuestionUpdateOneRequiredWithoutResponsesNestedInput = {
    create?: XOR<QuestionCreateWithoutResponsesInput, QuestionUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutResponsesInput
    upsert?: QuestionUpsertWithoutResponsesInput
    connect?: QuestionWhereUniqueInput
    update?: XOR<XOR<QuestionUpdateToOneWithWhereWithoutResponsesInput, QuestionUpdateWithoutResponsesInput>, QuestionUncheckedUpdateWithoutResponsesInput>
  }

  export type UserUpdateOneRequiredWithoutQuestionResponsesNestedInput = {
    create?: XOR<UserCreateWithoutQuestionResponsesInput, UserUncheckedCreateWithoutQuestionResponsesInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuestionResponsesInput
    upsert?: UserUpsertWithoutQuestionResponsesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutQuestionResponsesInput, UserUpdateWithoutQuestionResponsesInput>, UserUncheckedUpdateWithoutQuestionResponsesInput>
  }

  export type QuestionScoreUpdateOneWithoutResponseNestedInput = {
    create?: XOR<QuestionScoreCreateWithoutResponseInput, QuestionScoreUncheckedCreateWithoutResponseInput>
    connectOrCreate?: QuestionScoreCreateOrConnectWithoutResponseInput
    upsert?: QuestionScoreUpsertWithoutResponseInput
    disconnect?: QuestionScoreWhereInput | boolean
    delete?: QuestionScoreWhereInput | boolean
    connect?: QuestionScoreWhereUniqueInput
    update?: XOR<XOR<QuestionScoreUpdateToOneWithWhereWithoutResponseInput, QuestionScoreUpdateWithoutResponseInput>, QuestionScoreUncheckedUpdateWithoutResponseInput>
  }

  export type QuestionScoreUncheckedUpdateOneWithoutResponseNestedInput = {
    create?: XOR<QuestionScoreCreateWithoutResponseInput, QuestionScoreUncheckedCreateWithoutResponseInput>
    connectOrCreate?: QuestionScoreCreateOrConnectWithoutResponseInput
    upsert?: QuestionScoreUpsertWithoutResponseInput
    disconnect?: QuestionScoreWhereInput | boolean
    delete?: QuestionScoreWhereInput | boolean
    connect?: QuestionScoreWhereUniqueInput
    update?: XOR<XOR<QuestionScoreUpdateToOneWithWhereWithoutResponseInput, QuestionScoreUpdateWithoutResponseInput>, QuestionScoreUncheckedUpdateWithoutResponseInput>
  }

  export type QuestionResponseCreateNestedOneWithoutScoreInput = {
    create?: XOR<QuestionResponseCreateWithoutScoreInput, QuestionResponseUncheckedCreateWithoutScoreInput>
    connectOrCreate?: QuestionResponseCreateOrConnectWithoutScoreInput
    connect?: QuestionResponseWhereUniqueInput
  }

  export type QuestionCreateNestedOneWithoutScoresInput = {
    create?: XOR<QuestionCreateWithoutScoresInput, QuestionUncheckedCreateWithoutScoresInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutScoresInput
    connect?: QuestionWhereUniqueInput
  }

  export type ExamAttemptCreateNestedOneWithoutQuestionScoresInput = {
    create?: XOR<ExamAttemptCreateWithoutQuestionScoresInput, ExamAttemptUncheckedCreateWithoutQuestionScoresInput>
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutQuestionScoresInput
    connect?: ExamAttemptWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutQuestionScoresInput = {
    create?: XOR<UserCreateWithoutQuestionScoresInput, UserUncheckedCreateWithoutQuestionScoresInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuestionScoresInput
    connect?: UserWhereUniqueInput
  }

  export type QuestionResponseUpdateOneRequiredWithoutScoreNestedInput = {
    create?: XOR<QuestionResponseCreateWithoutScoreInput, QuestionResponseUncheckedCreateWithoutScoreInput>
    connectOrCreate?: QuestionResponseCreateOrConnectWithoutScoreInput
    upsert?: QuestionResponseUpsertWithoutScoreInput
    connect?: QuestionResponseWhereUniqueInput
    update?: XOR<XOR<QuestionResponseUpdateToOneWithWhereWithoutScoreInput, QuestionResponseUpdateWithoutScoreInput>, QuestionResponseUncheckedUpdateWithoutScoreInput>
  }

  export type QuestionUpdateOneRequiredWithoutScoresNestedInput = {
    create?: XOR<QuestionCreateWithoutScoresInput, QuestionUncheckedCreateWithoutScoresInput>
    connectOrCreate?: QuestionCreateOrConnectWithoutScoresInput
    upsert?: QuestionUpsertWithoutScoresInput
    connect?: QuestionWhereUniqueInput
    update?: XOR<XOR<QuestionUpdateToOneWithWhereWithoutScoresInput, QuestionUpdateWithoutScoresInput>, QuestionUncheckedUpdateWithoutScoresInput>
  }

  export type ExamAttemptUpdateOneRequiredWithoutQuestionScoresNestedInput = {
    create?: XOR<ExamAttemptCreateWithoutQuestionScoresInput, ExamAttemptUncheckedCreateWithoutQuestionScoresInput>
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutQuestionScoresInput
    upsert?: ExamAttemptUpsertWithoutQuestionScoresInput
    connect?: ExamAttemptWhereUniqueInput
    update?: XOR<XOR<ExamAttemptUpdateToOneWithWhereWithoutQuestionScoresInput, ExamAttemptUpdateWithoutQuestionScoresInput>, ExamAttemptUncheckedUpdateWithoutQuestionScoresInput>
  }

  export type UserUpdateOneRequiredWithoutQuestionScoresNestedInput = {
    create?: XOR<UserCreateWithoutQuestionScoresInput, UserUncheckedCreateWithoutQuestionScoresInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuestionScoresInput
    upsert?: UserUpsertWithoutQuestionScoresInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutQuestionScoresInput, UserUpdateWithoutQuestionScoresInput>, UserUncheckedUpdateWithoutQuestionScoresInput>
  }

  export type ExamAttemptCreateNestedOneWithoutExamScoreInput = {
    create?: XOR<ExamAttemptCreateWithoutExamScoreInput, ExamAttemptUncheckedCreateWithoutExamScoreInput>
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutExamScoreInput
    connect?: ExamAttemptWhereUniqueInput
  }

  export type ExamCreateNestedOneWithoutExamScoresInput = {
    create?: XOR<ExamCreateWithoutExamScoresInput, ExamUncheckedCreateWithoutExamScoresInput>
    connectOrCreate?: ExamCreateOrConnectWithoutExamScoresInput
    connect?: ExamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutExamScoresInput = {
    create?: XOR<UserCreateWithoutExamScoresInput, UserUncheckedCreateWithoutExamScoresInput>
    connectOrCreate?: UserCreateOrConnectWithoutExamScoresInput
    connect?: UserWhereUniqueInput
  }

  export type ExamAttemptUpdateOneRequiredWithoutExamScoreNestedInput = {
    create?: XOR<ExamAttemptCreateWithoutExamScoreInput, ExamAttemptUncheckedCreateWithoutExamScoreInput>
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutExamScoreInput
    upsert?: ExamAttemptUpsertWithoutExamScoreInput
    connect?: ExamAttemptWhereUniqueInput
    update?: XOR<XOR<ExamAttemptUpdateToOneWithWhereWithoutExamScoreInput, ExamAttemptUpdateWithoutExamScoreInput>, ExamAttemptUncheckedUpdateWithoutExamScoreInput>
  }

  export type ExamUpdateOneRequiredWithoutExamScoresNestedInput = {
    create?: XOR<ExamCreateWithoutExamScoresInput, ExamUncheckedCreateWithoutExamScoresInput>
    connectOrCreate?: ExamCreateOrConnectWithoutExamScoresInput
    upsert?: ExamUpsertWithoutExamScoresInput
    connect?: ExamWhereUniqueInput
    update?: XOR<XOR<ExamUpdateToOneWithWhereWithoutExamScoresInput, ExamUpdateWithoutExamScoresInput>, ExamUncheckedUpdateWithoutExamScoresInput>
  }

  export type UserUpdateOneRequiredWithoutExamScoresNestedInput = {
    create?: XOR<UserCreateWithoutExamScoresInput, UserUncheckedCreateWithoutExamScoresInput>
    connectOrCreate?: UserCreateOrConnectWithoutExamScoresInput
    upsert?: UserUpsertWithoutExamScoresInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExamScoresInput, UserUpdateWithoutExamScoresInput>, UserUncheckedUpdateWithoutExamScoresInput>
  }

  export type UserCreateNestedOneWithoutUserPerformancesInput = {
    create?: XOR<UserCreateWithoutUserPerformancesInput, UserUncheckedCreateWithoutUserPerformancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPerformancesInput
    connect?: UserWhereUniqueInput
  }

  export type ExamCategoryCreateNestedOneWithoutUserPerformancesInput = {
    create?: XOR<ExamCategoryCreateWithoutUserPerformancesInput, ExamCategoryUncheckedCreateWithoutUserPerformancesInput>
    connectOrCreate?: ExamCategoryCreateOrConnectWithoutUserPerformancesInput
    connect?: ExamCategoryWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUserPerformancesNestedInput = {
    create?: XOR<UserCreateWithoutUserPerformancesInput, UserUncheckedCreateWithoutUserPerformancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPerformancesInput
    upsert?: UserUpsertWithoutUserPerformancesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserPerformancesInput, UserUpdateWithoutUserPerformancesInput>, UserUncheckedUpdateWithoutUserPerformancesInput>
  }

  export type ExamCategoryUpdateOneWithoutUserPerformancesNestedInput = {
    create?: XOR<ExamCategoryCreateWithoutUserPerformancesInput, ExamCategoryUncheckedCreateWithoutUserPerformancesInput>
    connectOrCreate?: ExamCategoryCreateOrConnectWithoutUserPerformancesInput
    upsert?: ExamCategoryUpsertWithoutUserPerformancesInput
    disconnect?: ExamCategoryWhereInput | boolean
    delete?: ExamCategoryWhereInput | boolean
    connect?: ExamCategoryWhereUniqueInput
    update?: XOR<XOR<ExamCategoryUpdateToOneWithWhereWithoutUserPerformancesInput, ExamCategoryUpdateWithoutUserPerformancesInput>, ExamCategoryUncheckedUpdateWithoutUserPerformancesInput>
  }

  export type UserCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    connect?: UserWhereUniqueInput
  }

  export type ExamBookingCreateNestedOneWithoutPaymentInput = {
    create?: XOR<ExamBookingCreateWithoutPaymentInput, ExamBookingUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: ExamBookingCreateOrConnectWithoutPaymentInput
    connect?: ExamBookingWhereUniqueInput
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type UserUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput
    upsert?: UserUpsertWithoutPaymentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentsInput, UserUpdateWithoutPaymentsInput>, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type ExamBookingUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<ExamBookingCreateWithoutPaymentInput, ExamBookingUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: ExamBookingCreateOrConnectWithoutPaymentInput
    upsert?: ExamBookingUpsertWithoutPaymentInput
    disconnect?: ExamBookingWhereInput | boolean
    delete?: ExamBookingWhereInput | boolean
    connect?: ExamBookingWhereUniqueInput
    update?: XOR<XOR<ExamBookingUpdateToOneWithWhereWithoutPaymentInput, ExamBookingUpdateWithoutPaymentInput>, ExamBookingUncheckedUpdateWithoutPaymentInput>
  }

  export type UserCreateNestedOneWithoutCertificatesInput = {
    create?: XOR<UserCreateWithoutCertificatesInput, UserUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCertificatesInput
    connect?: UserWhereUniqueInput
  }

  export type ExamCreateNestedOneWithoutCertificatesInput = {
    create?: XOR<ExamCreateWithoutCertificatesInput, ExamUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: ExamCreateOrConnectWithoutCertificatesInput
    connect?: ExamWhereUniqueInput
  }

  export type ExamAttemptCreateNestedOneWithoutCertificateInput = {
    create?: XOR<ExamAttemptCreateWithoutCertificateInput, ExamAttemptUncheckedCreateWithoutCertificateInput>
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutCertificateInput
    connect?: ExamAttemptWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRevokedCertificatesInput = {
    create?: XOR<UserCreateWithoutRevokedCertificatesInput, UserUncheckedCreateWithoutRevokedCertificatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRevokedCertificatesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCertificatesNestedInput = {
    create?: XOR<UserCreateWithoutCertificatesInput, UserUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCertificatesInput
    upsert?: UserUpsertWithoutCertificatesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCertificatesInput, UserUpdateWithoutCertificatesInput>, UserUncheckedUpdateWithoutCertificatesInput>
  }

  export type ExamUpdateOneRequiredWithoutCertificatesNestedInput = {
    create?: XOR<ExamCreateWithoutCertificatesInput, ExamUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: ExamCreateOrConnectWithoutCertificatesInput
    upsert?: ExamUpsertWithoutCertificatesInput
    connect?: ExamWhereUniqueInput
    update?: XOR<XOR<ExamUpdateToOneWithWhereWithoutCertificatesInput, ExamUpdateWithoutCertificatesInput>, ExamUncheckedUpdateWithoutCertificatesInput>
  }

  export type ExamAttemptUpdateOneRequiredWithoutCertificateNestedInput = {
    create?: XOR<ExamAttemptCreateWithoutCertificateInput, ExamAttemptUncheckedCreateWithoutCertificateInput>
    connectOrCreate?: ExamAttemptCreateOrConnectWithoutCertificateInput
    upsert?: ExamAttemptUpsertWithoutCertificateInput
    connect?: ExamAttemptWhereUniqueInput
    update?: XOR<XOR<ExamAttemptUpdateToOneWithWhereWithoutCertificateInput, ExamAttemptUpdateWithoutCertificateInput>, ExamAttemptUncheckedUpdateWithoutCertificateInput>
  }

  export type UserUpdateOneWithoutRevokedCertificatesNestedInput = {
    create?: XOR<UserCreateWithoutRevokedCertificatesInput, UserUncheckedCreateWithoutRevokedCertificatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRevokedCertificatesInput
    upsert?: UserUpsertWithoutRevokedCertificatesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRevokedCertificatesInput, UserUpdateWithoutRevokedCertificatesInput>, UserUncheckedUpdateWithoutRevokedCertificatesInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutCreatedStudyGroupsInput = {
    create?: XOR<UserCreateWithoutCreatedStudyGroupsInput, UserUncheckedCreateWithoutCreatedStudyGroupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedStudyGroupsInput
    connect?: UserWhereUniqueInput
  }

  export type StudyGroupMemberCreateNestedManyWithoutGroupInput = {
    create?: XOR<StudyGroupMemberCreateWithoutGroupInput, StudyGroupMemberUncheckedCreateWithoutGroupInput> | StudyGroupMemberCreateWithoutGroupInput[] | StudyGroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: StudyGroupMemberCreateOrConnectWithoutGroupInput | StudyGroupMemberCreateOrConnectWithoutGroupInput[]
    createMany?: StudyGroupMemberCreateManyGroupInputEnvelope
    connect?: StudyGroupMemberWhereUniqueInput | StudyGroupMemberWhereUniqueInput[]
  }

  export type StudyGroupMemberUncheckedCreateNestedManyWithoutGroupInput = {
    create?: XOR<StudyGroupMemberCreateWithoutGroupInput, StudyGroupMemberUncheckedCreateWithoutGroupInput> | StudyGroupMemberCreateWithoutGroupInput[] | StudyGroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: StudyGroupMemberCreateOrConnectWithoutGroupInput | StudyGroupMemberCreateOrConnectWithoutGroupInput[]
    createMany?: StudyGroupMemberCreateManyGroupInputEnvelope
    connect?: StudyGroupMemberWhereUniqueInput | StudyGroupMemberWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutCreatedStudyGroupsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedStudyGroupsInput, UserUncheckedCreateWithoutCreatedStudyGroupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedStudyGroupsInput
    upsert?: UserUpsertWithoutCreatedStudyGroupsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedStudyGroupsInput, UserUpdateWithoutCreatedStudyGroupsInput>, UserUncheckedUpdateWithoutCreatedStudyGroupsInput>
  }

  export type StudyGroupMemberUpdateManyWithoutGroupNestedInput = {
    create?: XOR<StudyGroupMemberCreateWithoutGroupInput, StudyGroupMemberUncheckedCreateWithoutGroupInput> | StudyGroupMemberCreateWithoutGroupInput[] | StudyGroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: StudyGroupMemberCreateOrConnectWithoutGroupInput | StudyGroupMemberCreateOrConnectWithoutGroupInput[]
    upsert?: StudyGroupMemberUpsertWithWhereUniqueWithoutGroupInput | StudyGroupMemberUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: StudyGroupMemberCreateManyGroupInputEnvelope
    set?: StudyGroupMemberWhereUniqueInput | StudyGroupMemberWhereUniqueInput[]
    disconnect?: StudyGroupMemberWhereUniqueInput | StudyGroupMemberWhereUniqueInput[]
    delete?: StudyGroupMemberWhereUniqueInput | StudyGroupMemberWhereUniqueInput[]
    connect?: StudyGroupMemberWhereUniqueInput | StudyGroupMemberWhereUniqueInput[]
    update?: StudyGroupMemberUpdateWithWhereUniqueWithoutGroupInput | StudyGroupMemberUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: StudyGroupMemberUpdateManyWithWhereWithoutGroupInput | StudyGroupMemberUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: StudyGroupMemberScalarWhereInput | StudyGroupMemberScalarWhereInput[]
  }

  export type StudyGroupMemberUncheckedUpdateManyWithoutGroupNestedInput = {
    create?: XOR<StudyGroupMemberCreateWithoutGroupInput, StudyGroupMemberUncheckedCreateWithoutGroupInput> | StudyGroupMemberCreateWithoutGroupInput[] | StudyGroupMemberUncheckedCreateWithoutGroupInput[]
    connectOrCreate?: StudyGroupMemberCreateOrConnectWithoutGroupInput | StudyGroupMemberCreateOrConnectWithoutGroupInput[]
    upsert?: StudyGroupMemberUpsertWithWhereUniqueWithoutGroupInput | StudyGroupMemberUpsertWithWhereUniqueWithoutGroupInput[]
    createMany?: StudyGroupMemberCreateManyGroupInputEnvelope
    set?: StudyGroupMemberWhereUniqueInput | StudyGroupMemberWhereUniqueInput[]
    disconnect?: StudyGroupMemberWhereUniqueInput | StudyGroupMemberWhereUniqueInput[]
    delete?: StudyGroupMemberWhereUniqueInput | StudyGroupMemberWhereUniqueInput[]
    connect?: StudyGroupMemberWhereUniqueInput | StudyGroupMemberWhereUniqueInput[]
    update?: StudyGroupMemberUpdateWithWhereUniqueWithoutGroupInput | StudyGroupMemberUpdateWithWhereUniqueWithoutGroupInput[]
    updateMany?: StudyGroupMemberUpdateManyWithWhereWithoutGroupInput | StudyGroupMemberUpdateManyWithWhereWithoutGroupInput[]
    deleteMany?: StudyGroupMemberScalarWhereInput | StudyGroupMemberScalarWhereInput[]
  }

  export type StudyGroupCreateNestedOneWithoutMembersInput = {
    create?: XOR<StudyGroupCreateWithoutMembersInput, StudyGroupUncheckedCreateWithoutMembersInput>
    connectOrCreate?: StudyGroupCreateOrConnectWithoutMembersInput
    connect?: StudyGroupWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutStudyGroupsInput = {
    create?: XOR<UserCreateWithoutStudyGroupsInput, UserUncheckedCreateWithoutStudyGroupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudyGroupsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumGroupRoleFieldUpdateOperationsInput = {
    set?: $Enums.GroupRole
  }

  export type StudyGroupUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<StudyGroupCreateWithoutMembersInput, StudyGroupUncheckedCreateWithoutMembersInput>
    connectOrCreate?: StudyGroupCreateOrConnectWithoutMembersInput
    upsert?: StudyGroupUpsertWithoutMembersInput
    connect?: StudyGroupWhereUniqueInput
    update?: XOR<XOR<StudyGroupUpdateToOneWithWhereWithoutMembersInput, StudyGroupUpdateWithoutMembersInput>, StudyGroupUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutStudyGroupsNestedInput = {
    create?: XOR<UserCreateWithoutStudyGroupsInput, UserUncheckedCreateWithoutStudyGroupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudyGroupsInput
    upsert?: UserUpsertWithoutStudyGroupsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStudyGroupsInput, UserUpdateWithoutStudyGroupsInput>, UserUncheckedUpdateWithoutStudyGroupsInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type ExamCategoryCreateNestedOneWithoutUsersInput = {
    create?: XOR<ExamCategoryCreateWithoutUsersInput, ExamCategoryUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ExamCategoryCreateOrConnectWithoutUsersInput
    connect?: ExamCategoryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutExamCategoriesInput = {
    create?: XOR<UserCreateWithoutExamCategoriesInput, UserUncheckedCreateWithoutExamCategoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutExamCategoriesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGrantedExamCategoriesInput = {
    create?: XOR<UserCreateWithoutGrantedExamCategoriesInput, UserUncheckedCreateWithoutGrantedExamCategoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutGrantedExamCategoriesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAccessLevelFieldUpdateOperationsInput = {
    set?: $Enums.AccessLevel
  }

  export type ExamCategoryUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<ExamCategoryCreateWithoutUsersInput, ExamCategoryUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ExamCategoryCreateOrConnectWithoutUsersInput
    upsert?: ExamCategoryUpsertWithoutUsersInput
    connect?: ExamCategoryWhereUniqueInput
    update?: XOR<XOR<ExamCategoryUpdateToOneWithWhereWithoutUsersInput, ExamCategoryUpdateWithoutUsersInput>, ExamCategoryUncheckedUpdateWithoutUsersInput>
  }

  export type UserUpdateOneRequiredWithoutExamCategoriesNestedInput = {
    create?: XOR<UserCreateWithoutExamCategoriesInput, UserUncheckedCreateWithoutExamCategoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutExamCategoriesInput
    upsert?: UserUpsertWithoutExamCategoriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExamCategoriesInput, UserUpdateWithoutExamCategoriesInput>, UserUncheckedUpdateWithoutExamCategoriesInput>
  }

  export type UserUpdateOneRequiredWithoutGrantedExamCategoriesNestedInput = {
    create?: XOR<UserCreateWithoutGrantedExamCategoriesInput, UserUncheckedCreateWithoutGrantedExamCategoriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutGrantedExamCategoriesInput
    upsert?: UserUpsertWithoutGrantedExamCategoriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGrantedExamCategoriesInput, UserUpdateWithoutGrantedExamCategoriesInput>, UserUncheckedUpdateWithoutGrantedExamCategoriesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumQuestionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeFilter<$PrismaModel> | $Enums.QuestionType
  }

  export type NestedEnumQuestionDifficultyFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionDifficulty | EnumQuestionDifficultyFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionDifficulty[] | ListEnumQuestionDifficultyFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionDifficulty[] | ListEnumQuestionDifficultyFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionDifficultyFilter<$PrismaModel> | $Enums.QuestionDifficulty
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumQuestionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeWithAggregatesFilter<$PrismaModel> | $Enums.QuestionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionTypeFilter<$PrismaModel>
    _max?: NestedEnumQuestionTypeFilter<$PrismaModel>
  }

  export type NestedEnumQuestionDifficultyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionDifficulty | EnumQuestionDifficultyFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionDifficulty[] | ListEnumQuestionDifficultyFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionDifficulty[] | ListEnumQuestionDifficultyFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionDifficultyWithAggregatesFilter<$PrismaModel> | $Enums.QuestionDifficulty
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionDifficultyFilter<$PrismaModel>
    _max?: NestedEnumQuestionDifficultyFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type NestedEnumAttemptStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttemptStatus | EnumAttemptStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttemptStatus[] | ListEnumAttemptStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttemptStatus[] | ListEnumAttemptStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttemptStatusFilter<$PrismaModel> | $Enums.AttemptStatus
  }

  export type NestedEnumAttemptStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttemptStatus | EnumAttemptStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttemptStatus[] | ListEnumAttemptStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttemptStatus[] | ListEnumAttemptStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttemptStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttemptStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttemptStatusFilter<$PrismaModel>
    _max?: NestedEnumAttemptStatusFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumGroupRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupRole | EnumGroupRoleFieldRefInput<$PrismaModel>
    in?: $Enums.GroupRole[] | ListEnumGroupRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.GroupRole[] | ListEnumGroupRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupRoleFilter<$PrismaModel> | $Enums.GroupRole
  }

  export type NestedEnumGroupRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GroupRole | EnumGroupRoleFieldRefInput<$PrismaModel>
    in?: $Enums.GroupRole[] | ListEnumGroupRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.GroupRole[] | ListEnumGroupRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumGroupRoleWithAggregatesFilter<$PrismaModel> | $Enums.GroupRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGroupRoleFilter<$PrismaModel>
    _max?: NestedEnumGroupRoleFilter<$PrismaModel>
  }

  export type NestedEnumAccessLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessLevel | EnumAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessLevelFilter<$PrismaModel> | $Enums.AccessLevel
  }

  export type NestedEnumAccessLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessLevel | EnumAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessLevelWithAggregatesFilter<$PrismaModel> | $Enums.AccessLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccessLevelFilter<$PrismaModel>
    _max?: NestedEnumAccessLevelFilter<$PrismaModel>
  }

  export type ExamBookingCreateWithoutUserInput = {
    id?: string
    bookingDate?: Date | string
    scheduledAt?: Date | string | null
    status?: $Enums.BookingStatus
    paymentId?: string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exam: ExamCreateNestedOneWithoutBookingsInput
    payment?: PaymentCreateNestedOneWithoutBookingInput
    attempts?: ExamAttemptCreateNestedManyWithoutBookingInput
  }

  export type ExamBookingUncheckedCreateWithoutUserInput = {
    id?: string
    examId: string
    bookingDate?: Date | string
    scheduledAt?: Date | string | null
    status?: $Enums.BookingStatus
    paymentId?: string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payment?: PaymentUncheckedCreateNestedOneWithoutBookingInput
    attempts?: ExamAttemptUncheckedCreateNestedManyWithoutBookingInput
  }

  export type ExamBookingCreateOrConnectWithoutUserInput = {
    where: ExamBookingWhereUniqueInput
    create: XOR<ExamBookingCreateWithoutUserInput, ExamBookingUncheckedCreateWithoutUserInput>
  }

  export type ExamBookingCreateManyUserInputEnvelope = {
    data: ExamBookingCreateManyUserInput | ExamBookingCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutUserInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    stripePaymentId?: string | null
    stripeRefundId?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    refundedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking?: ExamBookingCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateWithoutUserInput = {
    id?: string
    bookingId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    stripePaymentId?: string | null
    stripeRefundId?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    refundedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutUserInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentCreateManyUserInputEnvelope = {
    data: PaymentCreateManyUserInput | PaymentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ExamAttemptCreateWithoutUserInput = {
    id?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.AttemptStatus
    totalMarks?: number
    obtainedMarks?: number
    percentage?: number
    isPassed?: boolean
    timeSpent?: number | null
    ipAddress?: string | null
    userAgent?: string | null
    isCheating?: boolean
    cheatingReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exam: ExamCreateNestedOneWithoutAttemptsInput
    booking?: ExamBookingCreateNestedOneWithoutAttemptsInput
    responses?: QuestionResponseCreateNestedManyWithoutAttemptInput
    questionScores?: QuestionScoreCreateNestedManyWithoutAttemptInput
    examScore?: ExamScoreCreateNestedOneWithoutAttemptInput
    certificate?: CertificateCreateNestedOneWithoutAttemptInput
  }

  export type ExamAttemptUncheckedCreateWithoutUserInput = {
    id?: string
    examId: string
    bookingId?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.AttemptStatus
    totalMarks?: number
    obtainedMarks?: number
    percentage?: number
    isPassed?: boolean
    timeSpent?: number | null
    ipAddress?: string | null
    userAgent?: string | null
    isCheating?: boolean
    cheatingReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: QuestionResponseUncheckedCreateNestedManyWithoutAttemptInput
    questionScores?: QuestionScoreUncheckedCreateNestedManyWithoutAttemptInput
    examScore?: ExamScoreUncheckedCreateNestedOneWithoutAttemptInput
    certificate?: CertificateUncheckedCreateNestedOneWithoutAttemptInput
  }

  export type ExamAttemptCreateOrConnectWithoutUserInput = {
    where: ExamAttemptWhereUniqueInput
    create: XOR<ExamAttemptCreateWithoutUserInput, ExamAttemptUncheckedCreateWithoutUserInput>
  }

  export type ExamAttemptCreateManyUserInputEnvelope = {
    data: ExamAttemptCreateManyUserInput | ExamAttemptCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type QuestionResponseCreateWithoutUserInput = {
    id?: string
    selectedOptions?: QuestionResponseCreateselectedOptionsInput | string[]
    isCorrect?: boolean | null
    marksObtained?: number
    timeSpent?: number | null
    answeredAt?: Date | string
    submittedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    attempt: ExamAttemptCreateNestedOneWithoutResponsesInput
    question: QuestionCreateNestedOneWithoutResponsesInput
    score?: QuestionScoreCreateNestedOneWithoutResponseInput
  }

  export type QuestionResponseUncheckedCreateWithoutUserInput = {
    id?: string
    attemptId: string
    questionId: string
    selectedOptions?: QuestionResponseCreateselectedOptionsInput | string[]
    isCorrect?: boolean | null
    marksObtained?: number
    timeSpent?: number | null
    answeredAt?: Date | string
    submittedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    score?: QuestionScoreUncheckedCreateNestedOneWithoutResponseInput
  }

  export type QuestionResponseCreateOrConnectWithoutUserInput = {
    where: QuestionResponseWhereUniqueInput
    create: XOR<QuestionResponseCreateWithoutUserInput, QuestionResponseUncheckedCreateWithoutUserInput>
  }

  export type QuestionResponseCreateManyUserInputEnvelope = {
    data: QuestionResponseCreateManyUserInput | QuestionResponseCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type QuestionScoreCreateWithoutUserInput = {
    id?: string
    isCorrect?: boolean
    marksObtained?: number
    maxMarks?: number
    accuracy?: number
    timeEfficiency?: number
    difficultyBonus?: number
    penalty?: number
    responseTime?: number
    attemptsCount?: number
    confidenceLevel?: number
    questionDifficulty: string
    scoredAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    response: QuestionResponseCreateNestedOneWithoutScoreInput
    question: QuestionCreateNestedOneWithoutScoresInput
    attempt: ExamAttemptCreateNestedOneWithoutQuestionScoresInput
  }

  export type QuestionScoreUncheckedCreateWithoutUserInput = {
    id?: string
    responseId: string
    questionId: string
    attemptId: string
    isCorrect?: boolean
    marksObtained?: number
    maxMarks?: number
    accuracy?: number
    timeEfficiency?: number
    difficultyBonus?: number
    penalty?: number
    responseTime?: number
    attemptsCount?: number
    confidenceLevel?: number
    questionDifficulty: string
    scoredAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionScoreCreateOrConnectWithoutUserInput = {
    where: QuestionScoreWhereUniqueInput
    create: XOR<QuestionScoreCreateWithoutUserInput, QuestionScoreUncheckedCreateWithoutUserInput>
  }

  export type QuestionScoreCreateManyUserInputEnvelope = {
    data: QuestionScoreCreateManyUserInput | QuestionScoreCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ExamScoreCreateWithoutUserInput = {
    id?: string
    totalMarks?: number
    maxMarks?: number
    percentage?: number
    grade?: string | null
    correctAnswers?: number
    wrongAnswers?: number
    unanswered?: number
    totalQuestions?: number
    totalTimeSpent?: number
    averageTimePerQuestion?: number
    timeEfficiency?: number
    easyCorrect?: number
    easyTotal?: number
    mediumCorrect?: number
    mediumTotal?: number
    hardCorrect?: number
    hardTotal?: number
    accuracy?: number
    speedScore?: number
    consistencyScore?: number
    difficultyScore?: number
    percentile?: number | null
    rank?: number | null
    improvement?: number | null
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    attempt: ExamAttemptCreateNestedOneWithoutExamScoreInput
    exam: ExamCreateNestedOneWithoutExamScoresInput
  }

  export type ExamScoreUncheckedCreateWithoutUserInput = {
    id?: string
    attemptId: string
    examId: string
    totalMarks?: number
    maxMarks?: number
    percentage?: number
    grade?: string | null
    correctAnswers?: number
    wrongAnswers?: number
    unanswered?: number
    totalQuestions?: number
    totalTimeSpent?: number
    averageTimePerQuestion?: number
    timeEfficiency?: number
    easyCorrect?: number
    easyTotal?: number
    mediumCorrect?: number
    mediumTotal?: number
    hardCorrect?: number
    hardTotal?: number
    accuracy?: number
    speedScore?: number
    consistencyScore?: number
    difficultyScore?: number
    percentile?: number | null
    rank?: number | null
    improvement?: number | null
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamScoreCreateOrConnectWithoutUserInput = {
    where: ExamScoreWhereUniqueInput
    create: XOR<ExamScoreCreateWithoutUserInput, ExamScoreUncheckedCreateWithoutUserInput>
  }

  export type ExamScoreCreateManyUserInputEnvelope = {
    data: ExamScoreCreateManyUserInput | ExamScoreCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserPerformanceCreateWithoutUserInput = {
    id?: string
    totalAttempts?: number
    totalPassed?: number
    totalFailed?: number
    passRate?: number
    averageScore?: number
    highestScore?: number
    lowestScore?: number
    totalMarks?: number
    totalTimeSpent?: number
    averageTimePerExam?: number
    easyAccuracy?: number
    mediumAccuracy?: number
    hardAccuracy?: number
    improvementRate?: number
    consistencyScore?: number
    learningCurve?: number
    lastAttemptAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examCategory?: ExamCategoryCreateNestedOneWithoutUserPerformancesInput
  }

  export type UserPerformanceUncheckedCreateWithoutUserInput = {
    id?: string
    examCategoryId?: string | null
    totalAttempts?: number
    totalPassed?: number
    totalFailed?: number
    passRate?: number
    averageScore?: number
    highestScore?: number
    lowestScore?: number
    totalMarks?: number
    totalTimeSpent?: number
    averageTimePerExam?: number
    easyAccuracy?: number
    mediumAccuracy?: number
    hardAccuracy?: number
    improvementRate?: number
    consistencyScore?: number
    learningCurve?: number
    lastAttemptAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPerformanceCreateOrConnectWithoutUserInput = {
    where: UserPerformanceWhereUniqueInput
    create: XOR<UserPerformanceCreateWithoutUserInput, UserPerformanceUncheckedCreateWithoutUserInput>
  }

  export type UserPerformanceCreateManyUserInputEnvelope = {
    data: UserPerformanceCreateManyUserInput | UserPerformanceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserSessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type UserSessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type UserSessionCreateOrConnectWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionCreateManyUserInputEnvelope = {
    data: UserSessionCreateManyUserInput | UserSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ExamCategoryUserCreateWithoutUserInput = {
    id?: string
    accessLevel?: $Enums.AccessLevel
    grantedAt?: Date | string
    examCategory: ExamCategoryCreateNestedOneWithoutUsersInput
    granter: UserCreateNestedOneWithoutGrantedExamCategoriesInput
  }

  export type ExamCategoryUserUncheckedCreateWithoutUserInput = {
    id?: string
    examCategoryId: string
    accessLevel?: $Enums.AccessLevel
    grantedAt?: Date | string
    grantedBy: string
  }

  export type ExamCategoryUserCreateOrConnectWithoutUserInput = {
    where: ExamCategoryUserWhereUniqueInput
    create: XOR<ExamCategoryUserCreateWithoutUserInput, ExamCategoryUserUncheckedCreateWithoutUserInput>
  }

  export type ExamCategoryUserCreateManyUserInputEnvelope = {
    data: ExamCategoryUserCreateManyUserInput | ExamCategoryUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StudyGroupMemberCreateWithoutUserInput = {
    id?: string
    role?: $Enums.GroupRole
    joinedAt?: Date | string
    isActive?: boolean
    group: StudyGroupCreateNestedOneWithoutMembersInput
  }

  export type StudyGroupMemberUncheckedCreateWithoutUserInput = {
    id?: string
    groupId: string
    role?: $Enums.GroupRole
    joinedAt?: Date | string
    isActive?: boolean
  }

  export type StudyGroupMemberCreateOrConnectWithoutUserInput = {
    where: StudyGroupMemberWhereUniqueInput
    create: XOR<StudyGroupMemberCreateWithoutUserInput, StudyGroupMemberUncheckedCreateWithoutUserInput>
  }

  export type StudyGroupMemberCreateManyUserInputEnvelope = {
    data: StudyGroupMemberCreateManyUserInput | StudyGroupMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CertificateCreateWithoutUserInput = {
    id?: string
    certificateNumber: string
    issuedAt?: Date | string
    expiresAt?: Date | string | null
    isRevoked?: boolean
    revokedAt?: Date | string | null
    revokedReason?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exam: ExamCreateNestedOneWithoutCertificatesInput
    attempt: ExamAttemptCreateNestedOneWithoutCertificateInput
    revoker?: UserCreateNestedOneWithoutRevokedCertificatesInput
  }

  export type CertificateUncheckedCreateWithoutUserInput = {
    id?: string
    examId: string
    attemptId: string
    certificateNumber: string
    issuedAt?: Date | string
    expiresAt?: Date | string | null
    isRevoked?: boolean
    revokedAt?: Date | string | null
    revokedBy?: string | null
    revokedReason?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificateCreateOrConnectWithoutUserInput = {
    where: CertificateWhereUniqueInput
    create: XOR<CertificateCreateWithoutUserInput, CertificateUncheckedCreateWithoutUserInput>
  }

  export type CertificateCreateManyUserInputEnvelope = {
    data: CertificateCreateManyUserInput | CertificateCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ExamCategoryUserCreateWithoutGranterInput = {
    id?: string
    accessLevel?: $Enums.AccessLevel
    grantedAt?: Date | string
    examCategory: ExamCategoryCreateNestedOneWithoutUsersInput
    user: UserCreateNestedOneWithoutExamCategoriesInput
  }

  export type ExamCategoryUserUncheckedCreateWithoutGranterInput = {
    id?: string
    examCategoryId: string
    userId: string
    accessLevel?: $Enums.AccessLevel
    grantedAt?: Date | string
  }

  export type ExamCategoryUserCreateOrConnectWithoutGranterInput = {
    where: ExamCategoryUserWhereUniqueInput
    create: XOR<ExamCategoryUserCreateWithoutGranterInput, ExamCategoryUserUncheckedCreateWithoutGranterInput>
  }

  export type ExamCategoryUserCreateManyGranterInputEnvelope = {
    data: ExamCategoryUserCreateManyGranterInput | ExamCategoryUserCreateManyGranterInput[]
    skipDuplicates?: boolean
  }

  export type StudyGroupCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    isPrivate?: boolean
    maxMembers?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: StudyGroupMemberCreateNestedManyWithoutGroupInput
  }

  export type StudyGroupUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    isPrivate?: boolean
    maxMembers?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: StudyGroupMemberUncheckedCreateNestedManyWithoutGroupInput
  }

  export type StudyGroupCreateOrConnectWithoutCreatorInput = {
    where: StudyGroupWhereUniqueInput
    create: XOR<StudyGroupCreateWithoutCreatorInput, StudyGroupUncheckedCreateWithoutCreatorInput>
  }

  export type StudyGroupCreateManyCreatorInputEnvelope = {
    data: StudyGroupCreateManyCreatorInput | StudyGroupCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type QuestionCreateWithoutCreatorInput = {
    id?: string
    text: string
    type: $Enums.QuestionType
    difficulty: $Enums.QuestionDifficulty
    marks?: number
    timeLimit?: number | null
    isActive?: boolean
    isPublic?: boolean
    approvedAt?: Date | string | null
    usageCount?: number
    correctAnswerRate?: number | null
    averageTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examCategory: ExamCategoryCreateNestedOneWithoutQuestionsInput
    approver?: UserCreateNestedOneWithoutApprovedQuestionsInput
    options?: QuestionOptionCreateNestedManyWithoutQuestionInput
    images?: QuestionImageCreateNestedManyWithoutQuestionInput
    tags?: QuestionTagCreateNestedManyWithoutQuestionInput
    examQuestions?: ExamQuestionCreateNestedManyWithoutQuestionInput
    responses?: QuestionResponseCreateNestedManyWithoutQuestionInput
    scores?: QuestionScoreCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateWithoutCreatorInput = {
    id?: string
    text: string
    type: $Enums.QuestionType
    difficulty: $Enums.QuestionDifficulty
    examCategoryId: string
    marks?: number
    timeLimit?: number | null
    isActive?: boolean
    isPublic?: boolean
    approvedBy?: string | null
    approvedAt?: Date | string | null
    usageCount?: number
    correctAnswerRate?: number | null
    averageTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: QuestionOptionUncheckedCreateNestedManyWithoutQuestionInput
    images?: QuestionImageUncheckedCreateNestedManyWithoutQuestionInput
    tags?: QuestionTagUncheckedCreateNestedManyWithoutQuestionInput
    examQuestions?: ExamQuestionUncheckedCreateNestedManyWithoutQuestionInput
    responses?: QuestionResponseUncheckedCreateNestedManyWithoutQuestionInput
    scores?: QuestionScoreUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionCreateOrConnectWithoutCreatorInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutCreatorInput, QuestionUncheckedCreateWithoutCreatorInput>
  }

  export type QuestionCreateManyCreatorInputEnvelope = {
    data: QuestionCreateManyCreatorInput | QuestionCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type QuestionCreateWithoutApproverInput = {
    id?: string
    text: string
    type: $Enums.QuestionType
    difficulty: $Enums.QuestionDifficulty
    marks?: number
    timeLimit?: number | null
    isActive?: boolean
    isPublic?: boolean
    approvedAt?: Date | string | null
    usageCount?: number
    correctAnswerRate?: number | null
    averageTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examCategory: ExamCategoryCreateNestedOneWithoutQuestionsInput
    creator: UserCreateNestedOneWithoutCreatedQuestionsInput
    options?: QuestionOptionCreateNestedManyWithoutQuestionInput
    images?: QuestionImageCreateNestedManyWithoutQuestionInput
    tags?: QuestionTagCreateNestedManyWithoutQuestionInput
    examQuestions?: ExamQuestionCreateNestedManyWithoutQuestionInput
    responses?: QuestionResponseCreateNestedManyWithoutQuestionInput
    scores?: QuestionScoreCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateWithoutApproverInput = {
    id?: string
    text: string
    type: $Enums.QuestionType
    difficulty: $Enums.QuestionDifficulty
    examCategoryId: string
    marks?: number
    timeLimit?: number | null
    isActive?: boolean
    isPublic?: boolean
    createdBy: string
    approvedAt?: Date | string | null
    usageCount?: number
    correctAnswerRate?: number | null
    averageTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: QuestionOptionUncheckedCreateNestedManyWithoutQuestionInput
    images?: QuestionImageUncheckedCreateNestedManyWithoutQuestionInput
    tags?: QuestionTagUncheckedCreateNestedManyWithoutQuestionInput
    examQuestions?: ExamQuestionUncheckedCreateNestedManyWithoutQuestionInput
    responses?: QuestionResponseUncheckedCreateNestedManyWithoutQuestionInput
    scores?: QuestionScoreUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionCreateOrConnectWithoutApproverInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutApproverInput, QuestionUncheckedCreateWithoutApproverInput>
  }

  export type QuestionCreateManyApproverInputEnvelope = {
    data: QuestionCreateManyApproverInput | QuestionCreateManyApproverInput[]
    skipDuplicates?: boolean
  }

  export type ExamCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    duration: number
    totalMarks: number
    passingMarks: number
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    isActive?: boolean
    isPublic?: boolean
    allowRetakes?: boolean
    maxRetakes?: number
    showResults?: boolean
    showAnswers?: boolean
    randomizeQuestions?: boolean
    randomizeOptions?: boolean
    questionOverlapPercentage?: number
    approvedAt?: Date | string | null
    scheduledStart?: Date | string | null
    scheduledEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examCategory: ExamCategoryCreateNestedOneWithoutExamsInput
    approver?: UserCreateNestedOneWithoutApprovedExamsInput
    questions?: ExamQuestionCreateNestedManyWithoutExamInput
    bookings?: ExamBookingCreateNestedManyWithoutExamInput
    attempts?: ExamAttemptCreateNestedManyWithoutExamInput
    examScores?: ExamScoreCreateNestedManyWithoutExamInput
    certificates?: CertificateCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutCreatorInput = {
    id?: string
    title: string
    description?: string | null
    examCategoryId: string
    duration: number
    totalMarks: number
    passingMarks: number
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    isActive?: boolean
    isPublic?: boolean
    allowRetakes?: boolean
    maxRetakes?: number
    showResults?: boolean
    showAnswers?: boolean
    randomizeQuestions?: boolean
    randomizeOptions?: boolean
    questionOverlapPercentage?: number
    approvedBy?: string | null
    approvedAt?: Date | string | null
    scheduledStart?: Date | string | null
    scheduledEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: ExamQuestionUncheckedCreateNestedManyWithoutExamInput
    bookings?: ExamBookingUncheckedCreateNestedManyWithoutExamInput
    attempts?: ExamAttemptUncheckedCreateNestedManyWithoutExamInput
    examScores?: ExamScoreUncheckedCreateNestedManyWithoutExamInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutCreatorInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutCreatorInput, ExamUncheckedCreateWithoutCreatorInput>
  }

  export type ExamCreateManyCreatorInputEnvelope = {
    data: ExamCreateManyCreatorInput | ExamCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type ExamCreateWithoutApproverInput = {
    id?: string
    title: string
    description?: string | null
    duration: number
    totalMarks: number
    passingMarks: number
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    isActive?: boolean
    isPublic?: boolean
    allowRetakes?: boolean
    maxRetakes?: number
    showResults?: boolean
    showAnswers?: boolean
    randomizeQuestions?: boolean
    randomizeOptions?: boolean
    questionOverlapPercentage?: number
    approvedAt?: Date | string | null
    scheduledStart?: Date | string | null
    scheduledEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examCategory: ExamCategoryCreateNestedOneWithoutExamsInput
    creator: UserCreateNestedOneWithoutCreatedExamsInput
    questions?: ExamQuestionCreateNestedManyWithoutExamInput
    bookings?: ExamBookingCreateNestedManyWithoutExamInput
    attempts?: ExamAttemptCreateNestedManyWithoutExamInput
    examScores?: ExamScoreCreateNestedManyWithoutExamInput
    certificates?: CertificateCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutApproverInput = {
    id?: string
    title: string
    description?: string | null
    examCategoryId: string
    duration: number
    totalMarks: number
    passingMarks: number
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    isActive?: boolean
    isPublic?: boolean
    allowRetakes?: boolean
    maxRetakes?: number
    showResults?: boolean
    showAnswers?: boolean
    randomizeQuestions?: boolean
    randomizeOptions?: boolean
    questionOverlapPercentage?: number
    createdBy: string
    approvedAt?: Date | string | null
    scheduledStart?: Date | string | null
    scheduledEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: ExamQuestionUncheckedCreateNestedManyWithoutExamInput
    bookings?: ExamBookingUncheckedCreateNestedManyWithoutExamInput
    attempts?: ExamAttemptUncheckedCreateNestedManyWithoutExamInput
    examScores?: ExamScoreUncheckedCreateNestedManyWithoutExamInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutApproverInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutApproverInput, ExamUncheckedCreateWithoutApproverInput>
  }

  export type ExamCreateManyApproverInputEnvelope = {
    data: ExamCreateManyApproverInput | ExamCreateManyApproverInput[]
    skipDuplicates?: boolean
  }

  export type CertificateCreateWithoutRevokerInput = {
    id?: string
    certificateNumber: string
    issuedAt?: Date | string
    expiresAt?: Date | string | null
    isRevoked?: boolean
    revokedAt?: Date | string | null
    revokedReason?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCertificatesInput
    exam: ExamCreateNestedOneWithoutCertificatesInput
    attempt: ExamAttemptCreateNestedOneWithoutCertificateInput
  }

  export type CertificateUncheckedCreateWithoutRevokerInput = {
    id?: string
    userId: string
    examId: string
    attemptId: string
    certificateNumber: string
    issuedAt?: Date | string
    expiresAt?: Date | string | null
    isRevoked?: boolean
    revokedAt?: Date | string | null
    revokedReason?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificateCreateOrConnectWithoutRevokerInput = {
    where: CertificateWhereUniqueInput
    create: XOR<CertificateCreateWithoutRevokerInput, CertificateUncheckedCreateWithoutRevokerInput>
  }

  export type CertificateCreateManyRevokerInputEnvelope = {
    data: CertificateCreateManyRevokerInput | CertificateCreateManyRevokerInput[]
    skipDuplicates?: boolean
  }

  export type ExamBookingUpsertWithWhereUniqueWithoutUserInput = {
    where: ExamBookingWhereUniqueInput
    update: XOR<ExamBookingUpdateWithoutUserInput, ExamBookingUncheckedUpdateWithoutUserInput>
    create: XOR<ExamBookingCreateWithoutUserInput, ExamBookingUncheckedCreateWithoutUserInput>
  }

  export type ExamBookingUpdateWithWhereUniqueWithoutUserInput = {
    where: ExamBookingWhereUniqueInput
    data: XOR<ExamBookingUpdateWithoutUserInput, ExamBookingUncheckedUpdateWithoutUserInput>
  }

  export type ExamBookingUpdateManyWithWhereWithoutUserInput = {
    where: ExamBookingScalarWhereInput
    data: XOR<ExamBookingUpdateManyMutationInput, ExamBookingUncheckedUpdateManyWithoutUserInput>
  }

  export type ExamBookingScalarWhereInput = {
    AND?: ExamBookingScalarWhereInput | ExamBookingScalarWhereInput[]
    OR?: ExamBookingScalarWhereInput[]
    NOT?: ExamBookingScalarWhereInput | ExamBookingScalarWhereInput[]
    id?: StringFilter<"ExamBooking"> | string
    userId?: StringFilter<"ExamBooking"> | string
    examId?: StringFilter<"ExamBooking"> | string
    bookingDate?: DateTimeFilter<"ExamBooking"> | Date | string
    scheduledAt?: DateTimeNullableFilter<"ExamBooking"> | Date | string | null
    status?: EnumBookingStatusFilter<"ExamBooking"> | $Enums.BookingStatus
    paymentId?: StringNullableFilter<"ExamBooking"> | string | null
    totalAmount?: DecimalFilter<"ExamBooking"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"ExamBooking"> | string
    notes?: StringNullableFilter<"ExamBooking"> | string | null
    createdAt?: DateTimeFilter<"ExamBooking"> | Date | string
    updatedAt?: DateTimeFilter<"ExamBooking"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
    create: XOR<PaymentCreateWithoutUserInput, PaymentUncheckedCreateWithoutUserInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutUserInput, PaymentUncheckedUpdateWithoutUserInput>
  }

  export type PaymentUpdateManyWithWhereWithoutUserInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutUserInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    userId?: StringFilter<"Payment"> | string
    bookingId?: StringNullableFilter<"Payment"> | string | null
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    stripePaymentId?: StringNullableFilter<"Payment"> | string | null
    stripeRefundId?: StringNullableFilter<"Payment"> | string | null
    description?: StringNullableFilter<"Payment"> | string | null
    metadata?: JsonNullableFilter<"Payment">
    refundedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type ExamAttemptUpsertWithWhereUniqueWithoutUserInput = {
    where: ExamAttemptWhereUniqueInput
    update: XOR<ExamAttemptUpdateWithoutUserInput, ExamAttemptUncheckedUpdateWithoutUserInput>
    create: XOR<ExamAttemptCreateWithoutUserInput, ExamAttemptUncheckedCreateWithoutUserInput>
  }

  export type ExamAttemptUpdateWithWhereUniqueWithoutUserInput = {
    where: ExamAttemptWhereUniqueInput
    data: XOR<ExamAttemptUpdateWithoutUserInput, ExamAttemptUncheckedUpdateWithoutUserInput>
  }

  export type ExamAttemptUpdateManyWithWhereWithoutUserInput = {
    where: ExamAttemptScalarWhereInput
    data: XOR<ExamAttemptUpdateManyMutationInput, ExamAttemptUncheckedUpdateManyWithoutUserInput>
  }

  export type ExamAttemptScalarWhereInput = {
    AND?: ExamAttemptScalarWhereInput | ExamAttemptScalarWhereInput[]
    OR?: ExamAttemptScalarWhereInput[]
    NOT?: ExamAttemptScalarWhereInput | ExamAttemptScalarWhereInput[]
    id?: StringFilter<"ExamAttempt"> | string
    userId?: StringFilter<"ExamAttempt"> | string
    examId?: StringFilter<"ExamAttempt"> | string
    bookingId?: StringNullableFilter<"ExamAttempt"> | string | null
    startedAt?: DateTimeFilter<"ExamAttempt"> | Date | string
    completedAt?: DateTimeNullableFilter<"ExamAttempt"> | Date | string | null
    status?: EnumAttemptStatusFilter<"ExamAttempt"> | $Enums.AttemptStatus
    totalMarks?: IntFilter<"ExamAttempt"> | number
    obtainedMarks?: IntFilter<"ExamAttempt"> | number
    percentage?: FloatFilter<"ExamAttempt"> | number
    isPassed?: BoolFilter<"ExamAttempt"> | boolean
    timeSpent?: IntNullableFilter<"ExamAttempt"> | number | null
    ipAddress?: StringNullableFilter<"ExamAttempt"> | string | null
    userAgent?: StringNullableFilter<"ExamAttempt"> | string | null
    isCheating?: BoolFilter<"ExamAttempt"> | boolean
    cheatingReason?: StringNullableFilter<"ExamAttempt"> | string | null
    createdAt?: DateTimeFilter<"ExamAttempt"> | Date | string
    updatedAt?: DateTimeFilter<"ExamAttempt"> | Date | string
  }

  export type QuestionResponseUpsertWithWhereUniqueWithoutUserInput = {
    where: QuestionResponseWhereUniqueInput
    update: XOR<QuestionResponseUpdateWithoutUserInput, QuestionResponseUncheckedUpdateWithoutUserInput>
    create: XOR<QuestionResponseCreateWithoutUserInput, QuestionResponseUncheckedCreateWithoutUserInput>
  }

  export type QuestionResponseUpdateWithWhereUniqueWithoutUserInput = {
    where: QuestionResponseWhereUniqueInput
    data: XOR<QuestionResponseUpdateWithoutUserInput, QuestionResponseUncheckedUpdateWithoutUserInput>
  }

  export type QuestionResponseUpdateManyWithWhereWithoutUserInput = {
    where: QuestionResponseScalarWhereInput
    data: XOR<QuestionResponseUpdateManyMutationInput, QuestionResponseUncheckedUpdateManyWithoutUserInput>
  }

  export type QuestionResponseScalarWhereInput = {
    AND?: QuestionResponseScalarWhereInput | QuestionResponseScalarWhereInput[]
    OR?: QuestionResponseScalarWhereInput[]
    NOT?: QuestionResponseScalarWhereInput | QuestionResponseScalarWhereInput[]
    id?: StringFilter<"QuestionResponse"> | string
    attemptId?: StringFilter<"QuestionResponse"> | string
    questionId?: StringFilter<"QuestionResponse"> | string
    userId?: StringFilter<"QuestionResponse"> | string
    selectedOptions?: StringNullableListFilter<"QuestionResponse">
    isCorrect?: BoolNullableFilter<"QuestionResponse"> | boolean | null
    marksObtained?: IntFilter<"QuestionResponse"> | number
    timeSpent?: IntNullableFilter<"QuestionResponse"> | number | null
    answeredAt?: DateTimeFilter<"QuestionResponse"> | Date | string
    submittedAt?: DateTimeFilter<"QuestionResponse"> | Date | string
    createdAt?: DateTimeFilter<"QuestionResponse"> | Date | string
    updatedAt?: DateTimeFilter<"QuestionResponse"> | Date | string
  }

  export type QuestionScoreUpsertWithWhereUniqueWithoutUserInput = {
    where: QuestionScoreWhereUniqueInput
    update: XOR<QuestionScoreUpdateWithoutUserInput, QuestionScoreUncheckedUpdateWithoutUserInput>
    create: XOR<QuestionScoreCreateWithoutUserInput, QuestionScoreUncheckedCreateWithoutUserInput>
  }

  export type QuestionScoreUpdateWithWhereUniqueWithoutUserInput = {
    where: QuestionScoreWhereUniqueInput
    data: XOR<QuestionScoreUpdateWithoutUserInput, QuestionScoreUncheckedUpdateWithoutUserInput>
  }

  export type QuestionScoreUpdateManyWithWhereWithoutUserInput = {
    where: QuestionScoreScalarWhereInput
    data: XOR<QuestionScoreUpdateManyMutationInput, QuestionScoreUncheckedUpdateManyWithoutUserInput>
  }

  export type QuestionScoreScalarWhereInput = {
    AND?: QuestionScoreScalarWhereInput | QuestionScoreScalarWhereInput[]
    OR?: QuestionScoreScalarWhereInput[]
    NOT?: QuestionScoreScalarWhereInput | QuestionScoreScalarWhereInput[]
    id?: StringFilter<"QuestionScore"> | string
    responseId?: StringFilter<"QuestionScore"> | string
    questionId?: StringFilter<"QuestionScore"> | string
    attemptId?: StringFilter<"QuestionScore"> | string
    userId?: StringFilter<"QuestionScore"> | string
    isCorrect?: BoolFilter<"QuestionScore"> | boolean
    marksObtained?: FloatFilter<"QuestionScore"> | number
    maxMarks?: FloatFilter<"QuestionScore"> | number
    accuracy?: FloatFilter<"QuestionScore"> | number
    timeEfficiency?: FloatFilter<"QuestionScore"> | number
    difficultyBonus?: FloatFilter<"QuestionScore"> | number
    penalty?: FloatFilter<"QuestionScore"> | number
    responseTime?: IntFilter<"QuestionScore"> | number
    attemptsCount?: IntFilter<"QuestionScore"> | number
    confidenceLevel?: FloatFilter<"QuestionScore"> | number
    questionDifficulty?: StringFilter<"QuestionScore"> | string
    scoredAt?: DateTimeFilter<"QuestionScore"> | Date | string
    createdAt?: DateTimeFilter<"QuestionScore"> | Date | string
    updatedAt?: DateTimeFilter<"QuestionScore"> | Date | string
  }

  export type ExamScoreUpsertWithWhereUniqueWithoutUserInput = {
    where: ExamScoreWhereUniqueInput
    update: XOR<ExamScoreUpdateWithoutUserInput, ExamScoreUncheckedUpdateWithoutUserInput>
    create: XOR<ExamScoreCreateWithoutUserInput, ExamScoreUncheckedCreateWithoutUserInput>
  }

  export type ExamScoreUpdateWithWhereUniqueWithoutUserInput = {
    where: ExamScoreWhereUniqueInput
    data: XOR<ExamScoreUpdateWithoutUserInput, ExamScoreUncheckedUpdateWithoutUserInput>
  }

  export type ExamScoreUpdateManyWithWhereWithoutUserInput = {
    where: ExamScoreScalarWhereInput
    data: XOR<ExamScoreUpdateManyMutationInput, ExamScoreUncheckedUpdateManyWithoutUserInput>
  }

  export type ExamScoreScalarWhereInput = {
    AND?: ExamScoreScalarWhereInput | ExamScoreScalarWhereInput[]
    OR?: ExamScoreScalarWhereInput[]
    NOT?: ExamScoreScalarWhereInput | ExamScoreScalarWhereInput[]
    id?: StringFilter<"ExamScore"> | string
    attemptId?: StringFilter<"ExamScore"> | string
    examId?: StringFilter<"ExamScore"> | string
    userId?: StringFilter<"ExamScore"> | string
    totalMarks?: FloatFilter<"ExamScore"> | number
    maxMarks?: FloatFilter<"ExamScore"> | number
    percentage?: FloatFilter<"ExamScore"> | number
    grade?: StringNullableFilter<"ExamScore"> | string | null
    correctAnswers?: IntFilter<"ExamScore"> | number
    wrongAnswers?: IntFilter<"ExamScore"> | number
    unanswered?: IntFilter<"ExamScore"> | number
    totalQuestions?: IntFilter<"ExamScore"> | number
    totalTimeSpent?: IntFilter<"ExamScore"> | number
    averageTimePerQuestion?: FloatFilter<"ExamScore"> | number
    timeEfficiency?: FloatFilter<"ExamScore"> | number
    easyCorrect?: IntFilter<"ExamScore"> | number
    easyTotal?: IntFilter<"ExamScore"> | number
    mediumCorrect?: IntFilter<"ExamScore"> | number
    mediumTotal?: IntFilter<"ExamScore"> | number
    hardCorrect?: IntFilter<"ExamScore"> | number
    hardTotal?: IntFilter<"ExamScore"> | number
    accuracy?: FloatFilter<"ExamScore"> | number
    speedScore?: FloatFilter<"ExamScore"> | number
    consistencyScore?: FloatFilter<"ExamScore"> | number
    difficultyScore?: FloatFilter<"ExamScore"> | number
    percentile?: FloatNullableFilter<"ExamScore"> | number | null
    rank?: IntNullableFilter<"ExamScore"> | number | null
    improvement?: FloatNullableFilter<"ExamScore"> | number | null
    calculatedAt?: DateTimeFilter<"ExamScore"> | Date | string
    createdAt?: DateTimeFilter<"ExamScore"> | Date | string
    updatedAt?: DateTimeFilter<"ExamScore"> | Date | string
  }

  export type UserPerformanceUpsertWithWhereUniqueWithoutUserInput = {
    where: UserPerformanceWhereUniqueInput
    update: XOR<UserPerformanceUpdateWithoutUserInput, UserPerformanceUncheckedUpdateWithoutUserInput>
    create: XOR<UserPerformanceCreateWithoutUserInput, UserPerformanceUncheckedCreateWithoutUserInput>
  }

  export type UserPerformanceUpdateWithWhereUniqueWithoutUserInput = {
    where: UserPerformanceWhereUniqueInput
    data: XOR<UserPerformanceUpdateWithoutUserInput, UserPerformanceUncheckedUpdateWithoutUserInput>
  }

  export type UserPerformanceUpdateManyWithWhereWithoutUserInput = {
    where: UserPerformanceScalarWhereInput
    data: XOR<UserPerformanceUpdateManyMutationInput, UserPerformanceUncheckedUpdateManyWithoutUserInput>
  }

  export type UserPerformanceScalarWhereInput = {
    AND?: UserPerformanceScalarWhereInput | UserPerformanceScalarWhereInput[]
    OR?: UserPerformanceScalarWhereInput[]
    NOT?: UserPerformanceScalarWhereInput | UserPerformanceScalarWhereInput[]
    id?: StringFilter<"UserPerformance"> | string
    userId?: StringFilter<"UserPerformance"> | string
    examCategoryId?: StringNullableFilter<"UserPerformance"> | string | null
    totalAttempts?: IntFilter<"UserPerformance"> | number
    totalPassed?: IntFilter<"UserPerformance"> | number
    totalFailed?: IntFilter<"UserPerformance"> | number
    passRate?: FloatFilter<"UserPerformance"> | number
    averageScore?: FloatFilter<"UserPerformance"> | number
    highestScore?: FloatFilter<"UserPerformance"> | number
    lowestScore?: FloatFilter<"UserPerformance"> | number
    totalMarks?: FloatFilter<"UserPerformance"> | number
    totalTimeSpent?: IntFilter<"UserPerformance"> | number
    averageTimePerExam?: FloatFilter<"UserPerformance"> | number
    easyAccuracy?: FloatFilter<"UserPerformance"> | number
    mediumAccuracy?: FloatFilter<"UserPerformance"> | number
    hardAccuracy?: FloatFilter<"UserPerformance"> | number
    improvementRate?: FloatFilter<"UserPerformance"> | number
    consistencyScore?: FloatFilter<"UserPerformance"> | number
    learningCurve?: FloatFilter<"UserPerformance"> | number
    lastAttemptAt?: DateTimeNullableFilter<"UserPerformance"> | Date | string | null
    createdAt?: DateTimeFilter<"UserPerformance"> | Date | string
    updatedAt?: DateTimeFilter<"UserPerformance"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    metadata?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type UserSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    update: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    data: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
  }

  export type UserSessionUpdateManyWithWhereWithoutUserInput = {
    where: UserSessionScalarWhereInput
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSessionScalarWhereInput = {
    AND?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    OR?: UserSessionScalarWhereInput[]
    NOT?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    id?: StringFilter<"UserSession"> | string
    userId?: StringFilter<"UserSession"> | string
    sessionToken?: StringFilter<"UserSession"> | string
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    ipAddress?: StringNullableFilter<"UserSession"> | string | null
    userAgent?: StringNullableFilter<"UserSession"> | string | null
    isActive?: BoolFilter<"UserSession"> | boolean
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
  }

  export type ExamCategoryUserUpsertWithWhereUniqueWithoutUserInput = {
    where: ExamCategoryUserWhereUniqueInput
    update: XOR<ExamCategoryUserUpdateWithoutUserInput, ExamCategoryUserUncheckedUpdateWithoutUserInput>
    create: XOR<ExamCategoryUserCreateWithoutUserInput, ExamCategoryUserUncheckedCreateWithoutUserInput>
  }

  export type ExamCategoryUserUpdateWithWhereUniqueWithoutUserInput = {
    where: ExamCategoryUserWhereUniqueInput
    data: XOR<ExamCategoryUserUpdateWithoutUserInput, ExamCategoryUserUncheckedUpdateWithoutUserInput>
  }

  export type ExamCategoryUserUpdateManyWithWhereWithoutUserInput = {
    where: ExamCategoryUserScalarWhereInput
    data: XOR<ExamCategoryUserUpdateManyMutationInput, ExamCategoryUserUncheckedUpdateManyWithoutUserInput>
  }

  export type ExamCategoryUserScalarWhereInput = {
    AND?: ExamCategoryUserScalarWhereInput | ExamCategoryUserScalarWhereInput[]
    OR?: ExamCategoryUserScalarWhereInput[]
    NOT?: ExamCategoryUserScalarWhereInput | ExamCategoryUserScalarWhereInput[]
    id?: StringFilter<"ExamCategoryUser"> | string
    examCategoryId?: StringFilter<"ExamCategoryUser"> | string
    userId?: StringFilter<"ExamCategoryUser"> | string
    accessLevel?: EnumAccessLevelFilter<"ExamCategoryUser"> | $Enums.AccessLevel
    grantedAt?: DateTimeFilter<"ExamCategoryUser"> | Date | string
    grantedBy?: StringFilter<"ExamCategoryUser"> | string
  }

  export type StudyGroupMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: StudyGroupMemberWhereUniqueInput
    update: XOR<StudyGroupMemberUpdateWithoutUserInput, StudyGroupMemberUncheckedUpdateWithoutUserInput>
    create: XOR<StudyGroupMemberCreateWithoutUserInput, StudyGroupMemberUncheckedCreateWithoutUserInput>
  }

  export type StudyGroupMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: StudyGroupMemberWhereUniqueInput
    data: XOR<StudyGroupMemberUpdateWithoutUserInput, StudyGroupMemberUncheckedUpdateWithoutUserInput>
  }

  export type StudyGroupMemberUpdateManyWithWhereWithoutUserInput = {
    where: StudyGroupMemberScalarWhereInput
    data: XOR<StudyGroupMemberUpdateManyMutationInput, StudyGroupMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type StudyGroupMemberScalarWhereInput = {
    AND?: StudyGroupMemberScalarWhereInput | StudyGroupMemberScalarWhereInput[]
    OR?: StudyGroupMemberScalarWhereInput[]
    NOT?: StudyGroupMemberScalarWhereInput | StudyGroupMemberScalarWhereInput[]
    id?: StringFilter<"StudyGroupMember"> | string
    groupId?: StringFilter<"StudyGroupMember"> | string
    userId?: StringFilter<"StudyGroupMember"> | string
    role?: EnumGroupRoleFilter<"StudyGroupMember"> | $Enums.GroupRole
    joinedAt?: DateTimeFilter<"StudyGroupMember"> | Date | string
    isActive?: BoolFilter<"StudyGroupMember"> | boolean
  }

  export type CertificateUpsertWithWhereUniqueWithoutUserInput = {
    where: CertificateWhereUniqueInput
    update: XOR<CertificateUpdateWithoutUserInput, CertificateUncheckedUpdateWithoutUserInput>
    create: XOR<CertificateCreateWithoutUserInput, CertificateUncheckedCreateWithoutUserInput>
  }

  export type CertificateUpdateWithWhereUniqueWithoutUserInput = {
    where: CertificateWhereUniqueInput
    data: XOR<CertificateUpdateWithoutUserInput, CertificateUncheckedUpdateWithoutUserInput>
  }

  export type CertificateUpdateManyWithWhereWithoutUserInput = {
    where: CertificateScalarWhereInput
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyWithoutUserInput>
  }

  export type CertificateScalarWhereInput = {
    AND?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
    OR?: CertificateScalarWhereInput[]
    NOT?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
    id?: StringFilter<"Certificate"> | string
    userId?: StringFilter<"Certificate"> | string
    examId?: StringFilter<"Certificate"> | string
    attemptId?: StringFilter<"Certificate"> | string
    certificateNumber?: StringFilter<"Certificate"> | string
    issuedAt?: DateTimeFilter<"Certificate"> | Date | string
    expiresAt?: DateTimeNullableFilter<"Certificate"> | Date | string | null
    isRevoked?: BoolFilter<"Certificate"> | boolean
    revokedAt?: DateTimeNullableFilter<"Certificate"> | Date | string | null
    revokedBy?: StringNullableFilter<"Certificate"> | string | null
    revokedReason?: StringNullableFilter<"Certificate"> | string | null
    pdfUrl?: StringNullableFilter<"Certificate"> | string | null
    createdAt?: DateTimeFilter<"Certificate"> | Date | string
    updatedAt?: DateTimeFilter<"Certificate"> | Date | string
  }

  export type ExamCategoryUserUpsertWithWhereUniqueWithoutGranterInput = {
    where: ExamCategoryUserWhereUniqueInput
    update: XOR<ExamCategoryUserUpdateWithoutGranterInput, ExamCategoryUserUncheckedUpdateWithoutGranterInput>
    create: XOR<ExamCategoryUserCreateWithoutGranterInput, ExamCategoryUserUncheckedCreateWithoutGranterInput>
  }

  export type ExamCategoryUserUpdateWithWhereUniqueWithoutGranterInput = {
    where: ExamCategoryUserWhereUniqueInput
    data: XOR<ExamCategoryUserUpdateWithoutGranterInput, ExamCategoryUserUncheckedUpdateWithoutGranterInput>
  }

  export type ExamCategoryUserUpdateManyWithWhereWithoutGranterInput = {
    where: ExamCategoryUserScalarWhereInput
    data: XOR<ExamCategoryUserUpdateManyMutationInput, ExamCategoryUserUncheckedUpdateManyWithoutGranterInput>
  }

  export type StudyGroupUpsertWithWhereUniqueWithoutCreatorInput = {
    where: StudyGroupWhereUniqueInput
    update: XOR<StudyGroupUpdateWithoutCreatorInput, StudyGroupUncheckedUpdateWithoutCreatorInput>
    create: XOR<StudyGroupCreateWithoutCreatorInput, StudyGroupUncheckedCreateWithoutCreatorInput>
  }

  export type StudyGroupUpdateWithWhereUniqueWithoutCreatorInput = {
    where: StudyGroupWhereUniqueInput
    data: XOR<StudyGroupUpdateWithoutCreatorInput, StudyGroupUncheckedUpdateWithoutCreatorInput>
  }

  export type StudyGroupUpdateManyWithWhereWithoutCreatorInput = {
    where: StudyGroupScalarWhereInput
    data: XOR<StudyGroupUpdateManyMutationInput, StudyGroupUncheckedUpdateManyWithoutCreatorInput>
  }

  export type StudyGroupScalarWhereInput = {
    AND?: StudyGroupScalarWhereInput | StudyGroupScalarWhereInput[]
    OR?: StudyGroupScalarWhereInput[]
    NOT?: StudyGroupScalarWhereInput | StudyGroupScalarWhereInput[]
    id?: StringFilter<"StudyGroup"> | string
    name?: StringFilter<"StudyGroup"> | string
    description?: StringNullableFilter<"StudyGroup"> | string | null
    isPrivate?: BoolFilter<"StudyGroup"> | boolean
    maxMembers?: IntFilter<"StudyGroup"> | number
    createdBy?: StringFilter<"StudyGroup"> | string
    isActive?: BoolFilter<"StudyGroup"> | boolean
    createdAt?: DateTimeFilter<"StudyGroup"> | Date | string
    updatedAt?: DateTimeFilter<"StudyGroup"> | Date | string
  }

  export type QuestionUpsertWithWhereUniqueWithoutCreatorInput = {
    where: QuestionWhereUniqueInput
    update: XOR<QuestionUpdateWithoutCreatorInput, QuestionUncheckedUpdateWithoutCreatorInput>
    create: XOR<QuestionCreateWithoutCreatorInput, QuestionUncheckedCreateWithoutCreatorInput>
  }

  export type QuestionUpdateWithWhereUniqueWithoutCreatorInput = {
    where: QuestionWhereUniqueInput
    data: XOR<QuestionUpdateWithoutCreatorInput, QuestionUncheckedUpdateWithoutCreatorInput>
  }

  export type QuestionUpdateManyWithWhereWithoutCreatorInput = {
    where: QuestionScalarWhereInput
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyWithoutCreatorInput>
  }

  export type QuestionScalarWhereInput = {
    AND?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
    OR?: QuestionScalarWhereInput[]
    NOT?: QuestionScalarWhereInput | QuestionScalarWhereInput[]
    id?: StringFilter<"Question"> | string
    text?: StringFilter<"Question"> | string
    type?: EnumQuestionTypeFilter<"Question"> | $Enums.QuestionType
    difficulty?: EnumQuestionDifficultyFilter<"Question"> | $Enums.QuestionDifficulty
    examCategoryId?: StringFilter<"Question"> | string
    marks?: IntFilter<"Question"> | number
    timeLimit?: IntNullableFilter<"Question"> | number | null
    isActive?: BoolFilter<"Question"> | boolean
    isPublic?: BoolFilter<"Question"> | boolean
    createdBy?: StringFilter<"Question"> | string
    approvedBy?: StringNullableFilter<"Question"> | string | null
    approvedAt?: DateTimeNullableFilter<"Question"> | Date | string | null
    usageCount?: IntFilter<"Question"> | number
    correctAnswerRate?: FloatNullableFilter<"Question"> | number | null
    averageTime?: IntNullableFilter<"Question"> | number | null
    createdAt?: DateTimeFilter<"Question"> | Date | string
    updatedAt?: DateTimeFilter<"Question"> | Date | string
  }

  export type QuestionUpsertWithWhereUniqueWithoutApproverInput = {
    where: QuestionWhereUniqueInput
    update: XOR<QuestionUpdateWithoutApproverInput, QuestionUncheckedUpdateWithoutApproverInput>
    create: XOR<QuestionCreateWithoutApproverInput, QuestionUncheckedCreateWithoutApproverInput>
  }

  export type QuestionUpdateWithWhereUniqueWithoutApproverInput = {
    where: QuestionWhereUniqueInput
    data: XOR<QuestionUpdateWithoutApproverInput, QuestionUncheckedUpdateWithoutApproverInput>
  }

  export type QuestionUpdateManyWithWhereWithoutApproverInput = {
    where: QuestionScalarWhereInput
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyWithoutApproverInput>
  }

  export type ExamUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ExamWhereUniqueInput
    update: XOR<ExamUpdateWithoutCreatorInput, ExamUncheckedUpdateWithoutCreatorInput>
    create: XOR<ExamCreateWithoutCreatorInput, ExamUncheckedCreateWithoutCreatorInput>
  }

  export type ExamUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ExamWhereUniqueInput
    data: XOR<ExamUpdateWithoutCreatorInput, ExamUncheckedUpdateWithoutCreatorInput>
  }

  export type ExamUpdateManyWithWhereWithoutCreatorInput = {
    where: ExamScalarWhereInput
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ExamScalarWhereInput = {
    AND?: ExamScalarWhereInput | ExamScalarWhereInput[]
    OR?: ExamScalarWhereInput[]
    NOT?: ExamScalarWhereInput | ExamScalarWhereInput[]
    id?: StringFilter<"Exam"> | string
    title?: StringFilter<"Exam"> | string
    description?: StringNullableFilter<"Exam"> | string | null
    examCategoryId?: StringFilter<"Exam"> | string
    duration?: IntFilter<"Exam"> | number
    totalMarks?: IntFilter<"Exam"> | number
    passingMarks?: IntFilter<"Exam"> | number
    price?: DecimalFilter<"Exam"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Exam"> | string
    isActive?: BoolFilter<"Exam"> | boolean
    isPublic?: BoolFilter<"Exam"> | boolean
    allowRetakes?: BoolFilter<"Exam"> | boolean
    maxRetakes?: IntFilter<"Exam"> | number
    showResults?: BoolFilter<"Exam"> | boolean
    showAnswers?: BoolFilter<"Exam"> | boolean
    randomizeQuestions?: BoolFilter<"Exam"> | boolean
    randomizeOptions?: BoolFilter<"Exam"> | boolean
    questionOverlapPercentage?: FloatFilter<"Exam"> | number
    createdBy?: StringFilter<"Exam"> | string
    approvedBy?: StringNullableFilter<"Exam"> | string | null
    approvedAt?: DateTimeNullableFilter<"Exam"> | Date | string | null
    scheduledStart?: DateTimeNullableFilter<"Exam"> | Date | string | null
    scheduledEnd?: DateTimeNullableFilter<"Exam"> | Date | string | null
    createdAt?: DateTimeFilter<"Exam"> | Date | string
    updatedAt?: DateTimeFilter<"Exam"> | Date | string
  }

  export type ExamUpsertWithWhereUniqueWithoutApproverInput = {
    where: ExamWhereUniqueInput
    update: XOR<ExamUpdateWithoutApproverInput, ExamUncheckedUpdateWithoutApproverInput>
    create: XOR<ExamCreateWithoutApproverInput, ExamUncheckedCreateWithoutApproverInput>
  }

  export type ExamUpdateWithWhereUniqueWithoutApproverInput = {
    where: ExamWhereUniqueInput
    data: XOR<ExamUpdateWithoutApproverInput, ExamUncheckedUpdateWithoutApproverInput>
  }

  export type ExamUpdateManyWithWhereWithoutApproverInput = {
    where: ExamScalarWhereInput
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyWithoutApproverInput>
  }

  export type CertificateUpsertWithWhereUniqueWithoutRevokerInput = {
    where: CertificateWhereUniqueInput
    update: XOR<CertificateUpdateWithoutRevokerInput, CertificateUncheckedUpdateWithoutRevokerInput>
    create: XOR<CertificateCreateWithoutRevokerInput, CertificateUncheckedCreateWithoutRevokerInput>
  }

  export type CertificateUpdateWithWhereUniqueWithoutRevokerInput = {
    where: CertificateWhereUniqueInput
    data: XOR<CertificateUpdateWithoutRevokerInput, CertificateUncheckedUpdateWithoutRevokerInput>
  }

  export type CertificateUpdateManyWithWhereWithoutRevokerInput = {
    where: CertificateScalarWhereInput
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyWithoutRevokerInput>
  }

  export type UserCreateWithoutUserSessionsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examBookings?: ExamBookingCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    examAttempts?: ExamAttemptCreateNestedManyWithoutUserInput
    questionResponses?: QuestionResponseCreateNestedManyWithoutUserInput
    questionScores?: QuestionScoreCreateNestedManyWithoutUserInput
    examScores?: ExamScoreCreateNestedManyWithoutUserInput
    userPerformances?: UserPerformanceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    examCategories?: ExamCategoryUserCreateNestedManyWithoutUserInput
    studyGroups?: StudyGroupMemberCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    grantedExamCategories?: ExamCategoryUserCreateNestedManyWithoutGranterInput
    createdStudyGroups?: StudyGroupCreateNestedManyWithoutCreatorInput
    createdQuestions?: QuestionCreateNestedManyWithoutCreatorInput
    approvedQuestions?: QuestionCreateNestedManyWithoutApproverInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    approvedExams?: ExamCreateNestedManyWithoutApproverInput
    revokedCertificates?: CertificateCreateNestedManyWithoutRevokerInput
  }

  export type UserUncheckedCreateWithoutUserSessionsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examBookings?: ExamBookingUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    examAttempts?: ExamAttemptUncheckedCreateNestedManyWithoutUserInput
    questionResponses?: QuestionResponseUncheckedCreateNestedManyWithoutUserInput
    questionScores?: QuestionScoreUncheckedCreateNestedManyWithoutUserInput
    examScores?: ExamScoreUncheckedCreateNestedManyWithoutUserInput
    userPerformances?: UserPerformanceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    examCategories?: ExamCategoryUserUncheckedCreateNestedManyWithoutUserInput
    studyGroups?: StudyGroupMemberUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    grantedExamCategories?: ExamCategoryUserUncheckedCreateNestedManyWithoutGranterInput
    createdStudyGroups?: StudyGroupUncheckedCreateNestedManyWithoutCreatorInput
    createdQuestions?: QuestionUncheckedCreateNestedManyWithoutCreatorInput
    approvedQuestions?: QuestionUncheckedCreateNestedManyWithoutApproverInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    approvedExams?: ExamUncheckedCreateNestedManyWithoutApproverInput
    revokedCertificates?: CertificateUncheckedCreateNestedManyWithoutRevokerInput
  }

  export type UserCreateOrConnectWithoutUserSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserSessionsInput, UserUncheckedCreateWithoutUserSessionsInput>
  }

  export type UserUpsertWithoutUserSessionsInput = {
    update: XOR<UserUpdateWithoutUserSessionsInput, UserUncheckedUpdateWithoutUserSessionsInput>
    create: XOR<UserCreateWithoutUserSessionsInput, UserUncheckedCreateWithoutUserSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserSessionsInput, UserUncheckedUpdateWithoutUserSessionsInput>
  }

  export type UserUpdateWithoutUserSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examBookings?: ExamBookingUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    examAttempts?: ExamAttemptUpdateManyWithoutUserNestedInput
    questionResponses?: QuestionResponseUpdateManyWithoutUserNestedInput
    questionScores?: QuestionScoreUpdateManyWithoutUserNestedInput
    examScores?: ExamScoreUpdateManyWithoutUserNestedInput
    userPerformances?: UserPerformanceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    examCategories?: ExamCategoryUserUpdateManyWithoutUserNestedInput
    studyGroups?: StudyGroupMemberUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    grantedExamCategories?: ExamCategoryUserUpdateManyWithoutGranterNestedInput
    createdStudyGroups?: StudyGroupUpdateManyWithoutCreatorNestedInput
    createdQuestions?: QuestionUpdateManyWithoutCreatorNestedInput
    approvedQuestions?: QuestionUpdateManyWithoutApproverNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    approvedExams?: ExamUpdateManyWithoutApproverNestedInput
    revokedCertificates?: CertificateUpdateManyWithoutRevokerNestedInput
  }

  export type UserUncheckedUpdateWithoutUserSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examBookings?: ExamBookingUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    examAttempts?: ExamAttemptUncheckedUpdateManyWithoutUserNestedInput
    questionResponses?: QuestionResponseUncheckedUpdateManyWithoutUserNestedInput
    questionScores?: QuestionScoreUncheckedUpdateManyWithoutUserNestedInput
    examScores?: ExamScoreUncheckedUpdateManyWithoutUserNestedInput
    userPerformances?: UserPerformanceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    examCategories?: ExamCategoryUserUncheckedUpdateManyWithoutUserNestedInput
    studyGroups?: StudyGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    grantedExamCategories?: ExamCategoryUserUncheckedUpdateManyWithoutGranterNestedInput
    createdStudyGroups?: StudyGroupUncheckedUpdateManyWithoutCreatorNestedInput
    createdQuestions?: QuestionUncheckedUpdateManyWithoutCreatorNestedInput
    approvedQuestions?: QuestionUncheckedUpdateManyWithoutApproverNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    approvedExams?: ExamUncheckedUpdateManyWithoutApproverNestedInput
    revokedCertificates?: CertificateUncheckedUpdateManyWithoutRevokerNestedInput
  }

  export type ExamCreateWithoutExamCategoryInput = {
    id?: string
    title: string
    description?: string | null
    duration: number
    totalMarks: number
    passingMarks: number
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    isActive?: boolean
    isPublic?: boolean
    allowRetakes?: boolean
    maxRetakes?: number
    showResults?: boolean
    showAnswers?: boolean
    randomizeQuestions?: boolean
    randomizeOptions?: boolean
    questionOverlapPercentage?: number
    approvedAt?: Date | string | null
    scheduledStart?: Date | string | null
    scheduledEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedExamsInput
    approver?: UserCreateNestedOneWithoutApprovedExamsInput
    questions?: ExamQuestionCreateNestedManyWithoutExamInput
    bookings?: ExamBookingCreateNestedManyWithoutExamInput
    attempts?: ExamAttemptCreateNestedManyWithoutExamInput
    examScores?: ExamScoreCreateNestedManyWithoutExamInput
    certificates?: CertificateCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutExamCategoryInput = {
    id?: string
    title: string
    description?: string | null
    duration: number
    totalMarks: number
    passingMarks: number
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    isActive?: boolean
    isPublic?: boolean
    allowRetakes?: boolean
    maxRetakes?: number
    showResults?: boolean
    showAnswers?: boolean
    randomizeQuestions?: boolean
    randomizeOptions?: boolean
    questionOverlapPercentage?: number
    createdBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    scheduledStart?: Date | string | null
    scheduledEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: ExamQuestionUncheckedCreateNestedManyWithoutExamInput
    bookings?: ExamBookingUncheckedCreateNestedManyWithoutExamInput
    attempts?: ExamAttemptUncheckedCreateNestedManyWithoutExamInput
    examScores?: ExamScoreUncheckedCreateNestedManyWithoutExamInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutExamCategoryInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutExamCategoryInput, ExamUncheckedCreateWithoutExamCategoryInput>
  }

  export type ExamCreateManyExamCategoryInputEnvelope = {
    data: ExamCreateManyExamCategoryInput | ExamCreateManyExamCategoryInput[]
    skipDuplicates?: boolean
  }

  export type QuestionCreateWithoutExamCategoryInput = {
    id?: string
    text: string
    type: $Enums.QuestionType
    difficulty: $Enums.QuestionDifficulty
    marks?: number
    timeLimit?: number | null
    isActive?: boolean
    isPublic?: boolean
    approvedAt?: Date | string | null
    usageCount?: number
    correctAnswerRate?: number | null
    averageTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedQuestionsInput
    approver?: UserCreateNestedOneWithoutApprovedQuestionsInput
    options?: QuestionOptionCreateNestedManyWithoutQuestionInput
    images?: QuestionImageCreateNestedManyWithoutQuestionInput
    tags?: QuestionTagCreateNestedManyWithoutQuestionInput
    examQuestions?: ExamQuestionCreateNestedManyWithoutQuestionInput
    responses?: QuestionResponseCreateNestedManyWithoutQuestionInput
    scores?: QuestionScoreCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateWithoutExamCategoryInput = {
    id?: string
    text: string
    type: $Enums.QuestionType
    difficulty: $Enums.QuestionDifficulty
    marks?: number
    timeLimit?: number | null
    isActive?: boolean
    isPublic?: boolean
    createdBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    usageCount?: number
    correctAnswerRate?: number | null
    averageTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: QuestionOptionUncheckedCreateNestedManyWithoutQuestionInput
    images?: QuestionImageUncheckedCreateNestedManyWithoutQuestionInput
    tags?: QuestionTagUncheckedCreateNestedManyWithoutQuestionInput
    examQuestions?: ExamQuestionUncheckedCreateNestedManyWithoutQuestionInput
    responses?: QuestionResponseUncheckedCreateNestedManyWithoutQuestionInput
    scores?: QuestionScoreUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionCreateOrConnectWithoutExamCategoryInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutExamCategoryInput, QuestionUncheckedCreateWithoutExamCategoryInput>
  }

  export type QuestionCreateManyExamCategoryInputEnvelope = {
    data: QuestionCreateManyExamCategoryInput | QuestionCreateManyExamCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ExamCategoryUserCreateWithoutExamCategoryInput = {
    id?: string
    accessLevel?: $Enums.AccessLevel
    grantedAt?: Date | string
    user: UserCreateNestedOneWithoutExamCategoriesInput
    granter: UserCreateNestedOneWithoutGrantedExamCategoriesInput
  }

  export type ExamCategoryUserUncheckedCreateWithoutExamCategoryInput = {
    id?: string
    userId: string
    accessLevel?: $Enums.AccessLevel
    grantedAt?: Date | string
    grantedBy: string
  }

  export type ExamCategoryUserCreateOrConnectWithoutExamCategoryInput = {
    where: ExamCategoryUserWhereUniqueInput
    create: XOR<ExamCategoryUserCreateWithoutExamCategoryInput, ExamCategoryUserUncheckedCreateWithoutExamCategoryInput>
  }

  export type ExamCategoryUserCreateManyExamCategoryInputEnvelope = {
    data: ExamCategoryUserCreateManyExamCategoryInput | ExamCategoryUserCreateManyExamCategoryInput[]
    skipDuplicates?: boolean
  }

  export type UserPerformanceCreateWithoutExamCategoryInput = {
    id?: string
    totalAttempts?: number
    totalPassed?: number
    totalFailed?: number
    passRate?: number
    averageScore?: number
    highestScore?: number
    lowestScore?: number
    totalMarks?: number
    totalTimeSpent?: number
    averageTimePerExam?: number
    easyAccuracy?: number
    mediumAccuracy?: number
    hardAccuracy?: number
    improvementRate?: number
    consistencyScore?: number
    learningCurve?: number
    lastAttemptAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutUserPerformancesInput
  }

  export type UserPerformanceUncheckedCreateWithoutExamCategoryInput = {
    id?: string
    userId: string
    totalAttempts?: number
    totalPassed?: number
    totalFailed?: number
    passRate?: number
    averageScore?: number
    highestScore?: number
    lowestScore?: number
    totalMarks?: number
    totalTimeSpent?: number
    averageTimePerExam?: number
    easyAccuracy?: number
    mediumAccuracy?: number
    hardAccuracy?: number
    improvementRate?: number
    consistencyScore?: number
    learningCurve?: number
    lastAttemptAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPerformanceCreateOrConnectWithoutExamCategoryInput = {
    where: UserPerformanceWhereUniqueInput
    create: XOR<UserPerformanceCreateWithoutExamCategoryInput, UserPerformanceUncheckedCreateWithoutExamCategoryInput>
  }

  export type UserPerformanceCreateManyExamCategoryInputEnvelope = {
    data: UserPerformanceCreateManyExamCategoryInput | UserPerformanceCreateManyExamCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ExamUpsertWithWhereUniqueWithoutExamCategoryInput = {
    where: ExamWhereUniqueInput
    update: XOR<ExamUpdateWithoutExamCategoryInput, ExamUncheckedUpdateWithoutExamCategoryInput>
    create: XOR<ExamCreateWithoutExamCategoryInput, ExamUncheckedCreateWithoutExamCategoryInput>
  }

  export type ExamUpdateWithWhereUniqueWithoutExamCategoryInput = {
    where: ExamWhereUniqueInput
    data: XOR<ExamUpdateWithoutExamCategoryInput, ExamUncheckedUpdateWithoutExamCategoryInput>
  }

  export type ExamUpdateManyWithWhereWithoutExamCategoryInput = {
    where: ExamScalarWhereInput
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyWithoutExamCategoryInput>
  }

  export type QuestionUpsertWithWhereUniqueWithoutExamCategoryInput = {
    where: QuestionWhereUniqueInput
    update: XOR<QuestionUpdateWithoutExamCategoryInput, QuestionUncheckedUpdateWithoutExamCategoryInput>
    create: XOR<QuestionCreateWithoutExamCategoryInput, QuestionUncheckedCreateWithoutExamCategoryInput>
  }

  export type QuestionUpdateWithWhereUniqueWithoutExamCategoryInput = {
    where: QuestionWhereUniqueInput
    data: XOR<QuestionUpdateWithoutExamCategoryInput, QuestionUncheckedUpdateWithoutExamCategoryInput>
  }

  export type QuestionUpdateManyWithWhereWithoutExamCategoryInput = {
    where: QuestionScalarWhereInput
    data: XOR<QuestionUpdateManyMutationInput, QuestionUncheckedUpdateManyWithoutExamCategoryInput>
  }

  export type ExamCategoryUserUpsertWithWhereUniqueWithoutExamCategoryInput = {
    where: ExamCategoryUserWhereUniqueInput
    update: XOR<ExamCategoryUserUpdateWithoutExamCategoryInput, ExamCategoryUserUncheckedUpdateWithoutExamCategoryInput>
    create: XOR<ExamCategoryUserCreateWithoutExamCategoryInput, ExamCategoryUserUncheckedCreateWithoutExamCategoryInput>
  }

  export type ExamCategoryUserUpdateWithWhereUniqueWithoutExamCategoryInput = {
    where: ExamCategoryUserWhereUniqueInput
    data: XOR<ExamCategoryUserUpdateWithoutExamCategoryInput, ExamCategoryUserUncheckedUpdateWithoutExamCategoryInput>
  }

  export type ExamCategoryUserUpdateManyWithWhereWithoutExamCategoryInput = {
    where: ExamCategoryUserScalarWhereInput
    data: XOR<ExamCategoryUserUpdateManyMutationInput, ExamCategoryUserUncheckedUpdateManyWithoutExamCategoryInput>
  }

  export type UserPerformanceUpsertWithWhereUniqueWithoutExamCategoryInput = {
    where: UserPerformanceWhereUniqueInput
    update: XOR<UserPerformanceUpdateWithoutExamCategoryInput, UserPerformanceUncheckedUpdateWithoutExamCategoryInput>
    create: XOR<UserPerformanceCreateWithoutExamCategoryInput, UserPerformanceUncheckedCreateWithoutExamCategoryInput>
  }

  export type UserPerformanceUpdateWithWhereUniqueWithoutExamCategoryInput = {
    where: UserPerformanceWhereUniqueInput
    data: XOR<UserPerformanceUpdateWithoutExamCategoryInput, UserPerformanceUncheckedUpdateWithoutExamCategoryInput>
  }

  export type UserPerformanceUpdateManyWithWhereWithoutExamCategoryInput = {
    where: UserPerformanceScalarWhereInput
    data: XOR<UserPerformanceUpdateManyMutationInput, UserPerformanceUncheckedUpdateManyWithoutExamCategoryInput>
  }

  export type ExamCategoryCreateWithoutQuestionsInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    exams?: ExamCreateNestedManyWithoutExamCategoryInput
    users?: ExamCategoryUserCreateNestedManyWithoutExamCategoryInput
    userPerformances?: UserPerformanceCreateNestedManyWithoutExamCategoryInput
  }

  export type ExamCategoryUncheckedCreateWithoutQuestionsInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    exams?: ExamUncheckedCreateNestedManyWithoutExamCategoryInput
    users?: ExamCategoryUserUncheckedCreateNestedManyWithoutExamCategoryInput
    userPerformances?: UserPerformanceUncheckedCreateNestedManyWithoutExamCategoryInput
  }

  export type ExamCategoryCreateOrConnectWithoutQuestionsInput = {
    where: ExamCategoryWhereUniqueInput
    create: XOR<ExamCategoryCreateWithoutQuestionsInput, ExamCategoryUncheckedCreateWithoutQuestionsInput>
  }

  export type UserCreateWithoutCreatedQuestionsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examBookings?: ExamBookingCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    examAttempts?: ExamAttemptCreateNestedManyWithoutUserInput
    questionResponses?: QuestionResponseCreateNestedManyWithoutUserInput
    questionScores?: QuestionScoreCreateNestedManyWithoutUserInput
    examScores?: ExamScoreCreateNestedManyWithoutUserInput
    userPerformances?: UserPerformanceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    examCategories?: ExamCategoryUserCreateNestedManyWithoutUserInput
    studyGroups?: StudyGroupMemberCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    grantedExamCategories?: ExamCategoryUserCreateNestedManyWithoutGranterInput
    createdStudyGroups?: StudyGroupCreateNestedManyWithoutCreatorInput
    approvedQuestions?: QuestionCreateNestedManyWithoutApproverInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    approvedExams?: ExamCreateNestedManyWithoutApproverInput
    revokedCertificates?: CertificateCreateNestedManyWithoutRevokerInput
  }

  export type UserUncheckedCreateWithoutCreatedQuestionsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examBookings?: ExamBookingUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    examAttempts?: ExamAttemptUncheckedCreateNestedManyWithoutUserInput
    questionResponses?: QuestionResponseUncheckedCreateNestedManyWithoutUserInput
    questionScores?: QuestionScoreUncheckedCreateNestedManyWithoutUserInput
    examScores?: ExamScoreUncheckedCreateNestedManyWithoutUserInput
    userPerformances?: UserPerformanceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    examCategories?: ExamCategoryUserUncheckedCreateNestedManyWithoutUserInput
    studyGroups?: StudyGroupMemberUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    grantedExamCategories?: ExamCategoryUserUncheckedCreateNestedManyWithoutGranterInput
    createdStudyGroups?: StudyGroupUncheckedCreateNestedManyWithoutCreatorInput
    approvedQuestions?: QuestionUncheckedCreateNestedManyWithoutApproverInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    approvedExams?: ExamUncheckedCreateNestedManyWithoutApproverInput
    revokedCertificates?: CertificateUncheckedCreateNestedManyWithoutRevokerInput
  }

  export type UserCreateOrConnectWithoutCreatedQuestionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedQuestionsInput, UserUncheckedCreateWithoutCreatedQuestionsInput>
  }

  export type UserCreateWithoutApprovedQuestionsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examBookings?: ExamBookingCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    examAttempts?: ExamAttemptCreateNestedManyWithoutUserInput
    questionResponses?: QuestionResponseCreateNestedManyWithoutUserInput
    questionScores?: QuestionScoreCreateNestedManyWithoutUserInput
    examScores?: ExamScoreCreateNestedManyWithoutUserInput
    userPerformances?: UserPerformanceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    examCategories?: ExamCategoryUserCreateNestedManyWithoutUserInput
    studyGroups?: StudyGroupMemberCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    grantedExamCategories?: ExamCategoryUserCreateNestedManyWithoutGranterInput
    createdStudyGroups?: StudyGroupCreateNestedManyWithoutCreatorInput
    createdQuestions?: QuestionCreateNestedManyWithoutCreatorInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    approvedExams?: ExamCreateNestedManyWithoutApproverInput
    revokedCertificates?: CertificateCreateNestedManyWithoutRevokerInput
  }

  export type UserUncheckedCreateWithoutApprovedQuestionsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examBookings?: ExamBookingUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    examAttempts?: ExamAttemptUncheckedCreateNestedManyWithoutUserInput
    questionResponses?: QuestionResponseUncheckedCreateNestedManyWithoutUserInput
    questionScores?: QuestionScoreUncheckedCreateNestedManyWithoutUserInput
    examScores?: ExamScoreUncheckedCreateNestedManyWithoutUserInput
    userPerformances?: UserPerformanceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    examCategories?: ExamCategoryUserUncheckedCreateNestedManyWithoutUserInput
    studyGroups?: StudyGroupMemberUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    grantedExamCategories?: ExamCategoryUserUncheckedCreateNestedManyWithoutGranterInput
    createdStudyGroups?: StudyGroupUncheckedCreateNestedManyWithoutCreatorInput
    createdQuestions?: QuestionUncheckedCreateNestedManyWithoutCreatorInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    approvedExams?: ExamUncheckedCreateNestedManyWithoutApproverInput
    revokedCertificates?: CertificateUncheckedCreateNestedManyWithoutRevokerInput
  }

  export type UserCreateOrConnectWithoutApprovedQuestionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovedQuestionsInput, UserUncheckedCreateWithoutApprovedQuestionsInput>
  }

  export type QuestionOptionCreateWithoutQuestionInput = {
    id?: string
    text: string
    isCorrect?: boolean
    sortOrder?: number
    createdAt?: Date | string
  }

  export type QuestionOptionUncheckedCreateWithoutQuestionInput = {
    id?: string
    text: string
    isCorrect?: boolean
    sortOrder?: number
    createdAt?: Date | string
  }

  export type QuestionOptionCreateOrConnectWithoutQuestionInput = {
    where: QuestionOptionWhereUniqueInput
    create: XOR<QuestionOptionCreateWithoutQuestionInput, QuestionOptionUncheckedCreateWithoutQuestionInput>
  }

  export type QuestionOptionCreateManyQuestionInputEnvelope = {
    data: QuestionOptionCreateManyQuestionInput | QuestionOptionCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type QuestionImageCreateWithoutQuestionInput = {
    id?: string
    imageUrl: string
    altText?: string | null
    sortOrder?: number
    createdAt?: Date | string
  }

  export type QuestionImageUncheckedCreateWithoutQuestionInput = {
    id?: string
    imageUrl: string
    altText?: string | null
    sortOrder?: number
    createdAt?: Date | string
  }

  export type QuestionImageCreateOrConnectWithoutQuestionInput = {
    where: QuestionImageWhereUniqueInput
    create: XOR<QuestionImageCreateWithoutQuestionInput, QuestionImageUncheckedCreateWithoutQuestionInput>
  }

  export type QuestionImageCreateManyQuestionInputEnvelope = {
    data: QuestionImageCreateManyQuestionInput | QuestionImageCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type QuestionTagCreateWithoutQuestionInput = {
    id?: string
    tag: string
    createdAt?: Date | string
  }

  export type QuestionTagUncheckedCreateWithoutQuestionInput = {
    id?: string
    tag: string
    createdAt?: Date | string
  }

  export type QuestionTagCreateOrConnectWithoutQuestionInput = {
    where: QuestionTagWhereUniqueInput
    create: XOR<QuestionTagCreateWithoutQuestionInput, QuestionTagUncheckedCreateWithoutQuestionInput>
  }

  export type QuestionTagCreateManyQuestionInputEnvelope = {
    data: QuestionTagCreateManyQuestionInput | QuestionTagCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type ExamQuestionCreateWithoutQuestionInput = {
    id?: string
    order: number
    marks?: number
    createdAt?: Date | string
    exam: ExamCreateNestedOneWithoutQuestionsInput
  }

  export type ExamQuestionUncheckedCreateWithoutQuestionInput = {
    id?: string
    examId: string
    order: number
    marks?: number
    createdAt?: Date | string
  }

  export type ExamQuestionCreateOrConnectWithoutQuestionInput = {
    where: ExamQuestionWhereUniqueInput
    create: XOR<ExamQuestionCreateWithoutQuestionInput, ExamQuestionUncheckedCreateWithoutQuestionInput>
  }

  export type ExamQuestionCreateManyQuestionInputEnvelope = {
    data: ExamQuestionCreateManyQuestionInput | ExamQuestionCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type QuestionResponseCreateWithoutQuestionInput = {
    id?: string
    selectedOptions?: QuestionResponseCreateselectedOptionsInput | string[]
    isCorrect?: boolean | null
    marksObtained?: number
    timeSpent?: number | null
    answeredAt?: Date | string
    submittedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    attempt: ExamAttemptCreateNestedOneWithoutResponsesInput
    user: UserCreateNestedOneWithoutQuestionResponsesInput
    score?: QuestionScoreCreateNestedOneWithoutResponseInput
  }

  export type QuestionResponseUncheckedCreateWithoutQuestionInput = {
    id?: string
    attemptId: string
    userId: string
    selectedOptions?: QuestionResponseCreateselectedOptionsInput | string[]
    isCorrect?: boolean | null
    marksObtained?: number
    timeSpent?: number | null
    answeredAt?: Date | string
    submittedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    score?: QuestionScoreUncheckedCreateNestedOneWithoutResponseInput
  }

  export type QuestionResponseCreateOrConnectWithoutQuestionInput = {
    where: QuestionResponseWhereUniqueInput
    create: XOR<QuestionResponseCreateWithoutQuestionInput, QuestionResponseUncheckedCreateWithoutQuestionInput>
  }

  export type QuestionResponseCreateManyQuestionInputEnvelope = {
    data: QuestionResponseCreateManyQuestionInput | QuestionResponseCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type QuestionScoreCreateWithoutQuestionInput = {
    id?: string
    isCorrect?: boolean
    marksObtained?: number
    maxMarks?: number
    accuracy?: number
    timeEfficiency?: number
    difficultyBonus?: number
    penalty?: number
    responseTime?: number
    attemptsCount?: number
    confidenceLevel?: number
    questionDifficulty: string
    scoredAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    response: QuestionResponseCreateNestedOneWithoutScoreInput
    attempt: ExamAttemptCreateNestedOneWithoutQuestionScoresInput
    user: UserCreateNestedOneWithoutQuestionScoresInput
  }

  export type QuestionScoreUncheckedCreateWithoutQuestionInput = {
    id?: string
    responseId: string
    attemptId: string
    userId: string
    isCorrect?: boolean
    marksObtained?: number
    maxMarks?: number
    accuracy?: number
    timeEfficiency?: number
    difficultyBonus?: number
    penalty?: number
    responseTime?: number
    attemptsCount?: number
    confidenceLevel?: number
    questionDifficulty: string
    scoredAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionScoreCreateOrConnectWithoutQuestionInput = {
    where: QuestionScoreWhereUniqueInput
    create: XOR<QuestionScoreCreateWithoutQuestionInput, QuestionScoreUncheckedCreateWithoutQuestionInput>
  }

  export type QuestionScoreCreateManyQuestionInputEnvelope = {
    data: QuestionScoreCreateManyQuestionInput | QuestionScoreCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type ExamCategoryUpsertWithoutQuestionsInput = {
    update: XOR<ExamCategoryUpdateWithoutQuestionsInput, ExamCategoryUncheckedUpdateWithoutQuestionsInput>
    create: XOR<ExamCategoryCreateWithoutQuestionsInput, ExamCategoryUncheckedCreateWithoutQuestionsInput>
    where?: ExamCategoryWhereInput
  }

  export type ExamCategoryUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: ExamCategoryWhereInput
    data: XOR<ExamCategoryUpdateWithoutQuestionsInput, ExamCategoryUncheckedUpdateWithoutQuestionsInput>
  }

  export type ExamCategoryUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exams?: ExamUpdateManyWithoutExamCategoryNestedInput
    users?: ExamCategoryUserUpdateManyWithoutExamCategoryNestedInput
    userPerformances?: UserPerformanceUpdateManyWithoutExamCategoryNestedInput
  }

  export type ExamCategoryUncheckedUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exams?: ExamUncheckedUpdateManyWithoutExamCategoryNestedInput
    users?: ExamCategoryUserUncheckedUpdateManyWithoutExamCategoryNestedInput
    userPerformances?: UserPerformanceUncheckedUpdateManyWithoutExamCategoryNestedInput
  }

  export type UserUpsertWithoutCreatedQuestionsInput = {
    update: XOR<UserUpdateWithoutCreatedQuestionsInput, UserUncheckedUpdateWithoutCreatedQuestionsInput>
    create: XOR<UserCreateWithoutCreatedQuestionsInput, UserUncheckedCreateWithoutCreatedQuestionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedQuestionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedQuestionsInput, UserUncheckedUpdateWithoutCreatedQuestionsInput>
  }

  export type UserUpdateWithoutCreatedQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examBookings?: ExamBookingUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    examAttempts?: ExamAttemptUpdateManyWithoutUserNestedInput
    questionResponses?: QuestionResponseUpdateManyWithoutUserNestedInput
    questionScores?: QuestionScoreUpdateManyWithoutUserNestedInput
    examScores?: ExamScoreUpdateManyWithoutUserNestedInput
    userPerformances?: UserPerformanceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    examCategories?: ExamCategoryUserUpdateManyWithoutUserNestedInput
    studyGroups?: StudyGroupMemberUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    grantedExamCategories?: ExamCategoryUserUpdateManyWithoutGranterNestedInput
    createdStudyGroups?: StudyGroupUpdateManyWithoutCreatorNestedInput
    approvedQuestions?: QuestionUpdateManyWithoutApproverNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    approvedExams?: ExamUpdateManyWithoutApproverNestedInput
    revokedCertificates?: CertificateUpdateManyWithoutRevokerNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examBookings?: ExamBookingUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    examAttempts?: ExamAttemptUncheckedUpdateManyWithoutUserNestedInput
    questionResponses?: QuestionResponseUncheckedUpdateManyWithoutUserNestedInput
    questionScores?: QuestionScoreUncheckedUpdateManyWithoutUserNestedInput
    examScores?: ExamScoreUncheckedUpdateManyWithoutUserNestedInput
    userPerformances?: UserPerformanceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    examCategories?: ExamCategoryUserUncheckedUpdateManyWithoutUserNestedInput
    studyGroups?: StudyGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    grantedExamCategories?: ExamCategoryUserUncheckedUpdateManyWithoutGranterNestedInput
    createdStudyGroups?: StudyGroupUncheckedUpdateManyWithoutCreatorNestedInput
    approvedQuestions?: QuestionUncheckedUpdateManyWithoutApproverNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    approvedExams?: ExamUncheckedUpdateManyWithoutApproverNestedInput
    revokedCertificates?: CertificateUncheckedUpdateManyWithoutRevokerNestedInput
  }

  export type UserUpsertWithoutApprovedQuestionsInput = {
    update: XOR<UserUpdateWithoutApprovedQuestionsInput, UserUncheckedUpdateWithoutApprovedQuestionsInput>
    create: XOR<UserCreateWithoutApprovedQuestionsInput, UserUncheckedCreateWithoutApprovedQuestionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovedQuestionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovedQuestionsInput, UserUncheckedUpdateWithoutApprovedQuestionsInput>
  }

  export type UserUpdateWithoutApprovedQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examBookings?: ExamBookingUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    examAttempts?: ExamAttemptUpdateManyWithoutUserNestedInput
    questionResponses?: QuestionResponseUpdateManyWithoutUserNestedInput
    questionScores?: QuestionScoreUpdateManyWithoutUserNestedInput
    examScores?: ExamScoreUpdateManyWithoutUserNestedInput
    userPerformances?: UserPerformanceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    examCategories?: ExamCategoryUserUpdateManyWithoutUserNestedInput
    studyGroups?: StudyGroupMemberUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    grantedExamCategories?: ExamCategoryUserUpdateManyWithoutGranterNestedInput
    createdStudyGroups?: StudyGroupUpdateManyWithoutCreatorNestedInput
    createdQuestions?: QuestionUpdateManyWithoutCreatorNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    approvedExams?: ExamUpdateManyWithoutApproverNestedInput
    revokedCertificates?: CertificateUpdateManyWithoutRevokerNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovedQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examBookings?: ExamBookingUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    examAttempts?: ExamAttemptUncheckedUpdateManyWithoutUserNestedInput
    questionResponses?: QuestionResponseUncheckedUpdateManyWithoutUserNestedInput
    questionScores?: QuestionScoreUncheckedUpdateManyWithoutUserNestedInput
    examScores?: ExamScoreUncheckedUpdateManyWithoutUserNestedInput
    userPerformances?: UserPerformanceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    examCategories?: ExamCategoryUserUncheckedUpdateManyWithoutUserNestedInput
    studyGroups?: StudyGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    grantedExamCategories?: ExamCategoryUserUncheckedUpdateManyWithoutGranterNestedInput
    createdStudyGroups?: StudyGroupUncheckedUpdateManyWithoutCreatorNestedInput
    createdQuestions?: QuestionUncheckedUpdateManyWithoutCreatorNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    approvedExams?: ExamUncheckedUpdateManyWithoutApproverNestedInput
    revokedCertificates?: CertificateUncheckedUpdateManyWithoutRevokerNestedInput
  }

  export type QuestionOptionUpsertWithWhereUniqueWithoutQuestionInput = {
    where: QuestionOptionWhereUniqueInput
    update: XOR<QuestionOptionUpdateWithoutQuestionInput, QuestionOptionUncheckedUpdateWithoutQuestionInput>
    create: XOR<QuestionOptionCreateWithoutQuestionInput, QuestionOptionUncheckedCreateWithoutQuestionInput>
  }

  export type QuestionOptionUpdateWithWhereUniqueWithoutQuestionInput = {
    where: QuestionOptionWhereUniqueInput
    data: XOR<QuestionOptionUpdateWithoutQuestionInput, QuestionOptionUncheckedUpdateWithoutQuestionInput>
  }

  export type QuestionOptionUpdateManyWithWhereWithoutQuestionInput = {
    where: QuestionOptionScalarWhereInput
    data: XOR<QuestionOptionUpdateManyMutationInput, QuestionOptionUncheckedUpdateManyWithoutQuestionInput>
  }

  export type QuestionOptionScalarWhereInput = {
    AND?: QuestionOptionScalarWhereInput | QuestionOptionScalarWhereInput[]
    OR?: QuestionOptionScalarWhereInput[]
    NOT?: QuestionOptionScalarWhereInput | QuestionOptionScalarWhereInput[]
    id?: StringFilter<"QuestionOption"> | string
    questionId?: StringFilter<"QuestionOption"> | string
    text?: StringFilter<"QuestionOption"> | string
    isCorrect?: BoolFilter<"QuestionOption"> | boolean
    sortOrder?: IntFilter<"QuestionOption"> | number
    createdAt?: DateTimeFilter<"QuestionOption"> | Date | string
  }

  export type QuestionImageUpsertWithWhereUniqueWithoutQuestionInput = {
    where: QuestionImageWhereUniqueInput
    update: XOR<QuestionImageUpdateWithoutQuestionInput, QuestionImageUncheckedUpdateWithoutQuestionInput>
    create: XOR<QuestionImageCreateWithoutQuestionInput, QuestionImageUncheckedCreateWithoutQuestionInput>
  }

  export type QuestionImageUpdateWithWhereUniqueWithoutQuestionInput = {
    where: QuestionImageWhereUniqueInput
    data: XOR<QuestionImageUpdateWithoutQuestionInput, QuestionImageUncheckedUpdateWithoutQuestionInput>
  }

  export type QuestionImageUpdateManyWithWhereWithoutQuestionInput = {
    where: QuestionImageScalarWhereInput
    data: XOR<QuestionImageUpdateManyMutationInput, QuestionImageUncheckedUpdateManyWithoutQuestionInput>
  }

  export type QuestionImageScalarWhereInput = {
    AND?: QuestionImageScalarWhereInput | QuestionImageScalarWhereInput[]
    OR?: QuestionImageScalarWhereInput[]
    NOT?: QuestionImageScalarWhereInput | QuestionImageScalarWhereInput[]
    id?: StringFilter<"QuestionImage"> | string
    questionId?: StringFilter<"QuestionImage"> | string
    imageUrl?: StringFilter<"QuestionImage"> | string
    altText?: StringNullableFilter<"QuestionImage"> | string | null
    sortOrder?: IntFilter<"QuestionImage"> | number
    createdAt?: DateTimeFilter<"QuestionImage"> | Date | string
  }

  export type QuestionTagUpsertWithWhereUniqueWithoutQuestionInput = {
    where: QuestionTagWhereUniqueInput
    update: XOR<QuestionTagUpdateWithoutQuestionInput, QuestionTagUncheckedUpdateWithoutQuestionInput>
    create: XOR<QuestionTagCreateWithoutQuestionInput, QuestionTagUncheckedCreateWithoutQuestionInput>
  }

  export type QuestionTagUpdateWithWhereUniqueWithoutQuestionInput = {
    where: QuestionTagWhereUniqueInput
    data: XOR<QuestionTagUpdateWithoutQuestionInput, QuestionTagUncheckedUpdateWithoutQuestionInput>
  }

  export type QuestionTagUpdateManyWithWhereWithoutQuestionInput = {
    where: QuestionTagScalarWhereInput
    data: XOR<QuestionTagUpdateManyMutationInput, QuestionTagUncheckedUpdateManyWithoutQuestionInput>
  }

  export type QuestionTagScalarWhereInput = {
    AND?: QuestionTagScalarWhereInput | QuestionTagScalarWhereInput[]
    OR?: QuestionTagScalarWhereInput[]
    NOT?: QuestionTagScalarWhereInput | QuestionTagScalarWhereInput[]
    id?: StringFilter<"QuestionTag"> | string
    questionId?: StringFilter<"QuestionTag"> | string
    tag?: StringFilter<"QuestionTag"> | string
    createdAt?: DateTimeFilter<"QuestionTag"> | Date | string
  }

  export type ExamQuestionUpsertWithWhereUniqueWithoutQuestionInput = {
    where: ExamQuestionWhereUniqueInput
    update: XOR<ExamQuestionUpdateWithoutQuestionInput, ExamQuestionUncheckedUpdateWithoutQuestionInput>
    create: XOR<ExamQuestionCreateWithoutQuestionInput, ExamQuestionUncheckedCreateWithoutQuestionInput>
  }

  export type ExamQuestionUpdateWithWhereUniqueWithoutQuestionInput = {
    where: ExamQuestionWhereUniqueInput
    data: XOR<ExamQuestionUpdateWithoutQuestionInput, ExamQuestionUncheckedUpdateWithoutQuestionInput>
  }

  export type ExamQuestionUpdateManyWithWhereWithoutQuestionInput = {
    where: ExamQuestionScalarWhereInput
    data: XOR<ExamQuestionUpdateManyMutationInput, ExamQuestionUncheckedUpdateManyWithoutQuestionInput>
  }

  export type ExamQuestionScalarWhereInput = {
    AND?: ExamQuestionScalarWhereInput | ExamQuestionScalarWhereInput[]
    OR?: ExamQuestionScalarWhereInput[]
    NOT?: ExamQuestionScalarWhereInput | ExamQuestionScalarWhereInput[]
    id?: StringFilter<"ExamQuestion"> | string
    examId?: StringFilter<"ExamQuestion"> | string
    questionId?: StringFilter<"ExamQuestion"> | string
    order?: IntFilter<"ExamQuestion"> | number
    marks?: IntFilter<"ExamQuestion"> | number
    createdAt?: DateTimeFilter<"ExamQuestion"> | Date | string
  }

  export type QuestionResponseUpsertWithWhereUniqueWithoutQuestionInput = {
    where: QuestionResponseWhereUniqueInput
    update: XOR<QuestionResponseUpdateWithoutQuestionInput, QuestionResponseUncheckedUpdateWithoutQuestionInput>
    create: XOR<QuestionResponseCreateWithoutQuestionInput, QuestionResponseUncheckedCreateWithoutQuestionInput>
  }

  export type QuestionResponseUpdateWithWhereUniqueWithoutQuestionInput = {
    where: QuestionResponseWhereUniqueInput
    data: XOR<QuestionResponseUpdateWithoutQuestionInput, QuestionResponseUncheckedUpdateWithoutQuestionInput>
  }

  export type QuestionResponseUpdateManyWithWhereWithoutQuestionInput = {
    where: QuestionResponseScalarWhereInput
    data: XOR<QuestionResponseUpdateManyMutationInput, QuestionResponseUncheckedUpdateManyWithoutQuestionInput>
  }

  export type QuestionScoreUpsertWithWhereUniqueWithoutQuestionInput = {
    where: QuestionScoreWhereUniqueInput
    update: XOR<QuestionScoreUpdateWithoutQuestionInput, QuestionScoreUncheckedUpdateWithoutQuestionInput>
    create: XOR<QuestionScoreCreateWithoutQuestionInput, QuestionScoreUncheckedCreateWithoutQuestionInput>
  }

  export type QuestionScoreUpdateWithWhereUniqueWithoutQuestionInput = {
    where: QuestionScoreWhereUniqueInput
    data: XOR<QuestionScoreUpdateWithoutQuestionInput, QuestionScoreUncheckedUpdateWithoutQuestionInput>
  }

  export type QuestionScoreUpdateManyWithWhereWithoutQuestionInput = {
    where: QuestionScoreScalarWhereInput
    data: XOR<QuestionScoreUpdateManyMutationInput, QuestionScoreUncheckedUpdateManyWithoutQuestionInput>
  }

  export type QuestionCreateWithoutOptionsInput = {
    id?: string
    text: string
    type: $Enums.QuestionType
    difficulty: $Enums.QuestionDifficulty
    marks?: number
    timeLimit?: number | null
    isActive?: boolean
    isPublic?: boolean
    approvedAt?: Date | string | null
    usageCount?: number
    correctAnswerRate?: number | null
    averageTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examCategory: ExamCategoryCreateNestedOneWithoutQuestionsInput
    creator: UserCreateNestedOneWithoutCreatedQuestionsInput
    approver?: UserCreateNestedOneWithoutApprovedQuestionsInput
    images?: QuestionImageCreateNestedManyWithoutQuestionInput
    tags?: QuestionTagCreateNestedManyWithoutQuestionInput
    examQuestions?: ExamQuestionCreateNestedManyWithoutQuestionInput
    responses?: QuestionResponseCreateNestedManyWithoutQuestionInput
    scores?: QuestionScoreCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateWithoutOptionsInput = {
    id?: string
    text: string
    type: $Enums.QuestionType
    difficulty: $Enums.QuestionDifficulty
    examCategoryId: string
    marks?: number
    timeLimit?: number | null
    isActive?: boolean
    isPublic?: boolean
    createdBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    usageCount?: number
    correctAnswerRate?: number | null
    averageTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: QuestionImageUncheckedCreateNestedManyWithoutQuestionInput
    tags?: QuestionTagUncheckedCreateNestedManyWithoutQuestionInput
    examQuestions?: ExamQuestionUncheckedCreateNestedManyWithoutQuestionInput
    responses?: QuestionResponseUncheckedCreateNestedManyWithoutQuestionInput
    scores?: QuestionScoreUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionCreateOrConnectWithoutOptionsInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutOptionsInput, QuestionUncheckedCreateWithoutOptionsInput>
  }

  export type QuestionUpsertWithoutOptionsInput = {
    update: XOR<QuestionUpdateWithoutOptionsInput, QuestionUncheckedUpdateWithoutOptionsInput>
    create: XOR<QuestionCreateWithoutOptionsInput, QuestionUncheckedCreateWithoutOptionsInput>
    where?: QuestionWhereInput
  }

  export type QuestionUpdateToOneWithWhereWithoutOptionsInput = {
    where?: QuestionWhereInput
    data: XOR<QuestionUpdateWithoutOptionsInput, QuestionUncheckedUpdateWithoutOptionsInput>
  }

  export type QuestionUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    difficulty?: EnumQuestionDifficultyFieldUpdateOperationsInput | $Enums.QuestionDifficulty
    marks?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    correctAnswerRate?: NullableFloatFieldUpdateOperationsInput | number | null
    averageTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examCategory?: ExamCategoryUpdateOneRequiredWithoutQuestionsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedQuestionsNestedInput
    approver?: UserUpdateOneWithoutApprovedQuestionsNestedInput
    images?: QuestionImageUpdateManyWithoutQuestionNestedInput
    tags?: QuestionTagUpdateManyWithoutQuestionNestedInput
    examQuestions?: ExamQuestionUpdateManyWithoutQuestionNestedInput
    responses?: QuestionResponseUpdateManyWithoutQuestionNestedInput
    scores?: QuestionScoreUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    difficulty?: EnumQuestionDifficultyFieldUpdateOperationsInput | $Enums.QuestionDifficulty
    examCategoryId?: StringFieldUpdateOperationsInput | string
    marks?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    correctAnswerRate?: NullableFloatFieldUpdateOperationsInput | number | null
    averageTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: QuestionImageUncheckedUpdateManyWithoutQuestionNestedInput
    tags?: QuestionTagUncheckedUpdateManyWithoutQuestionNestedInput
    examQuestions?: ExamQuestionUncheckedUpdateManyWithoutQuestionNestedInput
    responses?: QuestionResponseUncheckedUpdateManyWithoutQuestionNestedInput
    scores?: QuestionScoreUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionCreateWithoutImagesInput = {
    id?: string
    text: string
    type: $Enums.QuestionType
    difficulty: $Enums.QuestionDifficulty
    marks?: number
    timeLimit?: number | null
    isActive?: boolean
    isPublic?: boolean
    approvedAt?: Date | string | null
    usageCount?: number
    correctAnswerRate?: number | null
    averageTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examCategory: ExamCategoryCreateNestedOneWithoutQuestionsInput
    creator: UserCreateNestedOneWithoutCreatedQuestionsInput
    approver?: UserCreateNestedOneWithoutApprovedQuestionsInput
    options?: QuestionOptionCreateNestedManyWithoutQuestionInput
    tags?: QuestionTagCreateNestedManyWithoutQuestionInput
    examQuestions?: ExamQuestionCreateNestedManyWithoutQuestionInput
    responses?: QuestionResponseCreateNestedManyWithoutQuestionInput
    scores?: QuestionScoreCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateWithoutImagesInput = {
    id?: string
    text: string
    type: $Enums.QuestionType
    difficulty: $Enums.QuestionDifficulty
    examCategoryId: string
    marks?: number
    timeLimit?: number | null
    isActive?: boolean
    isPublic?: boolean
    createdBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    usageCount?: number
    correctAnswerRate?: number | null
    averageTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: QuestionOptionUncheckedCreateNestedManyWithoutQuestionInput
    tags?: QuestionTagUncheckedCreateNestedManyWithoutQuestionInput
    examQuestions?: ExamQuestionUncheckedCreateNestedManyWithoutQuestionInput
    responses?: QuestionResponseUncheckedCreateNestedManyWithoutQuestionInput
    scores?: QuestionScoreUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionCreateOrConnectWithoutImagesInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutImagesInput, QuestionUncheckedCreateWithoutImagesInput>
  }

  export type QuestionUpsertWithoutImagesInput = {
    update: XOR<QuestionUpdateWithoutImagesInput, QuestionUncheckedUpdateWithoutImagesInput>
    create: XOR<QuestionCreateWithoutImagesInput, QuestionUncheckedCreateWithoutImagesInput>
    where?: QuestionWhereInput
  }

  export type QuestionUpdateToOneWithWhereWithoutImagesInput = {
    where?: QuestionWhereInput
    data: XOR<QuestionUpdateWithoutImagesInput, QuestionUncheckedUpdateWithoutImagesInput>
  }

  export type QuestionUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    difficulty?: EnumQuestionDifficultyFieldUpdateOperationsInput | $Enums.QuestionDifficulty
    marks?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    correctAnswerRate?: NullableFloatFieldUpdateOperationsInput | number | null
    averageTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examCategory?: ExamCategoryUpdateOneRequiredWithoutQuestionsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedQuestionsNestedInput
    approver?: UserUpdateOneWithoutApprovedQuestionsNestedInput
    options?: QuestionOptionUpdateManyWithoutQuestionNestedInput
    tags?: QuestionTagUpdateManyWithoutQuestionNestedInput
    examQuestions?: ExamQuestionUpdateManyWithoutQuestionNestedInput
    responses?: QuestionResponseUpdateManyWithoutQuestionNestedInput
    scores?: QuestionScoreUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    difficulty?: EnumQuestionDifficultyFieldUpdateOperationsInput | $Enums.QuestionDifficulty
    examCategoryId?: StringFieldUpdateOperationsInput | string
    marks?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    correctAnswerRate?: NullableFloatFieldUpdateOperationsInput | number | null
    averageTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: QuestionOptionUncheckedUpdateManyWithoutQuestionNestedInput
    tags?: QuestionTagUncheckedUpdateManyWithoutQuestionNestedInput
    examQuestions?: ExamQuestionUncheckedUpdateManyWithoutQuestionNestedInput
    responses?: QuestionResponseUncheckedUpdateManyWithoutQuestionNestedInput
    scores?: QuestionScoreUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionCreateWithoutTagsInput = {
    id?: string
    text: string
    type: $Enums.QuestionType
    difficulty: $Enums.QuestionDifficulty
    marks?: number
    timeLimit?: number | null
    isActive?: boolean
    isPublic?: boolean
    approvedAt?: Date | string | null
    usageCount?: number
    correctAnswerRate?: number | null
    averageTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examCategory: ExamCategoryCreateNestedOneWithoutQuestionsInput
    creator: UserCreateNestedOneWithoutCreatedQuestionsInput
    approver?: UserCreateNestedOneWithoutApprovedQuestionsInput
    options?: QuestionOptionCreateNestedManyWithoutQuestionInput
    images?: QuestionImageCreateNestedManyWithoutQuestionInput
    examQuestions?: ExamQuestionCreateNestedManyWithoutQuestionInput
    responses?: QuestionResponseCreateNestedManyWithoutQuestionInput
    scores?: QuestionScoreCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateWithoutTagsInput = {
    id?: string
    text: string
    type: $Enums.QuestionType
    difficulty: $Enums.QuestionDifficulty
    examCategoryId: string
    marks?: number
    timeLimit?: number | null
    isActive?: boolean
    isPublic?: boolean
    createdBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    usageCount?: number
    correctAnswerRate?: number | null
    averageTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: QuestionOptionUncheckedCreateNestedManyWithoutQuestionInput
    images?: QuestionImageUncheckedCreateNestedManyWithoutQuestionInput
    examQuestions?: ExamQuestionUncheckedCreateNestedManyWithoutQuestionInput
    responses?: QuestionResponseUncheckedCreateNestedManyWithoutQuestionInput
    scores?: QuestionScoreUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionCreateOrConnectWithoutTagsInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutTagsInput, QuestionUncheckedCreateWithoutTagsInput>
  }

  export type QuestionUpsertWithoutTagsInput = {
    update: XOR<QuestionUpdateWithoutTagsInput, QuestionUncheckedUpdateWithoutTagsInput>
    create: XOR<QuestionCreateWithoutTagsInput, QuestionUncheckedCreateWithoutTagsInput>
    where?: QuestionWhereInput
  }

  export type QuestionUpdateToOneWithWhereWithoutTagsInput = {
    where?: QuestionWhereInput
    data: XOR<QuestionUpdateWithoutTagsInput, QuestionUncheckedUpdateWithoutTagsInput>
  }

  export type QuestionUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    difficulty?: EnumQuestionDifficultyFieldUpdateOperationsInput | $Enums.QuestionDifficulty
    marks?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    correctAnswerRate?: NullableFloatFieldUpdateOperationsInput | number | null
    averageTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examCategory?: ExamCategoryUpdateOneRequiredWithoutQuestionsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedQuestionsNestedInput
    approver?: UserUpdateOneWithoutApprovedQuestionsNestedInput
    options?: QuestionOptionUpdateManyWithoutQuestionNestedInput
    images?: QuestionImageUpdateManyWithoutQuestionNestedInput
    examQuestions?: ExamQuestionUpdateManyWithoutQuestionNestedInput
    responses?: QuestionResponseUpdateManyWithoutQuestionNestedInput
    scores?: QuestionScoreUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    difficulty?: EnumQuestionDifficultyFieldUpdateOperationsInput | $Enums.QuestionDifficulty
    examCategoryId?: StringFieldUpdateOperationsInput | string
    marks?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    correctAnswerRate?: NullableFloatFieldUpdateOperationsInput | number | null
    averageTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: QuestionOptionUncheckedUpdateManyWithoutQuestionNestedInput
    images?: QuestionImageUncheckedUpdateManyWithoutQuestionNestedInput
    examQuestions?: ExamQuestionUncheckedUpdateManyWithoutQuestionNestedInput
    responses?: QuestionResponseUncheckedUpdateManyWithoutQuestionNestedInput
    scores?: QuestionScoreUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type ExamCategoryCreateWithoutExamsInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: QuestionCreateNestedManyWithoutExamCategoryInput
    users?: ExamCategoryUserCreateNestedManyWithoutExamCategoryInput
    userPerformances?: UserPerformanceCreateNestedManyWithoutExamCategoryInput
  }

  export type ExamCategoryUncheckedCreateWithoutExamsInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: QuestionUncheckedCreateNestedManyWithoutExamCategoryInput
    users?: ExamCategoryUserUncheckedCreateNestedManyWithoutExamCategoryInput
    userPerformances?: UserPerformanceUncheckedCreateNestedManyWithoutExamCategoryInput
  }

  export type ExamCategoryCreateOrConnectWithoutExamsInput = {
    where: ExamCategoryWhereUniqueInput
    create: XOR<ExamCategoryCreateWithoutExamsInput, ExamCategoryUncheckedCreateWithoutExamsInput>
  }

  export type UserCreateWithoutCreatedExamsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examBookings?: ExamBookingCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    examAttempts?: ExamAttemptCreateNestedManyWithoutUserInput
    questionResponses?: QuestionResponseCreateNestedManyWithoutUserInput
    questionScores?: QuestionScoreCreateNestedManyWithoutUserInput
    examScores?: ExamScoreCreateNestedManyWithoutUserInput
    userPerformances?: UserPerformanceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    examCategories?: ExamCategoryUserCreateNestedManyWithoutUserInput
    studyGroups?: StudyGroupMemberCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    grantedExamCategories?: ExamCategoryUserCreateNestedManyWithoutGranterInput
    createdStudyGroups?: StudyGroupCreateNestedManyWithoutCreatorInput
    createdQuestions?: QuestionCreateNestedManyWithoutCreatorInput
    approvedQuestions?: QuestionCreateNestedManyWithoutApproverInput
    approvedExams?: ExamCreateNestedManyWithoutApproverInput
    revokedCertificates?: CertificateCreateNestedManyWithoutRevokerInput
  }

  export type UserUncheckedCreateWithoutCreatedExamsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examBookings?: ExamBookingUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    examAttempts?: ExamAttemptUncheckedCreateNestedManyWithoutUserInput
    questionResponses?: QuestionResponseUncheckedCreateNestedManyWithoutUserInput
    questionScores?: QuestionScoreUncheckedCreateNestedManyWithoutUserInput
    examScores?: ExamScoreUncheckedCreateNestedManyWithoutUserInput
    userPerformances?: UserPerformanceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    examCategories?: ExamCategoryUserUncheckedCreateNestedManyWithoutUserInput
    studyGroups?: StudyGroupMemberUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    grantedExamCategories?: ExamCategoryUserUncheckedCreateNestedManyWithoutGranterInput
    createdStudyGroups?: StudyGroupUncheckedCreateNestedManyWithoutCreatorInput
    createdQuestions?: QuestionUncheckedCreateNestedManyWithoutCreatorInput
    approvedQuestions?: QuestionUncheckedCreateNestedManyWithoutApproverInput
    approvedExams?: ExamUncheckedCreateNestedManyWithoutApproverInput
    revokedCertificates?: CertificateUncheckedCreateNestedManyWithoutRevokerInput
  }

  export type UserCreateOrConnectWithoutCreatedExamsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedExamsInput, UserUncheckedCreateWithoutCreatedExamsInput>
  }

  export type UserCreateWithoutApprovedExamsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examBookings?: ExamBookingCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    examAttempts?: ExamAttemptCreateNestedManyWithoutUserInput
    questionResponses?: QuestionResponseCreateNestedManyWithoutUserInput
    questionScores?: QuestionScoreCreateNestedManyWithoutUserInput
    examScores?: ExamScoreCreateNestedManyWithoutUserInput
    userPerformances?: UserPerformanceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    examCategories?: ExamCategoryUserCreateNestedManyWithoutUserInput
    studyGroups?: StudyGroupMemberCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    grantedExamCategories?: ExamCategoryUserCreateNestedManyWithoutGranterInput
    createdStudyGroups?: StudyGroupCreateNestedManyWithoutCreatorInput
    createdQuestions?: QuestionCreateNestedManyWithoutCreatorInput
    approvedQuestions?: QuestionCreateNestedManyWithoutApproverInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    revokedCertificates?: CertificateCreateNestedManyWithoutRevokerInput
  }

  export type UserUncheckedCreateWithoutApprovedExamsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examBookings?: ExamBookingUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    examAttempts?: ExamAttemptUncheckedCreateNestedManyWithoutUserInput
    questionResponses?: QuestionResponseUncheckedCreateNestedManyWithoutUserInput
    questionScores?: QuestionScoreUncheckedCreateNestedManyWithoutUserInput
    examScores?: ExamScoreUncheckedCreateNestedManyWithoutUserInput
    userPerformances?: UserPerformanceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    examCategories?: ExamCategoryUserUncheckedCreateNestedManyWithoutUserInput
    studyGroups?: StudyGroupMemberUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    grantedExamCategories?: ExamCategoryUserUncheckedCreateNestedManyWithoutGranterInput
    createdStudyGroups?: StudyGroupUncheckedCreateNestedManyWithoutCreatorInput
    createdQuestions?: QuestionUncheckedCreateNestedManyWithoutCreatorInput
    approvedQuestions?: QuestionUncheckedCreateNestedManyWithoutApproverInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    revokedCertificates?: CertificateUncheckedCreateNestedManyWithoutRevokerInput
  }

  export type UserCreateOrConnectWithoutApprovedExamsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovedExamsInput, UserUncheckedCreateWithoutApprovedExamsInput>
  }

  export type ExamQuestionCreateWithoutExamInput = {
    id?: string
    order: number
    marks?: number
    createdAt?: Date | string
    question: QuestionCreateNestedOneWithoutExamQuestionsInput
  }

  export type ExamQuestionUncheckedCreateWithoutExamInput = {
    id?: string
    questionId: string
    order: number
    marks?: number
    createdAt?: Date | string
  }

  export type ExamQuestionCreateOrConnectWithoutExamInput = {
    where: ExamQuestionWhereUniqueInput
    create: XOR<ExamQuestionCreateWithoutExamInput, ExamQuestionUncheckedCreateWithoutExamInput>
  }

  export type ExamQuestionCreateManyExamInputEnvelope = {
    data: ExamQuestionCreateManyExamInput | ExamQuestionCreateManyExamInput[]
    skipDuplicates?: boolean
  }

  export type ExamBookingCreateWithoutExamInput = {
    id?: string
    bookingDate?: Date | string
    scheduledAt?: Date | string | null
    status?: $Enums.BookingStatus
    paymentId?: string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutExamBookingsInput
    payment?: PaymentCreateNestedOneWithoutBookingInput
    attempts?: ExamAttemptCreateNestedManyWithoutBookingInput
  }

  export type ExamBookingUncheckedCreateWithoutExamInput = {
    id?: string
    userId: string
    bookingDate?: Date | string
    scheduledAt?: Date | string | null
    status?: $Enums.BookingStatus
    paymentId?: string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payment?: PaymentUncheckedCreateNestedOneWithoutBookingInput
    attempts?: ExamAttemptUncheckedCreateNestedManyWithoutBookingInput
  }

  export type ExamBookingCreateOrConnectWithoutExamInput = {
    where: ExamBookingWhereUniqueInput
    create: XOR<ExamBookingCreateWithoutExamInput, ExamBookingUncheckedCreateWithoutExamInput>
  }

  export type ExamBookingCreateManyExamInputEnvelope = {
    data: ExamBookingCreateManyExamInput | ExamBookingCreateManyExamInput[]
    skipDuplicates?: boolean
  }

  export type ExamAttemptCreateWithoutExamInput = {
    id?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.AttemptStatus
    totalMarks?: number
    obtainedMarks?: number
    percentage?: number
    isPassed?: boolean
    timeSpent?: number | null
    ipAddress?: string | null
    userAgent?: string | null
    isCheating?: boolean
    cheatingReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutExamAttemptsInput
    booking?: ExamBookingCreateNestedOneWithoutAttemptsInput
    responses?: QuestionResponseCreateNestedManyWithoutAttemptInput
    questionScores?: QuestionScoreCreateNestedManyWithoutAttemptInput
    examScore?: ExamScoreCreateNestedOneWithoutAttemptInput
    certificate?: CertificateCreateNestedOneWithoutAttemptInput
  }

  export type ExamAttemptUncheckedCreateWithoutExamInput = {
    id?: string
    userId: string
    bookingId?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.AttemptStatus
    totalMarks?: number
    obtainedMarks?: number
    percentage?: number
    isPassed?: boolean
    timeSpent?: number | null
    ipAddress?: string | null
    userAgent?: string | null
    isCheating?: boolean
    cheatingReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: QuestionResponseUncheckedCreateNestedManyWithoutAttemptInput
    questionScores?: QuestionScoreUncheckedCreateNestedManyWithoutAttemptInput
    examScore?: ExamScoreUncheckedCreateNestedOneWithoutAttemptInput
    certificate?: CertificateUncheckedCreateNestedOneWithoutAttemptInput
  }

  export type ExamAttemptCreateOrConnectWithoutExamInput = {
    where: ExamAttemptWhereUniqueInput
    create: XOR<ExamAttemptCreateWithoutExamInput, ExamAttemptUncheckedCreateWithoutExamInput>
  }

  export type ExamAttemptCreateManyExamInputEnvelope = {
    data: ExamAttemptCreateManyExamInput | ExamAttemptCreateManyExamInput[]
    skipDuplicates?: boolean
  }

  export type ExamScoreCreateWithoutExamInput = {
    id?: string
    totalMarks?: number
    maxMarks?: number
    percentage?: number
    grade?: string | null
    correctAnswers?: number
    wrongAnswers?: number
    unanswered?: number
    totalQuestions?: number
    totalTimeSpent?: number
    averageTimePerQuestion?: number
    timeEfficiency?: number
    easyCorrect?: number
    easyTotal?: number
    mediumCorrect?: number
    mediumTotal?: number
    hardCorrect?: number
    hardTotal?: number
    accuracy?: number
    speedScore?: number
    consistencyScore?: number
    difficultyScore?: number
    percentile?: number | null
    rank?: number | null
    improvement?: number | null
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    attempt: ExamAttemptCreateNestedOneWithoutExamScoreInput
    user: UserCreateNestedOneWithoutExamScoresInput
  }

  export type ExamScoreUncheckedCreateWithoutExamInput = {
    id?: string
    attemptId: string
    userId: string
    totalMarks?: number
    maxMarks?: number
    percentage?: number
    grade?: string | null
    correctAnswers?: number
    wrongAnswers?: number
    unanswered?: number
    totalQuestions?: number
    totalTimeSpent?: number
    averageTimePerQuestion?: number
    timeEfficiency?: number
    easyCorrect?: number
    easyTotal?: number
    mediumCorrect?: number
    mediumTotal?: number
    hardCorrect?: number
    hardTotal?: number
    accuracy?: number
    speedScore?: number
    consistencyScore?: number
    difficultyScore?: number
    percentile?: number | null
    rank?: number | null
    improvement?: number | null
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamScoreCreateOrConnectWithoutExamInput = {
    where: ExamScoreWhereUniqueInput
    create: XOR<ExamScoreCreateWithoutExamInput, ExamScoreUncheckedCreateWithoutExamInput>
  }

  export type ExamScoreCreateManyExamInputEnvelope = {
    data: ExamScoreCreateManyExamInput | ExamScoreCreateManyExamInput[]
    skipDuplicates?: boolean
  }

  export type CertificateCreateWithoutExamInput = {
    id?: string
    certificateNumber: string
    issuedAt?: Date | string
    expiresAt?: Date | string | null
    isRevoked?: boolean
    revokedAt?: Date | string | null
    revokedReason?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCertificatesInput
    attempt: ExamAttemptCreateNestedOneWithoutCertificateInput
    revoker?: UserCreateNestedOneWithoutRevokedCertificatesInput
  }

  export type CertificateUncheckedCreateWithoutExamInput = {
    id?: string
    userId: string
    attemptId: string
    certificateNumber: string
    issuedAt?: Date | string
    expiresAt?: Date | string | null
    isRevoked?: boolean
    revokedAt?: Date | string | null
    revokedBy?: string | null
    revokedReason?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificateCreateOrConnectWithoutExamInput = {
    where: CertificateWhereUniqueInput
    create: XOR<CertificateCreateWithoutExamInput, CertificateUncheckedCreateWithoutExamInput>
  }

  export type CertificateCreateManyExamInputEnvelope = {
    data: CertificateCreateManyExamInput | CertificateCreateManyExamInput[]
    skipDuplicates?: boolean
  }

  export type ExamCategoryUpsertWithoutExamsInput = {
    update: XOR<ExamCategoryUpdateWithoutExamsInput, ExamCategoryUncheckedUpdateWithoutExamsInput>
    create: XOR<ExamCategoryCreateWithoutExamsInput, ExamCategoryUncheckedCreateWithoutExamsInput>
    where?: ExamCategoryWhereInput
  }

  export type ExamCategoryUpdateToOneWithWhereWithoutExamsInput = {
    where?: ExamCategoryWhereInput
    data: XOR<ExamCategoryUpdateWithoutExamsInput, ExamCategoryUncheckedUpdateWithoutExamsInput>
  }

  export type ExamCategoryUpdateWithoutExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionUpdateManyWithoutExamCategoryNestedInput
    users?: ExamCategoryUserUpdateManyWithoutExamCategoryNestedInput
    userPerformances?: UserPerformanceUpdateManyWithoutExamCategoryNestedInput
  }

  export type ExamCategoryUncheckedUpdateWithoutExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionUncheckedUpdateManyWithoutExamCategoryNestedInput
    users?: ExamCategoryUserUncheckedUpdateManyWithoutExamCategoryNestedInput
    userPerformances?: UserPerformanceUncheckedUpdateManyWithoutExamCategoryNestedInput
  }

  export type UserUpsertWithoutCreatedExamsInput = {
    update: XOR<UserUpdateWithoutCreatedExamsInput, UserUncheckedUpdateWithoutCreatedExamsInput>
    create: XOR<UserCreateWithoutCreatedExamsInput, UserUncheckedCreateWithoutCreatedExamsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedExamsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedExamsInput, UserUncheckedUpdateWithoutCreatedExamsInput>
  }

  export type UserUpdateWithoutCreatedExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examBookings?: ExamBookingUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    examAttempts?: ExamAttemptUpdateManyWithoutUserNestedInput
    questionResponses?: QuestionResponseUpdateManyWithoutUserNestedInput
    questionScores?: QuestionScoreUpdateManyWithoutUserNestedInput
    examScores?: ExamScoreUpdateManyWithoutUserNestedInput
    userPerformances?: UserPerformanceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    examCategories?: ExamCategoryUserUpdateManyWithoutUserNestedInput
    studyGroups?: StudyGroupMemberUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    grantedExamCategories?: ExamCategoryUserUpdateManyWithoutGranterNestedInput
    createdStudyGroups?: StudyGroupUpdateManyWithoutCreatorNestedInput
    createdQuestions?: QuestionUpdateManyWithoutCreatorNestedInput
    approvedQuestions?: QuestionUpdateManyWithoutApproverNestedInput
    approvedExams?: ExamUpdateManyWithoutApproverNestedInput
    revokedCertificates?: CertificateUpdateManyWithoutRevokerNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examBookings?: ExamBookingUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    examAttempts?: ExamAttemptUncheckedUpdateManyWithoutUserNestedInput
    questionResponses?: QuestionResponseUncheckedUpdateManyWithoutUserNestedInput
    questionScores?: QuestionScoreUncheckedUpdateManyWithoutUserNestedInput
    examScores?: ExamScoreUncheckedUpdateManyWithoutUserNestedInput
    userPerformances?: UserPerformanceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    examCategories?: ExamCategoryUserUncheckedUpdateManyWithoutUserNestedInput
    studyGroups?: StudyGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    grantedExamCategories?: ExamCategoryUserUncheckedUpdateManyWithoutGranterNestedInput
    createdStudyGroups?: StudyGroupUncheckedUpdateManyWithoutCreatorNestedInput
    createdQuestions?: QuestionUncheckedUpdateManyWithoutCreatorNestedInput
    approvedQuestions?: QuestionUncheckedUpdateManyWithoutApproverNestedInput
    approvedExams?: ExamUncheckedUpdateManyWithoutApproverNestedInput
    revokedCertificates?: CertificateUncheckedUpdateManyWithoutRevokerNestedInput
  }

  export type UserUpsertWithoutApprovedExamsInput = {
    update: XOR<UserUpdateWithoutApprovedExamsInput, UserUncheckedUpdateWithoutApprovedExamsInput>
    create: XOR<UserCreateWithoutApprovedExamsInput, UserUncheckedCreateWithoutApprovedExamsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovedExamsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovedExamsInput, UserUncheckedUpdateWithoutApprovedExamsInput>
  }

  export type UserUpdateWithoutApprovedExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examBookings?: ExamBookingUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    examAttempts?: ExamAttemptUpdateManyWithoutUserNestedInput
    questionResponses?: QuestionResponseUpdateManyWithoutUserNestedInput
    questionScores?: QuestionScoreUpdateManyWithoutUserNestedInput
    examScores?: ExamScoreUpdateManyWithoutUserNestedInput
    userPerformances?: UserPerformanceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    examCategories?: ExamCategoryUserUpdateManyWithoutUserNestedInput
    studyGroups?: StudyGroupMemberUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    grantedExamCategories?: ExamCategoryUserUpdateManyWithoutGranterNestedInput
    createdStudyGroups?: StudyGroupUpdateManyWithoutCreatorNestedInput
    createdQuestions?: QuestionUpdateManyWithoutCreatorNestedInput
    approvedQuestions?: QuestionUpdateManyWithoutApproverNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    revokedCertificates?: CertificateUpdateManyWithoutRevokerNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovedExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examBookings?: ExamBookingUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    examAttempts?: ExamAttemptUncheckedUpdateManyWithoutUserNestedInput
    questionResponses?: QuestionResponseUncheckedUpdateManyWithoutUserNestedInput
    questionScores?: QuestionScoreUncheckedUpdateManyWithoutUserNestedInput
    examScores?: ExamScoreUncheckedUpdateManyWithoutUserNestedInput
    userPerformances?: UserPerformanceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    examCategories?: ExamCategoryUserUncheckedUpdateManyWithoutUserNestedInput
    studyGroups?: StudyGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    grantedExamCategories?: ExamCategoryUserUncheckedUpdateManyWithoutGranterNestedInput
    createdStudyGroups?: StudyGroupUncheckedUpdateManyWithoutCreatorNestedInput
    createdQuestions?: QuestionUncheckedUpdateManyWithoutCreatorNestedInput
    approvedQuestions?: QuestionUncheckedUpdateManyWithoutApproverNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    revokedCertificates?: CertificateUncheckedUpdateManyWithoutRevokerNestedInput
  }

  export type ExamQuestionUpsertWithWhereUniqueWithoutExamInput = {
    where: ExamQuestionWhereUniqueInput
    update: XOR<ExamQuestionUpdateWithoutExamInput, ExamQuestionUncheckedUpdateWithoutExamInput>
    create: XOR<ExamQuestionCreateWithoutExamInput, ExamQuestionUncheckedCreateWithoutExamInput>
  }

  export type ExamQuestionUpdateWithWhereUniqueWithoutExamInput = {
    where: ExamQuestionWhereUniqueInput
    data: XOR<ExamQuestionUpdateWithoutExamInput, ExamQuestionUncheckedUpdateWithoutExamInput>
  }

  export type ExamQuestionUpdateManyWithWhereWithoutExamInput = {
    where: ExamQuestionScalarWhereInput
    data: XOR<ExamQuestionUpdateManyMutationInput, ExamQuestionUncheckedUpdateManyWithoutExamInput>
  }

  export type ExamBookingUpsertWithWhereUniqueWithoutExamInput = {
    where: ExamBookingWhereUniqueInput
    update: XOR<ExamBookingUpdateWithoutExamInput, ExamBookingUncheckedUpdateWithoutExamInput>
    create: XOR<ExamBookingCreateWithoutExamInput, ExamBookingUncheckedCreateWithoutExamInput>
  }

  export type ExamBookingUpdateWithWhereUniqueWithoutExamInput = {
    where: ExamBookingWhereUniqueInput
    data: XOR<ExamBookingUpdateWithoutExamInput, ExamBookingUncheckedUpdateWithoutExamInput>
  }

  export type ExamBookingUpdateManyWithWhereWithoutExamInput = {
    where: ExamBookingScalarWhereInput
    data: XOR<ExamBookingUpdateManyMutationInput, ExamBookingUncheckedUpdateManyWithoutExamInput>
  }

  export type ExamAttemptUpsertWithWhereUniqueWithoutExamInput = {
    where: ExamAttemptWhereUniqueInput
    update: XOR<ExamAttemptUpdateWithoutExamInput, ExamAttemptUncheckedUpdateWithoutExamInput>
    create: XOR<ExamAttemptCreateWithoutExamInput, ExamAttemptUncheckedCreateWithoutExamInput>
  }

  export type ExamAttemptUpdateWithWhereUniqueWithoutExamInput = {
    where: ExamAttemptWhereUniqueInput
    data: XOR<ExamAttemptUpdateWithoutExamInput, ExamAttemptUncheckedUpdateWithoutExamInput>
  }

  export type ExamAttemptUpdateManyWithWhereWithoutExamInput = {
    where: ExamAttemptScalarWhereInput
    data: XOR<ExamAttemptUpdateManyMutationInput, ExamAttemptUncheckedUpdateManyWithoutExamInput>
  }

  export type ExamScoreUpsertWithWhereUniqueWithoutExamInput = {
    where: ExamScoreWhereUniqueInput
    update: XOR<ExamScoreUpdateWithoutExamInput, ExamScoreUncheckedUpdateWithoutExamInput>
    create: XOR<ExamScoreCreateWithoutExamInput, ExamScoreUncheckedCreateWithoutExamInput>
  }

  export type ExamScoreUpdateWithWhereUniqueWithoutExamInput = {
    where: ExamScoreWhereUniqueInput
    data: XOR<ExamScoreUpdateWithoutExamInput, ExamScoreUncheckedUpdateWithoutExamInput>
  }

  export type ExamScoreUpdateManyWithWhereWithoutExamInput = {
    where: ExamScoreScalarWhereInput
    data: XOR<ExamScoreUpdateManyMutationInput, ExamScoreUncheckedUpdateManyWithoutExamInput>
  }

  export type CertificateUpsertWithWhereUniqueWithoutExamInput = {
    where: CertificateWhereUniqueInput
    update: XOR<CertificateUpdateWithoutExamInput, CertificateUncheckedUpdateWithoutExamInput>
    create: XOR<CertificateCreateWithoutExamInput, CertificateUncheckedCreateWithoutExamInput>
  }

  export type CertificateUpdateWithWhereUniqueWithoutExamInput = {
    where: CertificateWhereUniqueInput
    data: XOR<CertificateUpdateWithoutExamInput, CertificateUncheckedUpdateWithoutExamInput>
  }

  export type CertificateUpdateManyWithWhereWithoutExamInput = {
    where: CertificateScalarWhereInput
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyWithoutExamInput>
  }

  export type ExamCreateWithoutQuestionsInput = {
    id?: string
    title: string
    description?: string | null
    duration: number
    totalMarks: number
    passingMarks: number
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    isActive?: boolean
    isPublic?: boolean
    allowRetakes?: boolean
    maxRetakes?: number
    showResults?: boolean
    showAnswers?: boolean
    randomizeQuestions?: boolean
    randomizeOptions?: boolean
    questionOverlapPercentage?: number
    approvedAt?: Date | string | null
    scheduledStart?: Date | string | null
    scheduledEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examCategory: ExamCategoryCreateNestedOneWithoutExamsInput
    creator: UserCreateNestedOneWithoutCreatedExamsInput
    approver?: UserCreateNestedOneWithoutApprovedExamsInput
    bookings?: ExamBookingCreateNestedManyWithoutExamInput
    attempts?: ExamAttemptCreateNestedManyWithoutExamInput
    examScores?: ExamScoreCreateNestedManyWithoutExamInput
    certificates?: CertificateCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutQuestionsInput = {
    id?: string
    title: string
    description?: string | null
    examCategoryId: string
    duration: number
    totalMarks: number
    passingMarks: number
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    isActive?: boolean
    isPublic?: boolean
    allowRetakes?: boolean
    maxRetakes?: number
    showResults?: boolean
    showAnswers?: boolean
    randomizeQuestions?: boolean
    randomizeOptions?: boolean
    questionOverlapPercentage?: number
    createdBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    scheduledStart?: Date | string | null
    scheduledEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: ExamBookingUncheckedCreateNestedManyWithoutExamInput
    attempts?: ExamAttemptUncheckedCreateNestedManyWithoutExamInput
    examScores?: ExamScoreUncheckedCreateNestedManyWithoutExamInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutQuestionsInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutQuestionsInput, ExamUncheckedCreateWithoutQuestionsInput>
  }

  export type QuestionCreateWithoutExamQuestionsInput = {
    id?: string
    text: string
    type: $Enums.QuestionType
    difficulty: $Enums.QuestionDifficulty
    marks?: number
    timeLimit?: number | null
    isActive?: boolean
    isPublic?: boolean
    approvedAt?: Date | string | null
    usageCount?: number
    correctAnswerRate?: number | null
    averageTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examCategory: ExamCategoryCreateNestedOneWithoutQuestionsInput
    creator: UserCreateNestedOneWithoutCreatedQuestionsInput
    approver?: UserCreateNestedOneWithoutApprovedQuestionsInput
    options?: QuestionOptionCreateNestedManyWithoutQuestionInput
    images?: QuestionImageCreateNestedManyWithoutQuestionInput
    tags?: QuestionTagCreateNestedManyWithoutQuestionInput
    responses?: QuestionResponseCreateNestedManyWithoutQuestionInput
    scores?: QuestionScoreCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateWithoutExamQuestionsInput = {
    id?: string
    text: string
    type: $Enums.QuestionType
    difficulty: $Enums.QuestionDifficulty
    examCategoryId: string
    marks?: number
    timeLimit?: number | null
    isActive?: boolean
    isPublic?: boolean
    createdBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    usageCount?: number
    correctAnswerRate?: number | null
    averageTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: QuestionOptionUncheckedCreateNestedManyWithoutQuestionInput
    images?: QuestionImageUncheckedCreateNestedManyWithoutQuestionInput
    tags?: QuestionTagUncheckedCreateNestedManyWithoutQuestionInput
    responses?: QuestionResponseUncheckedCreateNestedManyWithoutQuestionInput
    scores?: QuestionScoreUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionCreateOrConnectWithoutExamQuestionsInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutExamQuestionsInput, QuestionUncheckedCreateWithoutExamQuestionsInput>
  }

  export type ExamUpsertWithoutQuestionsInput = {
    update: XOR<ExamUpdateWithoutQuestionsInput, ExamUncheckedUpdateWithoutQuestionsInput>
    create: XOR<ExamCreateWithoutQuestionsInput, ExamUncheckedCreateWithoutQuestionsInput>
    where?: ExamWhereInput
  }

  export type ExamUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: ExamWhereInput
    data: XOR<ExamUpdateWithoutQuestionsInput, ExamUncheckedUpdateWithoutQuestionsInput>
  }

  export type ExamUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    totalMarks?: IntFieldUpdateOperationsInput | number
    passingMarks?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowRetakes?: BoolFieldUpdateOperationsInput | boolean
    maxRetakes?: IntFieldUpdateOperationsInput | number
    showResults?: BoolFieldUpdateOperationsInput | boolean
    showAnswers?: BoolFieldUpdateOperationsInput | boolean
    randomizeQuestions?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: BoolFieldUpdateOperationsInput | boolean
    questionOverlapPercentage?: FloatFieldUpdateOperationsInput | number
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examCategory?: ExamCategoryUpdateOneRequiredWithoutExamsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedExamsNestedInput
    approver?: UserUpdateOneWithoutApprovedExamsNestedInput
    bookings?: ExamBookingUpdateManyWithoutExamNestedInput
    attempts?: ExamAttemptUpdateManyWithoutExamNestedInput
    examScores?: ExamScoreUpdateManyWithoutExamNestedInput
    certificates?: CertificateUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    examCategoryId?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    totalMarks?: IntFieldUpdateOperationsInput | number
    passingMarks?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowRetakes?: BoolFieldUpdateOperationsInput | boolean
    maxRetakes?: IntFieldUpdateOperationsInput | number
    showResults?: BoolFieldUpdateOperationsInput | boolean
    showAnswers?: BoolFieldUpdateOperationsInput | boolean
    randomizeQuestions?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: BoolFieldUpdateOperationsInput | boolean
    questionOverlapPercentage?: FloatFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: ExamBookingUncheckedUpdateManyWithoutExamNestedInput
    attempts?: ExamAttemptUncheckedUpdateManyWithoutExamNestedInput
    examScores?: ExamScoreUncheckedUpdateManyWithoutExamNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutExamNestedInput
  }

  export type QuestionUpsertWithoutExamQuestionsInput = {
    update: XOR<QuestionUpdateWithoutExamQuestionsInput, QuestionUncheckedUpdateWithoutExamQuestionsInput>
    create: XOR<QuestionCreateWithoutExamQuestionsInput, QuestionUncheckedCreateWithoutExamQuestionsInput>
    where?: QuestionWhereInput
  }

  export type QuestionUpdateToOneWithWhereWithoutExamQuestionsInput = {
    where?: QuestionWhereInput
    data: XOR<QuestionUpdateWithoutExamQuestionsInput, QuestionUncheckedUpdateWithoutExamQuestionsInput>
  }

  export type QuestionUpdateWithoutExamQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    difficulty?: EnumQuestionDifficultyFieldUpdateOperationsInput | $Enums.QuestionDifficulty
    marks?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    correctAnswerRate?: NullableFloatFieldUpdateOperationsInput | number | null
    averageTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examCategory?: ExamCategoryUpdateOneRequiredWithoutQuestionsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedQuestionsNestedInput
    approver?: UserUpdateOneWithoutApprovedQuestionsNestedInput
    options?: QuestionOptionUpdateManyWithoutQuestionNestedInput
    images?: QuestionImageUpdateManyWithoutQuestionNestedInput
    tags?: QuestionTagUpdateManyWithoutQuestionNestedInput
    responses?: QuestionResponseUpdateManyWithoutQuestionNestedInput
    scores?: QuestionScoreUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateWithoutExamQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    difficulty?: EnumQuestionDifficultyFieldUpdateOperationsInput | $Enums.QuestionDifficulty
    examCategoryId?: StringFieldUpdateOperationsInput | string
    marks?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    correctAnswerRate?: NullableFloatFieldUpdateOperationsInput | number | null
    averageTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: QuestionOptionUncheckedUpdateManyWithoutQuestionNestedInput
    images?: QuestionImageUncheckedUpdateManyWithoutQuestionNestedInput
    tags?: QuestionTagUncheckedUpdateManyWithoutQuestionNestedInput
    responses?: QuestionResponseUncheckedUpdateManyWithoutQuestionNestedInput
    scores?: QuestionScoreUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type UserCreateWithoutExamBookingsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentCreateNestedManyWithoutUserInput
    examAttempts?: ExamAttemptCreateNestedManyWithoutUserInput
    questionResponses?: QuestionResponseCreateNestedManyWithoutUserInput
    questionScores?: QuestionScoreCreateNestedManyWithoutUserInput
    examScores?: ExamScoreCreateNestedManyWithoutUserInput
    userPerformances?: UserPerformanceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    examCategories?: ExamCategoryUserCreateNestedManyWithoutUserInput
    studyGroups?: StudyGroupMemberCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    grantedExamCategories?: ExamCategoryUserCreateNestedManyWithoutGranterInput
    createdStudyGroups?: StudyGroupCreateNestedManyWithoutCreatorInput
    createdQuestions?: QuestionCreateNestedManyWithoutCreatorInput
    approvedQuestions?: QuestionCreateNestedManyWithoutApproverInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    approvedExams?: ExamCreateNestedManyWithoutApproverInput
    revokedCertificates?: CertificateCreateNestedManyWithoutRevokerInput
  }

  export type UserUncheckedCreateWithoutExamBookingsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    examAttempts?: ExamAttemptUncheckedCreateNestedManyWithoutUserInput
    questionResponses?: QuestionResponseUncheckedCreateNestedManyWithoutUserInput
    questionScores?: QuestionScoreUncheckedCreateNestedManyWithoutUserInput
    examScores?: ExamScoreUncheckedCreateNestedManyWithoutUserInput
    userPerformances?: UserPerformanceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    examCategories?: ExamCategoryUserUncheckedCreateNestedManyWithoutUserInput
    studyGroups?: StudyGroupMemberUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    grantedExamCategories?: ExamCategoryUserUncheckedCreateNestedManyWithoutGranterInput
    createdStudyGroups?: StudyGroupUncheckedCreateNestedManyWithoutCreatorInput
    createdQuestions?: QuestionUncheckedCreateNestedManyWithoutCreatorInput
    approvedQuestions?: QuestionUncheckedCreateNestedManyWithoutApproverInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    approvedExams?: ExamUncheckedCreateNestedManyWithoutApproverInput
    revokedCertificates?: CertificateUncheckedCreateNestedManyWithoutRevokerInput
  }

  export type UserCreateOrConnectWithoutExamBookingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExamBookingsInput, UserUncheckedCreateWithoutExamBookingsInput>
  }

  export type ExamCreateWithoutBookingsInput = {
    id?: string
    title: string
    description?: string | null
    duration: number
    totalMarks: number
    passingMarks: number
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    isActive?: boolean
    isPublic?: boolean
    allowRetakes?: boolean
    maxRetakes?: number
    showResults?: boolean
    showAnswers?: boolean
    randomizeQuestions?: boolean
    randomizeOptions?: boolean
    questionOverlapPercentage?: number
    approvedAt?: Date | string | null
    scheduledStart?: Date | string | null
    scheduledEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examCategory: ExamCategoryCreateNestedOneWithoutExamsInput
    creator: UserCreateNestedOneWithoutCreatedExamsInput
    approver?: UserCreateNestedOneWithoutApprovedExamsInput
    questions?: ExamQuestionCreateNestedManyWithoutExamInput
    attempts?: ExamAttemptCreateNestedManyWithoutExamInput
    examScores?: ExamScoreCreateNestedManyWithoutExamInput
    certificates?: CertificateCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutBookingsInput = {
    id?: string
    title: string
    description?: string | null
    examCategoryId: string
    duration: number
    totalMarks: number
    passingMarks: number
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    isActive?: boolean
    isPublic?: boolean
    allowRetakes?: boolean
    maxRetakes?: number
    showResults?: boolean
    showAnswers?: boolean
    randomizeQuestions?: boolean
    randomizeOptions?: boolean
    questionOverlapPercentage?: number
    createdBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    scheduledStart?: Date | string | null
    scheduledEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: ExamQuestionUncheckedCreateNestedManyWithoutExamInput
    attempts?: ExamAttemptUncheckedCreateNestedManyWithoutExamInput
    examScores?: ExamScoreUncheckedCreateNestedManyWithoutExamInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutBookingsInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutBookingsInput, ExamUncheckedCreateWithoutBookingsInput>
  }

  export type PaymentCreateWithoutBookingInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    stripePaymentId?: string | null
    stripeRefundId?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    refundedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutBookingInput = {
    id?: string
    userId: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    stripePaymentId?: string | null
    stripeRefundId?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    refundedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutBookingInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
  }

  export type ExamAttemptCreateWithoutBookingInput = {
    id?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.AttemptStatus
    totalMarks?: number
    obtainedMarks?: number
    percentage?: number
    isPassed?: boolean
    timeSpent?: number | null
    ipAddress?: string | null
    userAgent?: string | null
    isCheating?: boolean
    cheatingReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutExamAttemptsInput
    exam: ExamCreateNestedOneWithoutAttemptsInput
    responses?: QuestionResponseCreateNestedManyWithoutAttemptInput
    questionScores?: QuestionScoreCreateNestedManyWithoutAttemptInput
    examScore?: ExamScoreCreateNestedOneWithoutAttemptInput
    certificate?: CertificateCreateNestedOneWithoutAttemptInput
  }

  export type ExamAttemptUncheckedCreateWithoutBookingInput = {
    id?: string
    userId: string
    examId: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.AttemptStatus
    totalMarks?: number
    obtainedMarks?: number
    percentage?: number
    isPassed?: boolean
    timeSpent?: number | null
    ipAddress?: string | null
    userAgent?: string | null
    isCheating?: boolean
    cheatingReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: QuestionResponseUncheckedCreateNestedManyWithoutAttemptInput
    questionScores?: QuestionScoreUncheckedCreateNestedManyWithoutAttemptInput
    examScore?: ExamScoreUncheckedCreateNestedOneWithoutAttemptInput
    certificate?: CertificateUncheckedCreateNestedOneWithoutAttemptInput
  }

  export type ExamAttemptCreateOrConnectWithoutBookingInput = {
    where: ExamAttemptWhereUniqueInput
    create: XOR<ExamAttemptCreateWithoutBookingInput, ExamAttemptUncheckedCreateWithoutBookingInput>
  }

  export type ExamAttemptCreateManyBookingInputEnvelope = {
    data: ExamAttemptCreateManyBookingInput | ExamAttemptCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutExamBookingsInput = {
    update: XOR<UserUpdateWithoutExamBookingsInput, UserUncheckedUpdateWithoutExamBookingsInput>
    create: XOR<UserCreateWithoutExamBookingsInput, UserUncheckedCreateWithoutExamBookingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExamBookingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExamBookingsInput, UserUncheckedUpdateWithoutExamBookingsInput>
  }

  export type UserUpdateWithoutExamBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUpdateManyWithoutUserNestedInput
    examAttempts?: ExamAttemptUpdateManyWithoutUserNestedInput
    questionResponses?: QuestionResponseUpdateManyWithoutUserNestedInput
    questionScores?: QuestionScoreUpdateManyWithoutUserNestedInput
    examScores?: ExamScoreUpdateManyWithoutUserNestedInput
    userPerformances?: UserPerformanceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    examCategories?: ExamCategoryUserUpdateManyWithoutUserNestedInput
    studyGroups?: StudyGroupMemberUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    grantedExamCategories?: ExamCategoryUserUpdateManyWithoutGranterNestedInput
    createdStudyGroups?: StudyGroupUpdateManyWithoutCreatorNestedInput
    createdQuestions?: QuestionUpdateManyWithoutCreatorNestedInput
    approvedQuestions?: QuestionUpdateManyWithoutApproverNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    approvedExams?: ExamUpdateManyWithoutApproverNestedInput
    revokedCertificates?: CertificateUpdateManyWithoutRevokerNestedInput
  }

  export type UserUncheckedUpdateWithoutExamBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    examAttempts?: ExamAttemptUncheckedUpdateManyWithoutUserNestedInput
    questionResponses?: QuestionResponseUncheckedUpdateManyWithoutUserNestedInput
    questionScores?: QuestionScoreUncheckedUpdateManyWithoutUserNestedInput
    examScores?: ExamScoreUncheckedUpdateManyWithoutUserNestedInput
    userPerformances?: UserPerformanceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    examCategories?: ExamCategoryUserUncheckedUpdateManyWithoutUserNestedInput
    studyGroups?: StudyGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    grantedExamCategories?: ExamCategoryUserUncheckedUpdateManyWithoutGranterNestedInput
    createdStudyGroups?: StudyGroupUncheckedUpdateManyWithoutCreatorNestedInput
    createdQuestions?: QuestionUncheckedUpdateManyWithoutCreatorNestedInput
    approvedQuestions?: QuestionUncheckedUpdateManyWithoutApproverNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    approvedExams?: ExamUncheckedUpdateManyWithoutApproverNestedInput
    revokedCertificates?: CertificateUncheckedUpdateManyWithoutRevokerNestedInput
  }

  export type ExamUpsertWithoutBookingsInput = {
    update: XOR<ExamUpdateWithoutBookingsInput, ExamUncheckedUpdateWithoutBookingsInput>
    create: XOR<ExamCreateWithoutBookingsInput, ExamUncheckedCreateWithoutBookingsInput>
    where?: ExamWhereInput
  }

  export type ExamUpdateToOneWithWhereWithoutBookingsInput = {
    where?: ExamWhereInput
    data: XOR<ExamUpdateWithoutBookingsInput, ExamUncheckedUpdateWithoutBookingsInput>
  }

  export type ExamUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    totalMarks?: IntFieldUpdateOperationsInput | number
    passingMarks?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowRetakes?: BoolFieldUpdateOperationsInput | boolean
    maxRetakes?: IntFieldUpdateOperationsInput | number
    showResults?: BoolFieldUpdateOperationsInput | boolean
    showAnswers?: BoolFieldUpdateOperationsInput | boolean
    randomizeQuestions?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: BoolFieldUpdateOperationsInput | boolean
    questionOverlapPercentage?: FloatFieldUpdateOperationsInput | number
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examCategory?: ExamCategoryUpdateOneRequiredWithoutExamsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedExamsNestedInput
    approver?: UserUpdateOneWithoutApprovedExamsNestedInput
    questions?: ExamQuestionUpdateManyWithoutExamNestedInput
    attempts?: ExamAttemptUpdateManyWithoutExamNestedInput
    examScores?: ExamScoreUpdateManyWithoutExamNestedInput
    certificates?: CertificateUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    examCategoryId?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    totalMarks?: IntFieldUpdateOperationsInput | number
    passingMarks?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowRetakes?: BoolFieldUpdateOperationsInput | boolean
    maxRetakes?: IntFieldUpdateOperationsInput | number
    showResults?: BoolFieldUpdateOperationsInput | boolean
    showAnswers?: BoolFieldUpdateOperationsInput | boolean
    randomizeQuestions?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: BoolFieldUpdateOperationsInput | boolean
    questionOverlapPercentage?: FloatFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: ExamQuestionUncheckedUpdateManyWithoutExamNestedInput
    attempts?: ExamAttemptUncheckedUpdateManyWithoutExamNestedInput
    examScores?: ExamScoreUncheckedUpdateManyWithoutExamNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutExamNestedInput
  }

  export type PaymentUpsertWithoutBookingInput = {
    update: XOR<PaymentUpdateWithoutBookingInput, PaymentUncheckedUpdateWithoutBookingInput>
    create: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutBookingInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutBookingInput, PaymentUncheckedUpdateWithoutBookingInput>
  }

  export type PaymentUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    stripePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    stripePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamAttemptUpsertWithWhereUniqueWithoutBookingInput = {
    where: ExamAttemptWhereUniqueInput
    update: XOR<ExamAttemptUpdateWithoutBookingInput, ExamAttemptUncheckedUpdateWithoutBookingInput>
    create: XOR<ExamAttemptCreateWithoutBookingInput, ExamAttemptUncheckedCreateWithoutBookingInput>
  }

  export type ExamAttemptUpdateWithWhereUniqueWithoutBookingInput = {
    where: ExamAttemptWhereUniqueInput
    data: XOR<ExamAttemptUpdateWithoutBookingInput, ExamAttemptUncheckedUpdateWithoutBookingInput>
  }

  export type ExamAttemptUpdateManyWithWhereWithoutBookingInput = {
    where: ExamAttemptScalarWhereInput
    data: XOR<ExamAttemptUpdateManyMutationInput, ExamAttemptUncheckedUpdateManyWithoutBookingInput>
  }

  export type UserCreateWithoutExamAttemptsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examBookings?: ExamBookingCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    questionResponses?: QuestionResponseCreateNestedManyWithoutUserInput
    questionScores?: QuestionScoreCreateNestedManyWithoutUserInput
    examScores?: ExamScoreCreateNestedManyWithoutUserInput
    userPerformances?: UserPerformanceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    examCategories?: ExamCategoryUserCreateNestedManyWithoutUserInput
    studyGroups?: StudyGroupMemberCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    grantedExamCategories?: ExamCategoryUserCreateNestedManyWithoutGranterInput
    createdStudyGroups?: StudyGroupCreateNestedManyWithoutCreatorInput
    createdQuestions?: QuestionCreateNestedManyWithoutCreatorInput
    approvedQuestions?: QuestionCreateNestedManyWithoutApproverInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    approvedExams?: ExamCreateNestedManyWithoutApproverInput
    revokedCertificates?: CertificateCreateNestedManyWithoutRevokerInput
  }

  export type UserUncheckedCreateWithoutExamAttemptsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examBookings?: ExamBookingUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    questionResponses?: QuestionResponseUncheckedCreateNestedManyWithoutUserInput
    questionScores?: QuestionScoreUncheckedCreateNestedManyWithoutUserInput
    examScores?: ExamScoreUncheckedCreateNestedManyWithoutUserInput
    userPerformances?: UserPerformanceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    examCategories?: ExamCategoryUserUncheckedCreateNestedManyWithoutUserInput
    studyGroups?: StudyGroupMemberUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    grantedExamCategories?: ExamCategoryUserUncheckedCreateNestedManyWithoutGranterInput
    createdStudyGroups?: StudyGroupUncheckedCreateNestedManyWithoutCreatorInput
    createdQuestions?: QuestionUncheckedCreateNestedManyWithoutCreatorInput
    approvedQuestions?: QuestionUncheckedCreateNestedManyWithoutApproverInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    approvedExams?: ExamUncheckedCreateNestedManyWithoutApproverInput
    revokedCertificates?: CertificateUncheckedCreateNestedManyWithoutRevokerInput
  }

  export type UserCreateOrConnectWithoutExamAttemptsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExamAttemptsInput, UserUncheckedCreateWithoutExamAttemptsInput>
  }

  export type ExamCreateWithoutAttemptsInput = {
    id?: string
    title: string
    description?: string | null
    duration: number
    totalMarks: number
    passingMarks: number
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    isActive?: boolean
    isPublic?: boolean
    allowRetakes?: boolean
    maxRetakes?: number
    showResults?: boolean
    showAnswers?: boolean
    randomizeQuestions?: boolean
    randomizeOptions?: boolean
    questionOverlapPercentage?: number
    approvedAt?: Date | string | null
    scheduledStart?: Date | string | null
    scheduledEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examCategory: ExamCategoryCreateNestedOneWithoutExamsInput
    creator: UserCreateNestedOneWithoutCreatedExamsInput
    approver?: UserCreateNestedOneWithoutApprovedExamsInput
    questions?: ExamQuestionCreateNestedManyWithoutExamInput
    bookings?: ExamBookingCreateNestedManyWithoutExamInput
    examScores?: ExamScoreCreateNestedManyWithoutExamInput
    certificates?: CertificateCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutAttemptsInput = {
    id?: string
    title: string
    description?: string | null
    examCategoryId: string
    duration: number
    totalMarks: number
    passingMarks: number
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    isActive?: boolean
    isPublic?: boolean
    allowRetakes?: boolean
    maxRetakes?: number
    showResults?: boolean
    showAnswers?: boolean
    randomizeQuestions?: boolean
    randomizeOptions?: boolean
    questionOverlapPercentage?: number
    createdBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    scheduledStart?: Date | string | null
    scheduledEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: ExamQuestionUncheckedCreateNestedManyWithoutExamInput
    bookings?: ExamBookingUncheckedCreateNestedManyWithoutExamInput
    examScores?: ExamScoreUncheckedCreateNestedManyWithoutExamInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutAttemptsInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutAttemptsInput, ExamUncheckedCreateWithoutAttemptsInput>
  }

  export type ExamBookingCreateWithoutAttemptsInput = {
    id?: string
    bookingDate?: Date | string
    scheduledAt?: Date | string | null
    status?: $Enums.BookingStatus
    paymentId?: string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutExamBookingsInput
    exam: ExamCreateNestedOneWithoutBookingsInput
    payment?: PaymentCreateNestedOneWithoutBookingInput
  }

  export type ExamBookingUncheckedCreateWithoutAttemptsInput = {
    id?: string
    userId: string
    examId: string
    bookingDate?: Date | string
    scheduledAt?: Date | string | null
    status?: $Enums.BookingStatus
    paymentId?: string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payment?: PaymentUncheckedCreateNestedOneWithoutBookingInput
  }

  export type ExamBookingCreateOrConnectWithoutAttemptsInput = {
    where: ExamBookingWhereUniqueInput
    create: XOR<ExamBookingCreateWithoutAttemptsInput, ExamBookingUncheckedCreateWithoutAttemptsInput>
  }

  export type QuestionResponseCreateWithoutAttemptInput = {
    id?: string
    selectedOptions?: QuestionResponseCreateselectedOptionsInput | string[]
    isCorrect?: boolean | null
    marksObtained?: number
    timeSpent?: number | null
    answeredAt?: Date | string
    submittedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    question: QuestionCreateNestedOneWithoutResponsesInput
    user: UserCreateNestedOneWithoutQuestionResponsesInput
    score?: QuestionScoreCreateNestedOneWithoutResponseInput
  }

  export type QuestionResponseUncheckedCreateWithoutAttemptInput = {
    id?: string
    questionId: string
    userId: string
    selectedOptions?: QuestionResponseCreateselectedOptionsInput | string[]
    isCorrect?: boolean | null
    marksObtained?: number
    timeSpent?: number | null
    answeredAt?: Date | string
    submittedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    score?: QuestionScoreUncheckedCreateNestedOneWithoutResponseInput
  }

  export type QuestionResponseCreateOrConnectWithoutAttemptInput = {
    where: QuestionResponseWhereUniqueInput
    create: XOR<QuestionResponseCreateWithoutAttemptInput, QuestionResponseUncheckedCreateWithoutAttemptInput>
  }

  export type QuestionResponseCreateManyAttemptInputEnvelope = {
    data: QuestionResponseCreateManyAttemptInput | QuestionResponseCreateManyAttemptInput[]
    skipDuplicates?: boolean
  }

  export type QuestionScoreCreateWithoutAttemptInput = {
    id?: string
    isCorrect?: boolean
    marksObtained?: number
    maxMarks?: number
    accuracy?: number
    timeEfficiency?: number
    difficultyBonus?: number
    penalty?: number
    responseTime?: number
    attemptsCount?: number
    confidenceLevel?: number
    questionDifficulty: string
    scoredAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    response: QuestionResponseCreateNestedOneWithoutScoreInput
    question: QuestionCreateNestedOneWithoutScoresInput
    user: UserCreateNestedOneWithoutQuestionScoresInput
  }

  export type QuestionScoreUncheckedCreateWithoutAttemptInput = {
    id?: string
    responseId: string
    questionId: string
    userId: string
    isCorrect?: boolean
    marksObtained?: number
    maxMarks?: number
    accuracy?: number
    timeEfficiency?: number
    difficultyBonus?: number
    penalty?: number
    responseTime?: number
    attemptsCount?: number
    confidenceLevel?: number
    questionDifficulty: string
    scoredAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionScoreCreateOrConnectWithoutAttemptInput = {
    where: QuestionScoreWhereUniqueInput
    create: XOR<QuestionScoreCreateWithoutAttemptInput, QuestionScoreUncheckedCreateWithoutAttemptInput>
  }

  export type QuestionScoreCreateManyAttemptInputEnvelope = {
    data: QuestionScoreCreateManyAttemptInput | QuestionScoreCreateManyAttemptInput[]
    skipDuplicates?: boolean
  }

  export type ExamScoreCreateWithoutAttemptInput = {
    id?: string
    totalMarks?: number
    maxMarks?: number
    percentage?: number
    grade?: string | null
    correctAnswers?: number
    wrongAnswers?: number
    unanswered?: number
    totalQuestions?: number
    totalTimeSpent?: number
    averageTimePerQuestion?: number
    timeEfficiency?: number
    easyCorrect?: number
    easyTotal?: number
    mediumCorrect?: number
    mediumTotal?: number
    hardCorrect?: number
    hardTotal?: number
    accuracy?: number
    speedScore?: number
    consistencyScore?: number
    difficultyScore?: number
    percentile?: number | null
    rank?: number | null
    improvement?: number | null
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    exam: ExamCreateNestedOneWithoutExamScoresInput
    user: UserCreateNestedOneWithoutExamScoresInput
  }

  export type ExamScoreUncheckedCreateWithoutAttemptInput = {
    id?: string
    examId: string
    userId: string
    totalMarks?: number
    maxMarks?: number
    percentage?: number
    grade?: string | null
    correctAnswers?: number
    wrongAnswers?: number
    unanswered?: number
    totalQuestions?: number
    totalTimeSpent?: number
    averageTimePerQuestion?: number
    timeEfficiency?: number
    easyCorrect?: number
    easyTotal?: number
    mediumCorrect?: number
    mediumTotal?: number
    hardCorrect?: number
    hardTotal?: number
    accuracy?: number
    speedScore?: number
    consistencyScore?: number
    difficultyScore?: number
    percentile?: number | null
    rank?: number | null
    improvement?: number | null
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamScoreCreateOrConnectWithoutAttemptInput = {
    where: ExamScoreWhereUniqueInput
    create: XOR<ExamScoreCreateWithoutAttemptInput, ExamScoreUncheckedCreateWithoutAttemptInput>
  }

  export type CertificateCreateWithoutAttemptInput = {
    id?: string
    certificateNumber: string
    issuedAt?: Date | string
    expiresAt?: Date | string | null
    isRevoked?: boolean
    revokedAt?: Date | string | null
    revokedReason?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCertificatesInput
    exam: ExamCreateNestedOneWithoutCertificatesInput
    revoker?: UserCreateNestedOneWithoutRevokedCertificatesInput
  }

  export type CertificateUncheckedCreateWithoutAttemptInput = {
    id?: string
    userId: string
    examId: string
    certificateNumber: string
    issuedAt?: Date | string
    expiresAt?: Date | string | null
    isRevoked?: boolean
    revokedAt?: Date | string | null
    revokedBy?: string | null
    revokedReason?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificateCreateOrConnectWithoutAttemptInput = {
    where: CertificateWhereUniqueInput
    create: XOR<CertificateCreateWithoutAttemptInput, CertificateUncheckedCreateWithoutAttemptInput>
  }

  export type UserUpsertWithoutExamAttemptsInput = {
    update: XOR<UserUpdateWithoutExamAttemptsInput, UserUncheckedUpdateWithoutExamAttemptsInput>
    create: XOR<UserCreateWithoutExamAttemptsInput, UserUncheckedCreateWithoutExamAttemptsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExamAttemptsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExamAttemptsInput, UserUncheckedUpdateWithoutExamAttemptsInput>
  }

  export type UserUpdateWithoutExamAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examBookings?: ExamBookingUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    questionResponses?: QuestionResponseUpdateManyWithoutUserNestedInput
    questionScores?: QuestionScoreUpdateManyWithoutUserNestedInput
    examScores?: ExamScoreUpdateManyWithoutUserNestedInput
    userPerformances?: UserPerformanceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    examCategories?: ExamCategoryUserUpdateManyWithoutUserNestedInput
    studyGroups?: StudyGroupMemberUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    grantedExamCategories?: ExamCategoryUserUpdateManyWithoutGranterNestedInput
    createdStudyGroups?: StudyGroupUpdateManyWithoutCreatorNestedInput
    createdQuestions?: QuestionUpdateManyWithoutCreatorNestedInput
    approvedQuestions?: QuestionUpdateManyWithoutApproverNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    approvedExams?: ExamUpdateManyWithoutApproverNestedInput
    revokedCertificates?: CertificateUpdateManyWithoutRevokerNestedInput
  }

  export type UserUncheckedUpdateWithoutExamAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examBookings?: ExamBookingUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    questionResponses?: QuestionResponseUncheckedUpdateManyWithoutUserNestedInput
    questionScores?: QuestionScoreUncheckedUpdateManyWithoutUserNestedInput
    examScores?: ExamScoreUncheckedUpdateManyWithoutUserNestedInput
    userPerformances?: UserPerformanceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    examCategories?: ExamCategoryUserUncheckedUpdateManyWithoutUserNestedInput
    studyGroups?: StudyGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    grantedExamCategories?: ExamCategoryUserUncheckedUpdateManyWithoutGranterNestedInput
    createdStudyGroups?: StudyGroupUncheckedUpdateManyWithoutCreatorNestedInput
    createdQuestions?: QuestionUncheckedUpdateManyWithoutCreatorNestedInput
    approvedQuestions?: QuestionUncheckedUpdateManyWithoutApproverNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    approvedExams?: ExamUncheckedUpdateManyWithoutApproverNestedInput
    revokedCertificates?: CertificateUncheckedUpdateManyWithoutRevokerNestedInput
  }

  export type ExamUpsertWithoutAttemptsInput = {
    update: XOR<ExamUpdateWithoutAttemptsInput, ExamUncheckedUpdateWithoutAttemptsInput>
    create: XOR<ExamCreateWithoutAttemptsInput, ExamUncheckedCreateWithoutAttemptsInput>
    where?: ExamWhereInput
  }

  export type ExamUpdateToOneWithWhereWithoutAttemptsInput = {
    where?: ExamWhereInput
    data: XOR<ExamUpdateWithoutAttemptsInput, ExamUncheckedUpdateWithoutAttemptsInput>
  }

  export type ExamUpdateWithoutAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    totalMarks?: IntFieldUpdateOperationsInput | number
    passingMarks?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowRetakes?: BoolFieldUpdateOperationsInput | boolean
    maxRetakes?: IntFieldUpdateOperationsInput | number
    showResults?: BoolFieldUpdateOperationsInput | boolean
    showAnswers?: BoolFieldUpdateOperationsInput | boolean
    randomizeQuestions?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: BoolFieldUpdateOperationsInput | boolean
    questionOverlapPercentage?: FloatFieldUpdateOperationsInput | number
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examCategory?: ExamCategoryUpdateOneRequiredWithoutExamsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedExamsNestedInput
    approver?: UserUpdateOneWithoutApprovedExamsNestedInput
    questions?: ExamQuestionUpdateManyWithoutExamNestedInput
    bookings?: ExamBookingUpdateManyWithoutExamNestedInput
    examScores?: ExamScoreUpdateManyWithoutExamNestedInput
    certificates?: CertificateUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    examCategoryId?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    totalMarks?: IntFieldUpdateOperationsInput | number
    passingMarks?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowRetakes?: BoolFieldUpdateOperationsInput | boolean
    maxRetakes?: IntFieldUpdateOperationsInput | number
    showResults?: BoolFieldUpdateOperationsInput | boolean
    showAnswers?: BoolFieldUpdateOperationsInput | boolean
    randomizeQuestions?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: BoolFieldUpdateOperationsInput | boolean
    questionOverlapPercentage?: FloatFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: ExamQuestionUncheckedUpdateManyWithoutExamNestedInput
    bookings?: ExamBookingUncheckedUpdateManyWithoutExamNestedInput
    examScores?: ExamScoreUncheckedUpdateManyWithoutExamNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutExamNestedInput
  }

  export type ExamBookingUpsertWithoutAttemptsInput = {
    update: XOR<ExamBookingUpdateWithoutAttemptsInput, ExamBookingUncheckedUpdateWithoutAttemptsInput>
    create: XOR<ExamBookingCreateWithoutAttemptsInput, ExamBookingUncheckedCreateWithoutAttemptsInput>
    where?: ExamBookingWhereInput
  }

  export type ExamBookingUpdateToOneWithWhereWithoutAttemptsInput = {
    where?: ExamBookingWhereInput
    data: XOR<ExamBookingUpdateWithoutAttemptsInput, ExamBookingUncheckedUpdateWithoutAttemptsInput>
  }

  export type ExamBookingUpdateWithoutAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExamBookingsNestedInput
    exam?: ExamUpdateOneRequiredWithoutBookingsNestedInput
    payment?: PaymentUpdateOneWithoutBookingNestedInput
  }

  export type ExamBookingUncheckedUpdateWithoutAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type QuestionResponseUpsertWithWhereUniqueWithoutAttemptInput = {
    where: QuestionResponseWhereUniqueInput
    update: XOR<QuestionResponseUpdateWithoutAttemptInput, QuestionResponseUncheckedUpdateWithoutAttemptInput>
    create: XOR<QuestionResponseCreateWithoutAttemptInput, QuestionResponseUncheckedCreateWithoutAttemptInput>
  }

  export type QuestionResponseUpdateWithWhereUniqueWithoutAttemptInput = {
    where: QuestionResponseWhereUniqueInput
    data: XOR<QuestionResponseUpdateWithoutAttemptInput, QuestionResponseUncheckedUpdateWithoutAttemptInput>
  }

  export type QuestionResponseUpdateManyWithWhereWithoutAttemptInput = {
    where: QuestionResponseScalarWhereInput
    data: XOR<QuestionResponseUpdateManyMutationInput, QuestionResponseUncheckedUpdateManyWithoutAttemptInput>
  }

  export type QuestionScoreUpsertWithWhereUniqueWithoutAttemptInput = {
    where: QuestionScoreWhereUniqueInput
    update: XOR<QuestionScoreUpdateWithoutAttemptInput, QuestionScoreUncheckedUpdateWithoutAttemptInput>
    create: XOR<QuestionScoreCreateWithoutAttemptInput, QuestionScoreUncheckedCreateWithoutAttemptInput>
  }

  export type QuestionScoreUpdateWithWhereUniqueWithoutAttemptInput = {
    where: QuestionScoreWhereUniqueInput
    data: XOR<QuestionScoreUpdateWithoutAttemptInput, QuestionScoreUncheckedUpdateWithoutAttemptInput>
  }

  export type QuestionScoreUpdateManyWithWhereWithoutAttemptInput = {
    where: QuestionScoreScalarWhereInput
    data: XOR<QuestionScoreUpdateManyMutationInput, QuestionScoreUncheckedUpdateManyWithoutAttemptInput>
  }

  export type ExamScoreUpsertWithoutAttemptInput = {
    update: XOR<ExamScoreUpdateWithoutAttemptInput, ExamScoreUncheckedUpdateWithoutAttemptInput>
    create: XOR<ExamScoreCreateWithoutAttemptInput, ExamScoreUncheckedCreateWithoutAttemptInput>
    where?: ExamScoreWhereInput
  }

  export type ExamScoreUpdateToOneWithWhereWithoutAttemptInput = {
    where?: ExamScoreWhereInput
    data: XOR<ExamScoreUpdateWithoutAttemptInput, ExamScoreUncheckedUpdateWithoutAttemptInput>
  }

  export type ExamScoreUpdateWithoutAttemptInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalMarks?: FloatFieldUpdateOperationsInput | number
    maxMarks?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswers?: IntFieldUpdateOperationsInput | number
    wrongAnswers?: IntFieldUpdateOperationsInput | number
    unanswered?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    totalTimeSpent?: IntFieldUpdateOperationsInput | number
    averageTimePerQuestion?: FloatFieldUpdateOperationsInput | number
    timeEfficiency?: FloatFieldUpdateOperationsInput | number
    easyCorrect?: IntFieldUpdateOperationsInput | number
    easyTotal?: IntFieldUpdateOperationsInput | number
    mediumCorrect?: IntFieldUpdateOperationsInput | number
    mediumTotal?: IntFieldUpdateOperationsInput | number
    hardCorrect?: IntFieldUpdateOperationsInput | number
    hardTotal?: IntFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    speedScore?: FloatFieldUpdateOperationsInput | number
    consistencyScore?: FloatFieldUpdateOperationsInput | number
    difficultyScore?: FloatFieldUpdateOperationsInput | number
    percentile?: NullableFloatFieldUpdateOperationsInput | number | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    improvement?: NullableFloatFieldUpdateOperationsInput | number | null
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exam?: ExamUpdateOneRequiredWithoutExamScoresNestedInput
    user?: UserUpdateOneRequiredWithoutExamScoresNestedInput
  }

  export type ExamScoreUncheckedUpdateWithoutAttemptInput = {
    id?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalMarks?: FloatFieldUpdateOperationsInput | number
    maxMarks?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswers?: IntFieldUpdateOperationsInput | number
    wrongAnswers?: IntFieldUpdateOperationsInput | number
    unanswered?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    totalTimeSpent?: IntFieldUpdateOperationsInput | number
    averageTimePerQuestion?: FloatFieldUpdateOperationsInput | number
    timeEfficiency?: FloatFieldUpdateOperationsInput | number
    easyCorrect?: IntFieldUpdateOperationsInput | number
    easyTotal?: IntFieldUpdateOperationsInput | number
    mediumCorrect?: IntFieldUpdateOperationsInput | number
    mediumTotal?: IntFieldUpdateOperationsInput | number
    hardCorrect?: IntFieldUpdateOperationsInput | number
    hardTotal?: IntFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    speedScore?: FloatFieldUpdateOperationsInput | number
    consistencyScore?: FloatFieldUpdateOperationsInput | number
    difficultyScore?: FloatFieldUpdateOperationsInput | number
    percentile?: NullableFloatFieldUpdateOperationsInput | number | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    improvement?: NullableFloatFieldUpdateOperationsInput | number | null
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUpsertWithoutAttemptInput = {
    update: XOR<CertificateUpdateWithoutAttemptInput, CertificateUncheckedUpdateWithoutAttemptInput>
    create: XOR<CertificateCreateWithoutAttemptInput, CertificateUncheckedCreateWithoutAttemptInput>
    where?: CertificateWhereInput
  }

  export type CertificateUpdateToOneWithWhereWithoutAttemptInput = {
    where?: CertificateWhereInput
    data: XOR<CertificateUpdateWithoutAttemptInput, CertificateUncheckedUpdateWithoutAttemptInput>
  }

  export type CertificateUpdateWithoutAttemptInput = {
    id?: StringFieldUpdateOperationsInput | string
    certificateNumber?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCertificatesNestedInput
    exam?: ExamUpdateOneRequiredWithoutCertificatesNestedInput
    revoker?: UserUpdateOneWithoutRevokedCertificatesNestedInput
  }

  export type CertificateUncheckedUpdateWithoutAttemptInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    certificateNumber?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedBy?: NullableStringFieldUpdateOperationsInput | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamAttemptCreateWithoutResponsesInput = {
    id?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.AttemptStatus
    totalMarks?: number
    obtainedMarks?: number
    percentage?: number
    isPassed?: boolean
    timeSpent?: number | null
    ipAddress?: string | null
    userAgent?: string | null
    isCheating?: boolean
    cheatingReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutExamAttemptsInput
    exam: ExamCreateNestedOneWithoutAttemptsInput
    booking?: ExamBookingCreateNestedOneWithoutAttemptsInput
    questionScores?: QuestionScoreCreateNestedManyWithoutAttemptInput
    examScore?: ExamScoreCreateNestedOneWithoutAttemptInput
    certificate?: CertificateCreateNestedOneWithoutAttemptInput
  }

  export type ExamAttemptUncheckedCreateWithoutResponsesInput = {
    id?: string
    userId: string
    examId: string
    bookingId?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.AttemptStatus
    totalMarks?: number
    obtainedMarks?: number
    percentage?: number
    isPassed?: boolean
    timeSpent?: number | null
    ipAddress?: string | null
    userAgent?: string | null
    isCheating?: boolean
    cheatingReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questionScores?: QuestionScoreUncheckedCreateNestedManyWithoutAttemptInput
    examScore?: ExamScoreUncheckedCreateNestedOneWithoutAttemptInput
    certificate?: CertificateUncheckedCreateNestedOneWithoutAttemptInput
  }

  export type ExamAttemptCreateOrConnectWithoutResponsesInput = {
    where: ExamAttemptWhereUniqueInput
    create: XOR<ExamAttemptCreateWithoutResponsesInput, ExamAttemptUncheckedCreateWithoutResponsesInput>
  }

  export type QuestionCreateWithoutResponsesInput = {
    id?: string
    text: string
    type: $Enums.QuestionType
    difficulty: $Enums.QuestionDifficulty
    marks?: number
    timeLimit?: number | null
    isActive?: boolean
    isPublic?: boolean
    approvedAt?: Date | string | null
    usageCount?: number
    correctAnswerRate?: number | null
    averageTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examCategory: ExamCategoryCreateNestedOneWithoutQuestionsInput
    creator: UserCreateNestedOneWithoutCreatedQuestionsInput
    approver?: UserCreateNestedOneWithoutApprovedQuestionsInput
    options?: QuestionOptionCreateNestedManyWithoutQuestionInput
    images?: QuestionImageCreateNestedManyWithoutQuestionInput
    tags?: QuestionTagCreateNestedManyWithoutQuestionInput
    examQuestions?: ExamQuestionCreateNestedManyWithoutQuestionInput
    scores?: QuestionScoreCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateWithoutResponsesInput = {
    id?: string
    text: string
    type: $Enums.QuestionType
    difficulty: $Enums.QuestionDifficulty
    examCategoryId: string
    marks?: number
    timeLimit?: number | null
    isActive?: boolean
    isPublic?: boolean
    createdBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    usageCount?: number
    correctAnswerRate?: number | null
    averageTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: QuestionOptionUncheckedCreateNestedManyWithoutQuestionInput
    images?: QuestionImageUncheckedCreateNestedManyWithoutQuestionInput
    tags?: QuestionTagUncheckedCreateNestedManyWithoutQuestionInput
    examQuestions?: ExamQuestionUncheckedCreateNestedManyWithoutQuestionInput
    scores?: QuestionScoreUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionCreateOrConnectWithoutResponsesInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutResponsesInput, QuestionUncheckedCreateWithoutResponsesInput>
  }

  export type UserCreateWithoutQuestionResponsesInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examBookings?: ExamBookingCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    examAttempts?: ExamAttemptCreateNestedManyWithoutUserInput
    questionScores?: QuestionScoreCreateNestedManyWithoutUserInput
    examScores?: ExamScoreCreateNestedManyWithoutUserInput
    userPerformances?: UserPerformanceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    examCategories?: ExamCategoryUserCreateNestedManyWithoutUserInput
    studyGroups?: StudyGroupMemberCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    grantedExamCategories?: ExamCategoryUserCreateNestedManyWithoutGranterInput
    createdStudyGroups?: StudyGroupCreateNestedManyWithoutCreatorInput
    createdQuestions?: QuestionCreateNestedManyWithoutCreatorInput
    approvedQuestions?: QuestionCreateNestedManyWithoutApproverInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    approvedExams?: ExamCreateNestedManyWithoutApproverInput
    revokedCertificates?: CertificateCreateNestedManyWithoutRevokerInput
  }

  export type UserUncheckedCreateWithoutQuestionResponsesInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examBookings?: ExamBookingUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    examAttempts?: ExamAttemptUncheckedCreateNestedManyWithoutUserInput
    questionScores?: QuestionScoreUncheckedCreateNestedManyWithoutUserInput
    examScores?: ExamScoreUncheckedCreateNestedManyWithoutUserInput
    userPerformances?: UserPerformanceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    examCategories?: ExamCategoryUserUncheckedCreateNestedManyWithoutUserInput
    studyGroups?: StudyGroupMemberUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    grantedExamCategories?: ExamCategoryUserUncheckedCreateNestedManyWithoutGranterInput
    createdStudyGroups?: StudyGroupUncheckedCreateNestedManyWithoutCreatorInput
    createdQuestions?: QuestionUncheckedCreateNestedManyWithoutCreatorInput
    approvedQuestions?: QuestionUncheckedCreateNestedManyWithoutApproverInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    approvedExams?: ExamUncheckedCreateNestedManyWithoutApproverInput
    revokedCertificates?: CertificateUncheckedCreateNestedManyWithoutRevokerInput
  }

  export type UserCreateOrConnectWithoutQuestionResponsesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuestionResponsesInput, UserUncheckedCreateWithoutQuestionResponsesInput>
  }

  export type QuestionScoreCreateWithoutResponseInput = {
    id?: string
    isCorrect?: boolean
    marksObtained?: number
    maxMarks?: number
    accuracy?: number
    timeEfficiency?: number
    difficultyBonus?: number
    penalty?: number
    responseTime?: number
    attemptsCount?: number
    confidenceLevel?: number
    questionDifficulty: string
    scoredAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    question: QuestionCreateNestedOneWithoutScoresInput
    attempt: ExamAttemptCreateNestedOneWithoutQuestionScoresInput
    user: UserCreateNestedOneWithoutQuestionScoresInput
  }

  export type QuestionScoreUncheckedCreateWithoutResponseInput = {
    id?: string
    questionId: string
    attemptId: string
    userId: string
    isCorrect?: boolean
    marksObtained?: number
    maxMarks?: number
    accuracy?: number
    timeEfficiency?: number
    difficultyBonus?: number
    penalty?: number
    responseTime?: number
    attemptsCount?: number
    confidenceLevel?: number
    questionDifficulty: string
    scoredAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionScoreCreateOrConnectWithoutResponseInput = {
    where: QuestionScoreWhereUniqueInput
    create: XOR<QuestionScoreCreateWithoutResponseInput, QuestionScoreUncheckedCreateWithoutResponseInput>
  }

  export type ExamAttemptUpsertWithoutResponsesInput = {
    update: XOR<ExamAttemptUpdateWithoutResponsesInput, ExamAttemptUncheckedUpdateWithoutResponsesInput>
    create: XOR<ExamAttemptCreateWithoutResponsesInput, ExamAttemptUncheckedCreateWithoutResponsesInput>
    where?: ExamAttemptWhereInput
  }

  export type ExamAttemptUpdateToOneWithWhereWithoutResponsesInput = {
    where?: ExamAttemptWhereInput
    data: XOR<ExamAttemptUpdateWithoutResponsesInput, ExamAttemptUncheckedUpdateWithoutResponsesInput>
  }

  export type ExamAttemptUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttemptStatusFieldUpdateOperationsInput | $Enums.AttemptStatus
    totalMarks?: IntFieldUpdateOperationsInput | number
    obtainedMarks?: IntFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isCheating?: BoolFieldUpdateOperationsInput | boolean
    cheatingReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExamAttemptsNestedInput
    exam?: ExamUpdateOneRequiredWithoutAttemptsNestedInput
    booking?: ExamBookingUpdateOneWithoutAttemptsNestedInput
    questionScores?: QuestionScoreUpdateManyWithoutAttemptNestedInput
    examScore?: ExamScoreUpdateOneWithoutAttemptNestedInput
    certificate?: CertificateUpdateOneWithoutAttemptNestedInput
  }

  export type ExamAttemptUncheckedUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttemptStatusFieldUpdateOperationsInput | $Enums.AttemptStatus
    totalMarks?: IntFieldUpdateOperationsInput | number
    obtainedMarks?: IntFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isCheating?: BoolFieldUpdateOperationsInput | boolean
    cheatingReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionScores?: QuestionScoreUncheckedUpdateManyWithoutAttemptNestedInput
    examScore?: ExamScoreUncheckedUpdateOneWithoutAttemptNestedInput
    certificate?: CertificateUncheckedUpdateOneWithoutAttemptNestedInput
  }

  export type QuestionUpsertWithoutResponsesInput = {
    update: XOR<QuestionUpdateWithoutResponsesInput, QuestionUncheckedUpdateWithoutResponsesInput>
    create: XOR<QuestionCreateWithoutResponsesInput, QuestionUncheckedCreateWithoutResponsesInput>
    where?: QuestionWhereInput
  }

  export type QuestionUpdateToOneWithWhereWithoutResponsesInput = {
    where?: QuestionWhereInput
    data: XOR<QuestionUpdateWithoutResponsesInput, QuestionUncheckedUpdateWithoutResponsesInput>
  }

  export type QuestionUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    difficulty?: EnumQuestionDifficultyFieldUpdateOperationsInput | $Enums.QuestionDifficulty
    marks?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    correctAnswerRate?: NullableFloatFieldUpdateOperationsInput | number | null
    averageTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examCategory?: ExamCategoryUpdateOneRequiredWithoutQuestionsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedQuestionsNestedInput
    approver?: UserUpdateOneWithoutApprovedQuestionsNestedInput
    options?: QuestionOptionUpdateManyWithoutQuestionNestedInput
    images?: QuestionImageUpdateManyWithoutQuestionNestedInput
    tags?: QuestionTagUpdateManyWithoutQuestionNestedInput
    examQuestions?: ExamQuestionUpdateManyWithoutQuestionNestedInput
    scores?: QuestionScoreUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    difficulty?: EnumQuestionDifficultyFieldUpdateOperationsInput | $Enums.QuestionDifficulty
    examCategoryId?: StringFieldUpdateOperationsInput | string
    marks?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    correctAnswerRate?: NullableFloatFieldUpdateOperationsInput | number | null
    averageTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: QuestionOptionUncheckedUpdateManyWithoutQuestionNestedInput
    images?: QuestionImageUncheckedUpdateManyWithoutQuestionNestedInput
    tags?: QuestionTagUncheckedUpdateManyWithoutQuestionNestedInput
    examQuestions?: ExamQuestionUncheckedUpdateManyWithoutQuestionNestedInput
    scores?: QuestionScoreUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type UserUpsertWithoutQuestionResponsesInput = {
    update: XOR<UserUpdateWithoutQuestionResponsesInput, UserUncheckedUpdateWithoutQuestionResponsesInput>
    create: XOR<UserCreateWithoutQuestionResponsesInput, UserUncheckedCreateWithoutQuestionResponsesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutQuestionResponsesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutQuestionResponsesInput, UserUncheckedUpdateWithoutQuestionResponsesInput>
  }

  export type UserUpdateWithoutQuestionResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examBookings?: ExamBookingUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    examAttempts?: ExamAttemptUpdateManyWithoutUserNestedInput
    questionScores?: QuestionScoreUpdateManyWithoutUserNestedInput
    examScores?: ExamScoreUpdateManyWithoutUserNestedInput
    userPerformances?: UserPerformanceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    examCategories?: ExamCategoryUserUpdateManyWithoutUserNestedInput
    studyGroups?: StudyGroupMemberUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    grantedExamCategories?: ExamCategoryUserUpdateManyWithoutGranterNestedInput
    createdStudyGroups?: StudyGroupUpdateManyWithoutCreatorNestedInput
    createdQuestions?: QuestionUpdateManyWithoutCreatorNestedInput
    approvedQuestions?: QuestionUpdateManyWithoutApproverNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    approvedExams?: ExamUpdateManyWithoutApproverNestedInput
    revokedCertificates?: CertificateUpdateManyWithoutRevokerNestedInput
  }

  export type UserUncheckedUpdateWithoutQuestionResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examBookings?: ExamBookingUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    examAttempts?: ExamAttemptUncheckedUpdateManyWithoutUserNestedInput
    questionScores?: QuestionScoreUncheckedUpdateManyWithoutUserNestedInput
    examScores?: ExamScoreUncheckedUpdateManyWithoutUserNestedInput
    userPerformances?: UserPerformanceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    examCategories?: ExamCategoryUserUncheckedUpdateManyWithoutUserNestedInput
    studyGroups?: StudyGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    grantedExamCategories?: ExamCategoryUserUncheckedUpdateManyWithoutGranterNestedInput
    createdStudyGroups?: StudyGroupUncheckedUpdateManyWithoutCreatorNestedInput
    createdQuestions?: QuestionUncheckedUpdateManyWithoutCreatorNestedInput
    approvedQuestions?: QuestionUncheckedUpdateManyWithoutApproverNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    approvedExams?: ExamUncheckedUpdateManyWithoutApproverNestedInput
    revokedCertificates?: CertificateUncheckedUpdateManyWithoutRevokerNestedInput
  }

  export type QuestionScoreUpsertWithoutResponseInput = {
    update: XOR<QuestionScoreUpdateWithoutResponseInput, QuestionScoreUncheckedUpdateWithoutResponseInput>
    create: XOR<QuestionScoreCreateWithoutResponseInput, QuestionScoreUncheckedCreateWithoutResponseInput>
    where?: QuestionScoreWhereInput
  }

  export type QuestionScoreUpdateToOneWithWhereWithoutResponseInput = {
    where?: QuestionScoreWhereInput
    data: XOR<QuestionScoreUpdateWithoutResponseInput, QuestionScoreUncheckedUpdateWithoutResponseInput>
  }

  export type QuestionScoreUpdateWithoutResponseInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    marksObtained?: FloatFieldUpdateOperationsInput | number
    maxMarks?: FloatFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    timeEfficiency?: FloatFieldUpdateOperationsInput | number
    difficultyBonus?: FloatFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    attemptsCount?: IntFieldUpdateOperationsInput | number
    confidenceLevel?: FloatFieldUpdateOperationsInput | number
    questionDifficulty?: StringFieldUpdateOperationsInput | string
    scoredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: QuestionUpdateOneRequiredWithoutScoresNestedInput
    attempt?: ExamAttemptUpdateOneRequiredWithoutQuestionScoresNestedInput
    user?: UserUpdateOneRequiredWithoutQuestionScoresNestedInput
  }

  export type QuestionScoreUncheckedUpdateWithoutResponseInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    attemptId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    marksObtained?: FloatFieldUpdateOperationsInput | number
    maxMarks?: FloatFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    timeEfficiency?: FloatFieldUpdateOperationsInput | number
    difficultyBonus?: FloatFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    attemptsCount?: IntFieldUpdateOperationsInput | number
    confidenceLevel?: FloatFieldUpdateOperationsInput | number
    questionDifficulty?: StringFieldUpdateOperationsInput | string
    scoredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionResponseCreateWithoutScoreInput = {
    id?: string
    selectedOptions?: QuestionResponseCreateselectedOptionsInput | string[]
    isCorrect?: boolean | null
    marksObtained?: number
    timeSpent?: number | null
    answeredAt?: Date | string
    submittedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    attempt: ExamAttemptCreateNestedOneWithoutResponsesInput
    question: QuestionCreateNestedOneWithoutResponsesInput
    user: UserCreateNestedOneWithoutQuestionResponsesInput
  }

  export type QuestionResponseUncheckedCreateWithoutScoreInput = {
    id?: string
    attemptId: string
    questionId: string
    userId: string
    selectedOptions?: QuestionResponseCreateselectedOptionsInput | string[]
    isCorrect?: boolean | null
    marksObtained?: number
    timeSpent?: number | null
    answeredAt?: Date | string
    submittedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionResponseCreateOrConnectWithoutScoreInput = {
    where: QuestionResponseWhereUniqueInput
    create: XOR<QuestionResponseCreateWithoutScoreInput, QuestionResponseUncheckedCreateWithoutScoreInput>
  }

  export type QuestionCreateWithoutScoresInput = {
    id?: string
    text: string
    type: $Enums.QuestionType
    difficulty: $Enums.QuestionDifficulty
    marks?: number
    timeLimit?: number | null
    isActive?: boolean
    isPublic?: boolean
    approvedAt?: Date | string | null
    usageCount?: number
    correctAnswerRate?: number | null
    averageTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examCategory: ExamCategoryCreateNestedOneWithoutQuestionsInput
    creator: UserCreateNestedOneWithoutCreatedQuestionsInput
    approver?: UserCreateNestedOneWithoutApprovedQuestionsInput
    options?: QuestionOptionCreateNestedManyWithoutQuestionInput
    images?: QuestionImageCreateNestedManyWithoutQuestionInput
    tags?: QuestionTagCreateNestedManyWithoutQuestionInput
    examQuestions?: ExamQuestionCreateNestedManyWithoutQuestionInput
    responses?: QuestionResponseCreateNestedManyWithoutQuestionInput
  }

  export type QuestionUncheckedCreateWithoutScoresInput = {
    id?: string
    text: string
    type: $Enums.QuestionType
    difficulty: $Enums.QuestionDifficulty
    examCategoryId: string
    marks?: number
    timeLimit?: number | null
    isActive?: boolean
    isPublic?: boolean
    createdBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    usageCount?: number
    correctAnswerRate?: number | null
    averageTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: QuestionOptionUncheckedCreateNestedManyWithoutQuestionInput
    images?: QuestionImageUncheckedCreateNestedManyWithoutQuestionInput
    tags?: QuestionTagUncheckedCreateNestedManyWithoutQuestionInput
    examQuestions?: ExamQuestionUncheckedCreateNestedManyWithoutQuestionInput
    responses?: QuestionResponseUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionCreateOrConnectWithoutScoresInput = {
    where: QuestionWhereUniqueInput
    create: XOR<QuestionCreateWithoutScoresInput, QuestionUncheckedCreateWithoutScoresInput>
  }

  export type ExamAttemptCreateWithoutQuestionScoresInput = {
    id?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.AttemptStatus
    totalMarks?: number
    obtainedMarks?: number
    percentage?: number
    isPassed?: boolean
    timeSpent?: number | null
    ipAddress?: string | null
    userAgent?: string | null
    isCheating?: boolean
    cheatingReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutExamAttemptsInput
    exam: ExamCreateNestedOneWithoutAttemptsInput
    booking?: ExamBookingCreateNestedOneWithoutAttemptsInput
    responses?: QuestionResponseCreateNestedManyWithoutAttemptInput
    examScore?: ExamScoreCreateNestedOneWithoutAttemptInput
    certificate?: CertificateCreateNestedOneWithoutAttemptInput
  }

  export type ExamAttemptUncheckedCreateWithoutQuestionScoresInput = {
    id?: string
    userId: string
    examId: string
    bookingId?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.AttemptStatus
    totalMarks?: number
    obtainedMarks?: number
    percentage?: number
    isPassed?: boolean
    timeSpent?: number | null
    ipAddress?: string | null
    userAgent?: string | null
    isCheating?: boolean
    cheatingReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: QuestionResponseUncheckedCreateNestedManyWithoutAttemptInput
    examScore?: ExamScoreUncheckedCreateNestedOneWithoutAttemptInput
    certificate?: CertificateUncheckedCreateNestedOneWithoutAttemptInput
  }

  export type ExamAttemptCreateOrConnectWithoutQuestionScoresInput = {
    where: ExamAttemptWhereUniqueInput
    create: XOR<ExamAttemptCreateWithoutQuestionScoresInput, ExamAttemptUncheckedCreateWithoutQuestionScoresInput>
  }

  export type UserCreateWithoutQuestionScoresInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examBookings?: ExamBookingCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    examAttempts?: ExamAttemptCreateNestedManyWithoutUserInput
    questionResponses?: QuestionResponseCreateNestedManyWithoutUserInput
    examScores?: ExamScoreCreateNestedManyWithoutUserInput
    userPerformances?: UserPerformanceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    examCategories?: ExamCategoryUserCreateNestedManyWithoutUserInput
    studyGroups?: StudyGroupMemberCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    grantedExamCategories?: ExamCategoryUserCreateNestedManyWithoutGranterInput
    createdStudyGroups?: StudyGroupCreateNestedManyWithoutCreatorInput
    createdQuestions?: QuestionCreateNestedManyWithoutCreatorInput
    approvedQuestions?: QuestionCreateNestedManyWithoutApproverInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    approvedExams?: ExamCreateNestedManyWithoutApproverInput
    revokedCertificates?: CertificateCreateNestedManyWithoutRevokerInput
  }

  export type UserUncheckedCreateWithoutQuestionScoresInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examBookings?: ExamBookingUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    examAttempts?: ExamAttemptUncheckedCreateNestedManyWithoutUserInput
    questionResponses?: QuestionResponseUncheckedCreateNestedManyWithoutUserInput
    examScores?: ExamScoreUncheckedCreateNestedManyWithoutUserInput
    userPerformances?: UserPerformanceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    examCategories?: ExamCategoryUserUncheckedCreateNestedManyWithoutUserInput
    studyGroups?: StudyGroupMemberUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    grantedExamCategories?: ExamCategoryUserUncheckedCreateNestedManyWithoutGranterInput
    createdStudyGroups?: StudyGroupUncheckedCreateNestedManyWithoutCreatorInput
    createdQuestions?: QuestionUncheckedCreateNestedManyWithoutCreatorInput
    approvedQuestions?: QuestionUncheckedCreateNestedManyWithoutApproverInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    approvedExams?: ExamUncheckedCreateNestedManyWithoutApproverInput
    revokedCertificates?: CertificateUncheckedCreateNestedManyWithoutRevokerInput
  }

  export type UserCreateOrConnectWithoutQuestionScoresInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuestionScoresInput, UserUncheckedCreateWithoutQuestionScoresInput>
  }

  export type QuestionResponseUpsertWithoutScoreInput = {
    update: XOR<QuestionResponseUpdateWithoutScoreInput, QuestionResponseUncheckedUpdateWithoutScoreInput>
    create: XOR<QuestionResponseCreateWithoutScoreInput, QuestionResponseUncheckedCreateWithoutScoreInput>
    where?: QuestionResponseWhereInput
  }

  export type QuestionResponseUpdateToOneWithWhereWithoutScoreInput = {
    where?: QuestionResponseWhereInput
    data: XOR<QuestionResponseUpdateWithoutScoreInput, QuestionResponseUncheckedUpdateWithoutScoreInput>
  }

  export type QuestionResponseUpdateWithoutScoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    selectedOptions?: QuestionResponseUpdateselectedOptionsInput | string[]
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marksObtained?: IntFieldUpdateOperationsInput | number
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    answeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempt?: ExamAttemptUpdateOneRequiredWithoutResponsesNestedInput
    question?: QuestionUpdateOneRequiredWithoutResponsesNestedInput
    user?: UserUpdateOneRequiredWithoutQuestionResponsesNestedInput
  }

  export type QuestionResponseUncheckedUpdateWithoutScoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    attemptId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    selectedOptions?: QuestionResponseUpdateselectedOptionsInput | string[]
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marksObtained?: IntFieldUpdateOperationsInput | number
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    answeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionUpsertWithoutScoresInput = {
    update: XOR<QuestionUpdateWithoutScoresInput, QuestionUncheckedUpdateWithoutScoresInput>
    create: XOR<QuestionCreateWithoutScoresInput, QuestionUncheckedCreateWithoutScoresInput>
    where?: QuestionWhereInput
  }

  export type QuestionUpdateToOneWithWhereWithoutScoresInput = {
    where?: QuestionWhereInput
    data: XOR<QuestionUpdateWithoutScoresInput, QuestionUncheckedUpdateWithoutScoresInput>
  }

  export type QuestionUpdateWithoutScoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    difficulty?: EnumQuestionDifficultyFieldUpdateOperationsInput | $Enums.QuestionDifficulty
    marks?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    correctAnswerRate?: NullableFloatFieldUpdateOperationsInput | number | null
    averageTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examCategory?: ExamCategoryUpdateOneRequiredWithoutQuestionsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedQuestionsNestedInput
    approver?: UserUpdateOneWithoutApprovedQuestionsNestedInput
    options?: QuestionOptionUpdateManyWithoutQuestionNestedInput
    images?: QuestionImageUpdateManyWithoutQuestionNestedInput
    tags?: QuestionTagUpdateManyWithoutQuestionNestedInput
    examQuestions?: ExamQuestionUpdateManyWithoutQuestionNestedInput
    responses?: QuestionResponseUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateWithoutScoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    difficulty?: EnumQuestionDifficultyFieldUpdateOperationsInput | $Enums.QuestionDifficulty
    examCategoryId?: StringFieldUpdateOperationsInput | string
    marks?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    correctAnswerRate?: NullableFloatFieldUpdateOperationsInput | number | null
    averageTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: QuestionOptionUncheckedUpdateManyWithoutQuestionNestedInput
    images?: QuestionImageUncheckedUpdateManyWithoutQuestionNestedInput
    tags?: QuestionTagUncheckedUpdateManyWithoutQuestionNestedInput
    examQuestions?: ExamQuestionUncheckedUpdateManyWithoutQuestionNestedInput
    responses?: QuestionResponseUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type ExamAttemptUpsertWithoutQuestionScoresInput = {
    update: XOR<ExamAttemptUpdateWithoutQuestionScoresInput, ExamAttemptUncheckedUpdateWithoutQuestionScoresInput>
    create: XOR<ExamAttemptCreateWithoutQuestionScoresInput, ExamAttemptUncheckedCreateWithoutQuestionScoresInput>
    where?: ExamAttemptWhereInput
  }

  export type ExamAttemptUpdateToOneWithWhereWithoutQuestionScoresInput = {
    where?: ExamAttemptWhereInput
    data: XOR<ExamAttemptUpdateWithoutQuestionScoresInput, ExamAttemptUncheckedUpdateWithoutQuestionScoresInput>
  }

  export type ExamAttemptUpdateWithoutQuestionScoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttemptStatusFieldUpdateOperationsInput | $Enums.AttemptStatus
    totalMarks?: IntFieldUpdateOperationsInput | number
    obtainedMarks?: IntFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isCheating?: BoolFieldUpdateOperationsInput | boolean
    cheatingReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExamAttemptsNestedInput
    exam?: ExamUpdateOneRequiredWithoutAttemptsNestedInput
    booking?: ExamBookingUpdateOneWithoutAttemptsNestedInput
    responses?: QuestionResponseUpdateManyWithoutAttemptNestedInput
    examScore?: ExamScoreUpdateOneWithoutAttemptNestedInput
    certificate?: CertificateUpdateOneWithoutAttemptNestedInput
  }

  export type ExamAttemptUncheckedUpdateWithoutQuestionScoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttemptStatusFieldUpdateOperationsInput | $Enums.AttemptStatus
    totalMarks?: IntFieldUpdateOperationsInput | number
    obtainedMarks?: IntFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isCheating?: BoolFieldUpdateOperationsInput | boolean
    cheatingReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: QuestionResponseUncheckedUpdateManyWithoutAttemptNestedInput
    examScore?: ExamScoreUncheckedUpdateOneWithoutAttemptNestedInput
    certificate?: CertificateUncheckedUpdateOneWithoutAttemptNestedInput
  }

  export type UserUpsertWithoutQuestionScoresInput = {
    update: XOR<UserUpdateWithoutQuestionScoresInput, UserUncheckedUpdateWithoutQuestionScoresInput>
    create: XOR<UserCreateWithoutQuestionScoresInput, UserUncheckedCreateWithoutQuestionScoresInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutQuestionScoresInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutQuestionScoresInput, UserUncheckedUpdateWithoutQuestionScoresInput>
  }

  export type UserUpdateWithoutQuestionScoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examBookings?: ExamBookingUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    examAttempts?: ExamAttemptUpdateManyWithoutUserNestedInput
    questionResponses?: QuestionResponseUpdateManyWithoutUserNestedInput
    examScores?: ExamScoreUpdateManyWithoutUserNestedInput
    userPerformances?: UserPerformanceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    examCategories?: ExamCategoryUserUpdateManyWithoutUserNestedInput
    studyGroups?: StudyGroupMemberUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    grantedExamCategories?: ExamCategoryUserUpdateManyWithoutGranterNestedInput
    createdStudyGroups?: StudyGroupUpdateManyWithoutCreatorNestedInput
    createdQuestions?: QuestionUpdateManyWithoutCreatorNestedInput
    approvedQuestions?: QuestionUpdateManyWithoutApproverNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    approvedExams?: ExamUpdateManyWithoutApproverNestedInput
    revokedCertificates?: CertificateUpdateManyWithoutRevokerNestedInput
  }

  export type UserUncheckedUpdateWithoutQuestionScoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examBookings?: ExamBookingUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    examAttempts?: ExamAttemptUncheckedUpdateManyWithoutUserNestedInput
    questionResponses?: QuestionResponseUncheckedUpdateManyWithoutUserNestedInput
    examScores?: ExamScoreUncheckedUpdateManyWithoutUserNestedInput
    userPerformances?: UserPerformanceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    examCategories?: ExamCategoryUserUncheckedUpdateManyWithoutUserNestedInput
    studyGroups?: StudyGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    grantedExamCategories?: ExamCategoryUserUncheckedUpdateManyWithoutGranterNestedInput
    createdStudyGroups?: StudyGroupUncheckedUpdateManyWithoutCreatorNestedInput
    createdQuestions?: QuestionUncheckedUpdateManyWithoutCreatorNestedInput
    approvedQuestions?: QuestionUncheckedUpdateManyWithoutApproverNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    approvedExams?: ExamUncheckedUpdateManyWithoutApproverNestedInput
    revokedCertificates?: CertificateUncheckedUpdateManyWithoutRevokerNestedInput
  }

  export type ExamAttemptCreateWithoutExamScoreInput = {
    id?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.AttemptStatus
    totalMarks?: number
    obtainedMarks?: number
    percentage?: number
    isPassed?: boolean
    timeSpent?: number | null
    ipAddress?: string | null
    userAgent?: string | null
    isCheating?: boolean
    cheatingReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutExamAttemptsInput
    exam: ExamCreateNestedOneWithoutAttemptsInput
    booking?: ExamBookingCreateNestedOneWithoutAttemptsInput
    responses?: QuestionResponseCreateNestedManyWithoutAttemptInput
    questionScores?: QuestionScoreCreateNestedManyWithoutAttemptInput
    certificate?: CertificateCreateNestedOneWithoutAttemptInput
  }

  export type ExamAttemptUncheckedCreateWithoutExamScoreInput = {
    id?: string
    userId: string
    examId: string
    bookingId?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.AttemptStatus
    totalMarks?: number
    obtainedMarks?: number
    percentage?: number
    isPassed?: boolean
    timeSpent?: number | null
    ipAddress?: string | null
    userAgent?: string | null
    isCheating?: boolean
    cheatingReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: QuestionResponseUncheckedCreateNestedManyWithoutAttemptInput
    questionScores?: QuestionScoreUncheckedCreateNestedManyWithoutAttemptInput
    certificate?: CertificateUncheckedCreateNestedOneWithoutAttemptInput
  }

  export type ExamAttemptCreateOrConnectWithoutExamScoreInput = {
    where: ExamAttemptWhereUniqueInput
    create: XOR<ExamAttemptCreateWithoutExamScoreInput, ExamAttemptUncheckedCreateWithoutExamScoreInput>
  }

  export type ExamCreateWithoutExamScoresInput = {
    id?: string
    title: string
    description?: string | null
    duration: number
    totalMarks: number
    passingMarks: number
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    isActive?: boolean
    isPublic?: boolean
    allowRetakes?: boolean
    maxRetakes?: number
    showResults?: boolean
    showAnswers?: boolean
    randomizeQuestions?: boolean
    randomizeOptions?: boolean
    questionOverlapPercentage?: number
    approvedAt?: Date | string | null
    scheduledStart?: Date | string | null
    scheduledEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examCategory: ExamCategoryCreateNestedOneWithoutExamsInput
    creator: UserCreateNestedOneWithoutCreatedExamsInput
    approver?: UserCreateNestedOneWithoutApprovedExamsInput
    questions?: ExamQuestionCreateNestedManyWithoutExamInput
    bookings?: ExamBookingCreateNestedManyWithoutExamInput
    attempts?: ExamAttemptCreateNestedManyWithoutExamInput
    certificates?: CertificateCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutExamScoresInput = {
    id?: string
    title: string
    description?: string | null
    examCategoryId: string
    duration: number
    totalMarks: number
    passingMarks: number
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    isActive?: boolean
    isPublic?: boolean
    allowRetakes?: boolean
    maxRetakes?: number
    showResults?: boolean
    showAnswers?: boolean
    randomizeQuestions?: boolean
    randomizeOptions?: boolean
    questionOverlapPercentage?: number
    createdBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    scheduledStart?: Date | string | null
    scheduledEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: ExamQuestionUncheckedCreateNestedManyWithoutExamInput
    bookings?: ExamBookingUncheckedCreateNestedManyWithoutExamInput
    attempts?: ExamAttemptUncheckedCreateNestedManyWithoutExamInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutExamScoresInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutExamScoresInput, ExamUncheckedCreateWithoutExamScoresInput>
  }

  export type UserCreateWithoutExamScoresInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examBookings?: ExamBookingCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    examAttempts?: ExamAttemptCreateNestedManyWithoutUserInput
    questionResponses?: QuestionResponseCreateNestedManyWithoutUserInput
    questionScores?: QuestionScoreCreateNestedManyWithoutUserInput
    userPerformances?: UserPerformanceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    examCategories?: ExamCategoryUserCreateNestedManyWithoutUserInput
    studyGroups?: StudyGroupMemberCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    grantedExamCategories?: ExamCategoryUserCreateNestedManyWithoutGranterInput
    createdStudyGroups?: StudyGroupCreateNestedManyWithoutCreatorInput
    createdQuestions?: QuestionCreateNestedManyWithoutCreatorInput
    approvedQuestions?: QuestionCreateNestedManyWithoutApproverInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    approvedExams?: ExamCreateNestedManyWithoutApproverInput
    revokedCertificates?: CertificateCreateNestedManyWithoutRevokerInput
  }

  export type UserUncheckedCreateWithoutExamScoresInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examBookings?: ExamBookingUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    examAttempts?: ExamAttemptUncheckedCreateNestedManyWithoutUserInput
    questionResponses?: QuestionResponseUncheckedCreateNestedManyWithoutUserInput
    questionScores?: QuestionScoreUncheckedCreateNestedManyWithoutUserInput
    userPerformances?: UserPerformanceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    examCategories?: ExamCategoryUserUncheckedCreateNestedManyWithoutUserInput
    studyGroups?: StudyGroupMemberUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    grantedExamCategories?: ExamCategoryUserUncheckedCreateNestedManyWithoutGranterInput
    createdStudyGroups?: StudyGroupUncheckedCreateNestedManyWithoutCreatorInput
    createdQuestions?: QuestionUncheckedCreateNestedManyWithoutCreatorInput
    approvedQuestions?: QuestionUncheckedCreateNestedManyWithoutApproverInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    approvedExams?: ExamUncheckedCreateNestedManyWithoutApproverInput
    revokedCertificates?: CertificateUncheckedCreateNestedManyWithoutRevokerInput
  }

  export type UserCreateOrConnectWithoutExamScoresInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExamScoresInput, UserUncheckedCreateWithoutExamScoresInput>
  }

  export type ExamAttemptUpsertWithoutExamScoreInput = {
    update: XOR<ExamAttemptUpdateWithoutExamScoreInput, ExamAttemptUncheckedUpdateWithoutExamScoreInput>
    create: XOR<ExamAttemptCreateWithoutExamScoreInput, ExamAttemptUncheckedCreateWithoutExamScoreInput>
    where?: ExamAttemptWhereInput
  }

  export type ExamAttemptUpdateToOneWithWhereWithoutExamScoreInput = {
    where?: ExamAttemptWhereInput
    data: XOR<ExamAttemptUpdateWithoutExamScoreInput, ExamAttemptUncheckedUpdateWithoutExamScoreInput>
  }

  export type ExamAttemptUpdateWithoutExamScoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttemptStatusFieldUpdateOperationsInput | $Enums.AttemptStatus
    totalMarks?: IntFieldUpdateOperationsInput | number
    obtainedMarks?: IntFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isCheating?: BoolFieldUpdateOperationsInput | boolean
    cheatingReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExamAttemptsNestedInput
    exam?: ExamUpdateOneRequiredWithoutAttemptsNestedInput
    booking?: ExamBookingUpdateOneWithoutAttemptsNestedInput
    responses?: QuestionResponseUpdateManyWithoutAttemptNestedInput
    questionScores?: QuestionScoreUpdateManyWithoutAttemptNestedInput
    certificate?: CertificateUpdateOneWithoutAttemptNestedInput
  }

  export type ExamAttemptUncheckedUpdateWithoutExamScoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttemptStatusFieldUpdateOperationsInput | $Enums.AttemptStatus
    totalMarks?: IntFieldUpdateOperationsInput | number
    obtainedMarks?: IntFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isCheating?: BoolFieldUpdateOperationsInput | boolean
    cheatingReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: QuestionResponseUncheckedUpdateManyWithoutAttemptNestedInput
    questionScores?: QuestionScoreUncheckedUpdateManyWithoutAttemptNestedInput
    certificate?: CertificateUncheckedUpdateOneWithoutAttemptNestedInput
  }

  export type ExamUpsertWithoutExamScoresInput = {
    update: XOR<ExamUpdateWithoutExamScoresInput, ExamUncheckedUpdateWithoutExamScoresInput>
    create: XOR<ExamCreateWithoutExamScoresInput, ExamUncheckedCreateWithoutExamScoresInput>
    where?: ExamWhereInput
  }

  export type ExamUpdateToOneWithWhereWithoutExamScoresInput = {
    where?: ExamWhereInput
    data: XOR<ExamUpdateWithoutExamScoresInput, ExamUncheckedUpdateWithoutExamScoresInput>
  }

  export type ExamUpdateWithoutExamScoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    totalMarks?: IntFieldUpdateOperationsInput | number
    passingMarks?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowRetakes?: BoolFieldUpdateOperationsInput | boolean
    maxRetakes?: IntFieldUpdateOperationsInput | number
    showResults?: BoolFieldUpdateOperationsInput | boolean
    showAnswers?: BoolFieldUpdateOperationsInput | boolean
    randomizeQuestions?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: BoolFieldUpdateOperationsInput | boolean
    questionOverlapPercentage?: FloatFieldUpdateOperationsInput | number
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examCategory?: ExamCategoryUpdateOneRequiredWithoutExamsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedExamsNestedInput
    approver?: UserUpdateOneWithoutApprovedExamsNestedInput
    questions?: ExamQuestionUpdateManyWithoutExamNestedInput
    bookings?: ExamBookingUpdateManyWithoutExamNestedInput
    attempts?: ExamAttemptUpdateManyWithoutExamNestedInput
    certificates?: CertificateUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutExamScoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    examCategoryId?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    totalMarks?: IntFieldUpdateOperationsInput | number
    passingMarks?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowRetakes?: BoolFieldUpdateOperationsInput | boolean
    maxRetakes?: IntFieldUpdateOperationsInput | number
    showResults?: BoolFieldUpdateOperationsInput | boolean
    showAnswers?: BoolFieldUpdateOperationsInput | boolean
    randomizeQuestions?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: BoolFieldUpdateOperationsInput | boolean
    questionOverlapPercentage?: FloatFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: ExamQuestionUncheckedUpdateManyWithoutExamNestedInput
    bookings?: ExamBookingUncheckedUpdateManyWithoutExamNestedInput
    attempts?: ExamAttemptUncheckedUpdateManyWithoutExamNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutExamNestedInput
  }

  export type UserUpsertWithoutExamScoresInput = {
    update: XOR<UserUpdateWithoutExamScoresInput, UserUncheckedUpdateWithoutExamScoresInput>
    create: XOR<UserCreateWithoutExamScoresInput, UserUncheckedCreateWithoutExamScoresInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExamScoresInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExamScoresInput, UserUncheckedUpdateWithoutExamScoresInput>
  }

  export type UserUpdateWithoutExamScoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examBookings?: ExamBookingUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    examAttempts?: ExamAttemptUpdateManyWithoutUserNestedInput
    questionResponses?: QuestionResponseUpdateManyWithoutUserNestedInput
    questionScores?: QuestionScoreUpdateManyWithoutUserNestedInput
    userPerformances?: UserPerformanceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    examCategories?: ExamCategoryUserUpdateManyWithoutUserNestedInput
    studyGroups?: StudyGroupMemberUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    grantedExamCategories?: ExamCategoryUserUpdateManyWithoutGranterNestedInput
    createdStudyGroups?: StudyGroupUpdateManyWithoutCreatorNestedInput
    createdQuestions?: QuestionUpdateManyWithoutCreatorNestedInput
    approvedQuestions?: QuestionUpdateManyWithoutApproverNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    approvedExams?: ExamUpdateManyWithoutApproverNestedInput
    revokedCertificates?: CertificateUpdateManyWithoutRevokerNestedInput
  }

  export type UserUncheckedUpdateWithoutExamScoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examBookings?: ExamBookingUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    examAttempts?: ExamAttemptUncheckedUpdateManyWithoutUserNestedInput
    questionResponses?: QuestionResponseUncheckedUpdateManyWithoutUserNestedInput
    questionScores?: QuestionScoreUncheckedUpdateManyWithoutUserNestedInput
    userPerformances?: UserPerformanceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    examCategories?: ExamCategoryUserUncheckedUpdateManyWithoutUserNestedInput
    studyGroups?: StudyGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    grantedExamCategories?: ExamCategoryUserUncheckedUpdateManyWithoutGranterNestedInput
    createdStudyGroups?: StudyGroupUncheckedUpdateManyWithoutCreatorNestedInput
    createdQuestions?: QuestionUncheckedUpdateManyWithoutCreatorNestedInput
    approvedQuestions?: QuestionUncheckedUpdateManyWithoutApproverNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    approvedExams?: ExamUncheckedUpdateManyWithoutApproverNestedInput
    revokedCertificates?: CertificateUncheckedUpdateManyWithoutRevokerNestedInput
  }

  export type UserCreateWithoutUserPerformancesInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examBookings?: ExamBookingCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    examAttempts?: ExamAttemptCreateNestedManyWithoutUserInput
    questionResponses?: QuestionResponseCreateNestedManyWithoutUserInput
    questionScores?: QuestionScoreCreateNestedManyWithoutUserInput
    examScores?: ExamScoreCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    examCategories?: ExamCategoryUserCreateNestedManyWithoutUserInput
    studyGroups?: StudyGroupMemberCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    grantedExamCategories?: ExamCategoryUserCreateNestedManyWithoutGranterInput
    createdStudyGroups?: StudyGroupCreateNestedManyWithoutCreatorInput
    createdQuestions?: QuestionCreateNestedManyWithoutCreatorInput
    approvedQuestions?: QuestionCreateNestedManyWithoutApproverInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    approvedExams?: ExamCreateNestedManyWithoutApproverInput
    revokedCertificates?: CertificateCreateNestedManyWithoutRevokerInput
  }

  export type UserUncheckedCreateWithoutUserPerformancesInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examBookings?: ExamBookingUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    examAttempts?: ExamAttemptUncheckedCreateNestedManyWithoutUserInput
    questionResponses?: QuestionResponseUncheckedCreateNestedManyWithoutUserInput
    questionScores?: QuestionScoreUncheckedCreateNestedManyWithoutUserInput
    examScores?: ExamScoreUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    examCategories?: ExamCategoryUserUncheckedCreateNestedManyWithoutUserInput
    studyGroups?: StudyGroupMemberUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    grantedExamCategories?: ExamCategoryUserUncheckedCreateNestedManyWithoutGranterInput
    createdStudyGroups?: StudyGroupUncheckedCreateNestedManyWithoutCreatorInput
    createdQuestions?: QuestionUncheckedCreateNestedManyWithoutCreatorInput
    approvedQuestions?: QuestionUncheckedCreateNestedManyWithoutApproverInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    approvedExams?: ExamUncheckedCreateNestedManyWithoutApproverInput
    revokedCertificates?: CertificateUncheckedCreateNestedManyWithoutRevokerInput
  }

  export type UserCreateOrConnectWithoutUserPerformancesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserPerformancesInput, UserUncheckedCreateWithoutUserPerformancesInput>
  }

  export type ExamCategoryCreateWithoutUserPerformancesInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    exams?: ExamCreateNestedManyWithoutExamCategoryInput
    questions?: QuestionCreateNestedManyWithoutExamCategoryInput
    users?: ExamCategoryUserCreateNestedManyWithoutExamCategoryInput
  }

  export type ExamCategoryUncheckedCreateWithoutUserPerformancesInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    exams?: ExamUncheckedCreateNestedManyWithoutExamCategoryInput
    questions?: QuestionUncheckedCreateNestedManyWithoutExamCategoryInput
    users?: ExamCategoryUserUncheckedCreateNestedManyWithoutExamCategoryInput
  }

  export type ExamCategoryCreateOrConnectWithoutUserPerformancesInput = {
    where: ExamCategoryWhereUniqueInput
    create: XOR<ExamCategoryCreateWithoutUserPerformancesInput, ExamCategoryUncheckedCreateWithoutUserPerformancesInput>
  }

  export type UserUpsertWithoutUserPerformancesInput = {
    update: XOR<UserUpdateWithoutUserPerformancesInput, UserUncheckedUpdateWithoutUserPerformancesInput>
    create: XOR<UserCreateWithoutUserPerformancesInput, UserUncheckedCreateWithoutUserPerformancesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserPerformancesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserPerformancesInput, UserUncheckedUpdateWithoutUserPerformancesInput>
  }

  export type UserUpdateWithoutUserPerformancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examBookings?: ExamBookingUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    examAttempts?: ExamAttemptUpdateManyWithoutUserNestedInput
    questionResponses?: QuestionResponseUpdateManyWithoutUserNestedInput
    questionScores?: QuestionScoreUpdateManyWithoutUserNestedInput
    examScores?: ExamScoreUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    examCategories?: ExamCategoryUserUpdateManyWithoutUserNestedInput
    studyGroups?: StudyGroupMemberUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    grantedExamCategories?: ExamCategoryUserUpdateManyWithoutGranterNestedInput
    createdStudyGroups?: StudyGroupUpdateManyWithoutCreatorNestedInput
    createdQuestions?: QuestionUpdateManyWithoutCreatorNestedInput
    approvedQuestions?: QuestionUpdateManyWithoutApproverNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    approvedExams?: ExamUpdateManyWithoutApproverNestedInput
    revokedCertificates?: CertificateUpdateManyWithoutRevokerNestedInput
  }

  export type UserUncheckedUpdateWithoutUserPerformancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examBookings?: ExamBookingUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    examAttempts?: ExamAttemptUncheckedUpdateManyWithoutUserNestedInput
    questionResponses?: QuestionResponseUncheckedUpdateManyWithoutUserNestedInput
    questionScores?: QuestionScoreUncheckedUpdateManyWithoutUserNestedInput
    examScores?: ExamScoreUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    examCategories?: ExamCategoryUserUncheckedUpdateManyWithoutUserNestedInput
    studyGroups?: StudyGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    grantedExamCategories?: ExamCategoryUserUncheckedUpdateManyWithoutGranterNestedInput
    createdStudyGroups?: StudyGroupUncheckedUpdateManyWithoutCreatorNestedInput
    createdQuestions?: QuestionUncheckedUpdateManyWithoutCreatorNestedInput
    approvedQuestions?: QuestionUncheckedUpdateManyWithoutApproverNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    approvedExams?: ExamUncheckedUpdateManyWithoutApproverNestedInput
    revokedCertificates?: CertificateUncheckedUpdateManyWithoutRevokerNestedInput
  }

  export type ExamCategoryUpsertWithoutUserPerformancesInput = {
    update: XOR<ExamCategoryUpdateWithoutUserPerformancesInput, ExamCategoryUncheckedUpdateWithoutUserPerformancesInput>
    create: XOR<ExamCategoryCreateWithoutUserPerformancesInput, ExamCategoryUncheckedCreateWithoutUserPerformancesInput>
    where?: ExamCategoryWhereInput
  }

  export type ExamCategoryUpdateToOneWithWhereWithoutUserPerformancesInput = {
    where?: ExamCategoryWhereInput
    data: XOR<ExamCategoryUpdateWithoutUserPerformancesInput, ExamCategoryUncheckedUpdateWithoutUserPerformancesInput>
  }

  export type ExamCategoryUpdateWithoutUserPerformancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exams?: ExamUpdateManyWithoutExamCategoryNestedInput
    questions?: QuestionUpdateManyWithoutExamCategoryNestedInput
    users?: ExamCategoryUserUpdateManyWithoutExamCategoryNestedInput
  }

  export type ExamCategoryUncheckedUpdateWithoutUserPerformancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exams?: ExamUncheckedUpdateManyWithoutExamCategoryNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutExamCategoryNestedInput
    users?: ExamCategoryUserUncheckedUpdateManyWithoutExamCategoryNestedInput
  }

  export type UserCreateWithoutPaymentsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examBookings?: ExamBookingCreateNestedManyWithoutUserInput
    examAttempts?: ExamAttemptCreateNestedManyWithoutUserInput
    questionResponses?: QuestionResponseCreateNestedManyWithoutUserInput
    questionScores?: QuestionScoreCreateNestedManyWithoutUserInput
    examScores?: ExamScoreCreateNestedManyWithoutUserInput
    userPerformances?: UserPerformanceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    examCategories?: ExamCategoryUserCreateNestedManyWithoutUserInput
    studyGroups?: StudyGroupMemberCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    grantedExamCategories?: ExamCategoryUserCreateNestedManyWithoutGranterInput
    createdStudyGroups?: StudyGroupCreateNestedManyWithoutCreatorInput
    createdQuestions?: QuestionCreateNestedManyWithoutCreatorInput
    approvedQuestions?: QuestionCreateNestedManyWithoutApproverInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    approvedExams?: ExamCreateNestedManyWithoutApproverInput
    revokedCertificates?: CertificateCreateNestedManyWithoutRevokerInput
  }

  export type UserUncheckedCreateWithoutPaymentsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examBookings?: ExamBookingUncheckedCreateNestedManyWithoutUserInput
    examAttempts?: ExamAttemptUncheckedCreateNestedManyWithoutUserInput
    questionResponses?: QuestionResponseUncheckedCreateNestedManyWithoutUserInput
    questionScores?: QuestionScoreUncheckedCreateNestedManyWithoutUserInput
    examScores?: ExamScoreUncheckedCreateNestedManyWithoutUserInput
    userPerformances?: UserPerformanceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    examCategories?: ExamCategoryUserUncheckedCreateNestedManyWithoutUserInput
    studyGroups?: StudyGroupMemberUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    grantedExamCategories?: ExamCategoryUserUncheckedCreateNestedManyWithoutGranterInput
    createdStudyGroups?: StudyGroupUncheckedCreateNestedManyWithoutCreatorInput
    createdQuestions?: QuestionUncheckedCreateNestedManyWithoutCreatorInput
    approvedQuestions?: QuestionUncheckedCreateNestedManyWithoutApproverInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    approvedExams?: ExamUncheckedCreateNestedManyWithoutApproverInput
    revokedCertificates?: CertificateUncheckedCreateNestedManyWithoutRevokerInput
  }

  export type UserCreateOrConnectWithoutPaymentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
  }

  export type ExamBookingCreateWithoutPaymentInput = {
    id?: string
    bookingDate?: Date | string
    scheduledAt?: Date | string | null
    status?: $Enums.BookingStatus
    paymentId?: string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutExamBookingsInput
    exam: ExamCreateNestedOneWithoutBookingsInput
    attempts?: ExamAttemptCreateNestedManyWithoutBookingInput
  }

  export type ExamBookingUncheckedCreateWithoutPaymentInput = {
    id?: string
    userId: string
    examId: string
    bookingDate?: Date | string
    scheduledAt?: Date | string | null
    status?: $Enums.BookingStatus
    paymentId?: string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attempts?: ExamAttemptUncheckedCreateNestedManyWithoutBookingInput
  }

  export type ExamBookingCreateOrConnectWithoutPaymentInput = {
    where: ExamBookingWhereUniqueInput
    create: XOR<ExamBookingCreateWithoutPaymentInput, ExamBookingUncheckedCreateWithoutPaymentInput>
  }

  export type UserUpsertWithoutPaymentsInput = {
    update: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
    create: XOR<UserCreateWithoutPaymentsInput, UserUncheckedCreateWithoutPaymentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentsInput, UserUncheckedUpdateWithoutPaymentsInput>
  }

  export type UserUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examBookings?: ExamBookingUpdateManyWithoutUserNestedInput
    examAttempts?: ExamAttemptUpdateManyWithoutUserNestedInput
    questionResponses?: QuestionResponseUpdateManyWithoutUserNestedInput
    questionScores?: QuestionScoreUpdateManyWithoutUserNestedInput
    examScores?: ExamScoreUpdateManyWithoutUserNestedInput
    userPerformances?: UserPerformanceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    examCategories?: ExamCategoryUserUpdateManyWithoutUserNestedInput
    studyGroups?: StudyGroupMemberUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    grantedExamCategories?: ExamCategoryUserUpdateManyWithoutGranterNestedInput
    createdStudyGroups?: StudyGroupUpdateManyWithoutCreatorNestedInput
    createdQuestions?: QuestionUpdateManyWithoutCreatorNestedInput
    approvedQuestions?: QuestionUpdateManyWithoutApproverNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    approvedExams?: ExamUpdateManyWithoutApproverNestedInput
    revokedCertificates?: CertificateUpdateManyWithoutRevokerNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examBookings?: ExamBookingUncheckedUpdateManyWithoutUserNestedInput
    examAttempts?: ExamAttemptUncheckedUpdateManyWithoutUserNestedInput
    questionResponses?: QuestionResponseUncheckedUpdateManyWithoutUserNestedInput
    questionScores?: QuestionScoreUncheckedUpdateManyWithoutUserNestedInput
    examScores?: ExamScoreUncheckedUpdateManyWithoutUserNestedInput
    userPerformances?: UserPerformanceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    examCategories?: ExamCategoryUserUncheckedUpdateManyWithoutUserNestedInput
    studyGroups?: StudyGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    grantedExamCategories?: ExamCategoryUserUncheckedUpdateManyWithoutGranterNestedInput
    createdStudyGroups?: StudyGroupUncheckedUpdateManyWithoutCreatorNestedInput
    createdQuestions?: QuestionUncheckedUpdateManyWithoutCreatorNestedInput
    approvedQuestions?: QuestionUncheckedUpdateManyWithoutApproverNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    approvedExams?: ExamUncheckedUpdateManyWithoutApproverNestedInput
    revokedCertificates?: CertificateUncheckedUpdateManyWithoutRevokerNestedInput
  }

  export type ExamBookingUpsertWithoutPaymentInput = {
    update: XOR<ExamBookingUpdateWithoutPaymentInput, ExamBookingUncheckedUpdateWithoutPaymentInput>
    create: XOR<ExamBookingCreateWithoutPaymentInput, ExamBookingUncheckedCreateWithoutPaymentInput>
    where?: ExamBookingWhereInput
  }

  export type ExamBookingUpdateToOneWithWhereWithoutPaymentInput = {
    where?: ExamBookingWhereInput
    data: XOR<ExamBookingUpdateWithoutPaymentInput, ExamBookingUncheckedUpdateWithoutPaymentInput>
  }

  export type ExamBookingUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExamBookingsNestedInput
    exam?: ExamUpdateOneRequiredWithoutBookingsNestedInput
    attempts?: ExamAttemptUpdateManyWithoutBookingNestedInput
  }

  export type ExamBookingUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempts?: ExamAttemptUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type UserCreateWithoutCertificatesInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examBookings?: ExamBookingCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    examAttempts?: ExamAttemptCreateNestedManyWithoutUserInput
    questionResponses?: QuestionResponseCreateNestedManyWithoutUserInput
    questionScores?: QuestionScoreCreateNestedManyWithoutUserInput
    examScores?: ExamScoreCreateNestedManyWithoutUserInput
    userPerformances?: UserPerformanceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    examCategories?: ExamCategoryUserCreateNestedManyWithoutUserInput
    studyGroups?: StudyGroupMemberCreateNestedManyWithoutUserInput
    grantedExamCategories?: ExamCategoryUserCreateNestedManyWithoutGranterInput
    createdStudyGroups?: StudyGroupCreateNestedManyWithoutCreatorInput
    createdQuestions?: QuestionCreateNestedManyWithoutCreatorInput
    approvedQuestions?: QuestionCreateNestedManyWithoutApproverInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    approvedExams?: ExamCreateNestedManyWithoutApproverInput
    revokedCertificates?: CertificateCreateNestedManyWithoutRevokerInput
  }

  export type UserUncheckedCreateWithoutCertificatesInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examBookings?: ExamBookingUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    examAttempts?: ExamAttemptUncheckedCreateNestedManyWithoutUserInput
    questionResponses?: QuestionResponseUncheckedCreateNestedManyWithoutUserInput
    questionScores?: QuestionScoreUncheckedCreateNestedManyWithoutUserInput
    examScores?: ExamScoreUncheckedCreateNestedManyWithoutUserInput
    userPerformances?: UserPerformanceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    examCategories?: ExamCategoryUserUncheckedCreateNestedManyWithoutUserInput
    studyGroups?: StudyGroupMemberUncheckedCreateNestedManyWithoutUserInput
    grantedExamCategories?: ExamCategoryUserUncheckedCreateNestedManyWithoutGranterInput
    createdStudyGroups?: StudyGroupUncheckedCreateNestedManyWithoutCreatorInput
    createdQuestions?: QuestionUncheckedCreateNestedManyWithoutCreatorInput
    approvedQuestions?: QuestionUncheckedCreateNestedManyWithoutApproverInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    approvedExams?: ExamUncheckedCreateNestedManyWithoutApproverInput
    revokedCertificates?: CertificateUncheckedCreateNestedManyWithoutRevokerInput
  }

  export type UserCreateOrConnectWithoutCertificatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCertificatesInput, UserUncheckedCreateWithoutCertificatesInput>
  }

  export type ExamCreateWithoutCertificatesInput = {
    id?: string
    title: string
    description?: string | null
    duration: number
    totalMarks: number
    passingMarks: number
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    isActive?: boolean
    isPublic?: boolean
    allowRetakes?: boolean
    maxRetakes?: number
    showResults?: boolean
    showAnswers?: boolean
    randomizeQuestions?: boolean
    randomizeOptions?: boolean
    questionOverlapPercentage?: number
    approvedAt?: Date | string | null
    scheduledStart?: Date | string | null
    scheduledEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examCategory: ExamCategoryCreateNestedOneWithoutExamsInput
    creator: UserCreateNestedOneWithoutCreatedExamsInput
    approver?: UserCreateNestedOneWithoutApprovedExamsInput
    questions?: ExamQuestionCreateNestedManyWithoutExamInput
    bookings?: ExamBookingCreateNestedManyWithoutExamInput
    attempts?: ExamAttemptCreateNestedManyWithoutExamInput
    examScores?: ExamScoreCreateNestedManyWithoutExamInput
  }

  export type ExamUncheckedCreateWithoutCertificatesInput = {
    id?: string
    title: string
    description?: string | null
    examCategoryId: string
    duration: number
    totalMarks: number
    passingMarks: number
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    isActive?: boolean
    isPublic?: boolean
    allowRetakes?: boolean
    maxRetakes?: number
    showResults?: boolean
    showAnswers?: boolean
    randomizeQuestions?: boolean
    randomizeOptions?: boolean
    questionOverlapPercentage?: number
    createdBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    scheduledStart?: Date | string | null
    scheduledEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: ExamQuestionUncheckedCreateNestedManyWithoutExamInput
    bookings?: ExamBookingUncheckedCreateNestedManyWithoutExamInput
    attempts?: ExamAttemptUncheckedCreateNestedManyWithoutExamInput
    examScores?: ExamScoreUncheckedCreateNestedManyWithoutExamInput
  }

  export type ExamCreateOrConnectWithoutCertificatesInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutCertificatesInput, ExamUncheckedCreateWithoutCertificatesInput>
  }

  export type ExamAttemptCreateWithoutCertificateInput = {
    id?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.AttemptStatus
    totalMarks?: number
    obtainedMarks?: number
    percentage?: number
    isPassed?: boolean
    timeSpent?: number | null
    ipAddress?: string | null
    userAgent?: string | null
    isCheating?: boolean
    cheatingReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutExamAttemptsInput
    exam: ExamCreateNestedOneWithoutAttemptsInput
    booking?: ExamBookingCreateNestedOneWithoutAttemptsInput
    responses?: QuestionResponseCreateNestedManyWithoutAttemptInput
    questionScores?: QuestionScoreCreateNestedManyWithoutAttemptInput
    examScore?: ExamScoreCreateNestedOneWithoutAttemptInput
  }

  export type ExamAttemptUncheckedCreateWithoutCertificateInput = {
    id?: string
    userId: string
    examId: string
    bookingId?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.AttemptStatus
    totalMarks?: number
    obtainedMarks?: number
    percentage?: number
    isPassed?: boolean
    timeSpent?: number | null
    ipAddress?: string | null
    userAgent?: string | null
    isCheating?: boolean
    cheatingReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    responses?: QuestionResponseUncheckedCreateNestedManyWithoutAttemptInput
    questionScores?: QuestionScoreUncheckedCreateNestedManyWithoutAttemptInput
    examScore?: ExamScoreUncheckedCreateNestedOneWithoutAttemptInput
  }

  export type ExamAttemptCreateOrConnectWithoutCertificateInput = {
    where: ExamAttemptWhereUniqueInput
    create: XOR<ExamAttemptCreateWithoutCertificateInput, ExamAttemptUncheckedCreateWithoutCertificateInput>
  }

  export type UserCreateWithoutRevokedCertificatesInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examBookings?: ExamBookingCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    examAttempts?: ExamAttemptCreateNestedManyWithoutUserInput
    questionResponses?: QuestionResponseCreateNestedManyWithoutUserInput
    questionScores?: QuestionScoreCreateNestedManyWithoutUserInput
    examScores?: ExamScoreCreateNestedManyWithoutUserInput
    userPerformances?: UserPerformanceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    examCategories?: ExamCategoryUserCreateNestedManyWithoutUserInput
    studyGroups?: StudyGroupMemberCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    grantedExamCategories?: ExamCategoryUserCreateNestedManyWithoutGranterInput
    createdStudyGroups?: StudyGroupCreateNestedManyWithoutCreatorInput
    createdQuestions?: QuestionCreateNestedManyWithoutCreatorInput
    approvedQuestions?: QuestionCreateNestedManyWithoutApproverInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    approvedExams?: ExamCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateWithoutRevokedCertificatesInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examBookings?: ExamBookingUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    examAttempts?: ExamAttemptUncheckedCreateNestedManyWithoutUserInput
    questionResponses?: QuestionResponseUncheckedCreateNestedManyWithoutUserInput
    questionScores?: QuestionScoreUncheckedCreateNestedManyWithoutUserInput
    examScores?: ExamScoreUncheckedCreateNestedManyWithoutUserInput
    userPerformances?: UserPerformanceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    examCategories?: ExamCategoryUserUncheckedCreateNestedManyWithoutUserInput
    studyGroups?: StudyGroupMemberUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    grantedExamCategories?: ExamCategoryUserUncheckedCreateNestedManyWithoutGranterInput
    createdStudyGroups?: StudyGroupUncheckedCreateNestedManyWithoutCreatorInput
    createdQuestions?: QuestionUncheckedCreateNestedManyWithoutCreatorInput
    approvedQuestions?: QuestionUncheckedCreateNestedManyWithoutApproverInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    approvedExams?: ExamUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutRevokedCertificatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRevokedCertificatesInput, UserUncheckedCreateWithoutRevokedCertificatesInput>
  }

  export type UserUpsertWithoutCertificatesInput = {
    update: XOR<UserUpdateWithoutCertificatesInput, UserUncheckedUpdateWithoutCertificatesInput>
    create: XOR<UserCreateWithoutCertificatesInput, UserUncheckedCreateWithoutCertificatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCertificatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCertificatesInput, UserUncheckedUpdateWithoutCertificatesInput>
  }

  export type UserUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examBookings?: ExamBookingUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    examAttempts?: ExamAttemptUpdateManyWithoutUserNestedInput
    questionResponses?: QuestionResponseUpdateManyWithoutUserNestedInput
    questionScores?: QuestionScoreUpdateManyWithoutUserNestedInput
    examScores?: ExamScoreUpdateManyWithoutUserNestedInput
    userPerformances?: UserPerformanceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    examCategories?: ExamCategoryUserUpdateManyWithoutUserNestedInput
    studyGroups?: StudyGroupMemberUpdateManyWithoutUserNestedInput
    grantedExamCategories?: ExamCategoryUserUpdateManyWithoutGranterNestedInput
    createdStudyGroups?: StudyGroupUpdateManyWithoutCreatorNestedInput
    createdQuestions?: QuestionUpdateManyWithoutCreatorNestedInput
    approvedQuestions?: QuestionUpdateManyWithoutApproverNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    approvedExams?: ExamUpdateManyWithoutApproverNestedInput
    revokedCertificates?: CertificateUpdateManyWithoutRevokerNestedInput
  }

  export type UserUncheckedUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examBookings?: ExamBookingUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    examAttempts?: ExamAttemptUncheckedUpdateManyWithoutUserNestedInput
    questionResponses?: QuestionResponseUncheckedUpdateManyWithoutUserNestedInput
    questionScores?: QuestionScoreUncheckedUpdateManyWithoutUserNestedInput
    examScores?: ExamScoreUncheckedUpdateManyWithoutUserNestedInput
    userPerformances?: UserPerformanceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    examCategories?: ExamCategoryUserUncheckedUpdateManyWithoutUserNestedInput
    studyGroups?: StudyGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    grantedExamCategories?: ExamCategoryUserUncheckedUpdateManyWithoutGranterNestedInput
    createdStudyGroups?: StudyGroupUncheckedUpdateManyWithoutCreatorNestedInput
    createdQuestions?: QuestionUncheckedUpdateManyWithoutCreatorNestedInput
    approvedQuestions?: QuestionUncheckedUpdateManyWithoutApproverNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    approvedExams?: ExamUncheckedUpdateManyWithoutApproverNestedInput
    revokedCertificates?: CertificateUncheckedUpdateManyWithoutRevokerNestedInput
  }

  export type ExamUpsertWithoutCertificatesInput = {
    update: XOR<ExamUpdateWithoutCertificatesInput, ExamUncheckedUpdateWithoutCertificatesInput>
    create: XOR<ExamCreateWithoutCertificatesInput, ExamUncheckedCreateWithoutCertificatesInput>
    where?: ExamWhereInput
  }

  export type ExamUpdateToOneWithWhereWithoutCertificatesInput = {
    where?: ExamWhereInput
    data: XOR<ExamUpdateWithoutCertificatesInput, ExamUncheckedUpdateWithoutCertificatesInput>
  }

  export type ExamUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    totalMarks?: IntFieldUpdateOperationsInput | number
    passingMarks?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowRetakes?: BoolFieldUpdateOperationsInput | boolean
    maxRetakes?: IntFieldUpdateOperationsInput | number
    showResults?: BoolFieldUpdateOperationsInput | boolean
    showAnswers?: BoolFieldUpdateOperationsInput | boolean
    randomizeQuestions?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: BoolFieldUpdateOperationsInput | boolean
    questionOverlapPercentage?: FloatFieldUpdateOperationsInput | number
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examCategory?: ExamCategoryUpdateOneRequiredWithoutExamsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedExamsNestedInput
    approver?: UserUpdateOneWithoutApprovedExamsNestedInput
    questions?: ExamQuestionUpdateManyWithoutExamNestedInput
    bookings?: ExamBookingUpdateManyWithoutExamNestedInput
    attempts?: ExamAttemptUpdateManyWithoutExamNestedInput
    examScores?: ExamScoreUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    examCategoryId?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    totalMarks?: IntFieldUpdateOperationsInput | number
    passingMarks?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowRetakes?: BoolFieldUpdateOperationsInput | boolean
    maxRetakes?: IntFieldUpdateOperationsInput | number
    showResults?: BoolFieldUpdateOperationsInput | boolean
    showAnswers?: BoolFieldUpdateOperationsInput | boolean
    randomizeQuestions?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: BoolFieldUpdateOperationsInput | boolean
    questionOverlapPercentage?: FloatFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: ExamQuestionUncheckedUpdateManyWithoutExamNestedInput
    bookings?: ExamBookingUncheckedUpdateManyWithoutExamNestedInput
    attempts?: ExamAttemptUncheckedUpdateManyWithoutExamNestedInput
    examScores?: ExamScoreUncheckedUpdateManyWithoutExamNestedInput
  }

  export type ExamAttemptUpsertWithoutCertificateInput = {
    update: XOR<ExamAttemptUpdateWithoutCertificateInput, ExamAttemptUncheckedUpdateWithoutCertificateInput>
    create: XOR<ExamAttemptCreateWithoutCertificateInput, ExamAttemptUncheckedCreateWithoutCertificateInput>
    where?: ExamAttemptWhereInput
  }

  export type ExamAttemptUpdateToOneWithWhereWithoutCertificateInput = {
    where?: ExamAttemptWhereInput
    data: XOR<ExamAttemptUpdateWithoutCertificateInput, ExamAttemptUncheckedUpdateWithoutCertificateInput>
  }

  export type ExamAttemptUpdateWithoutCertificateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttemptStatusFieldUpdateOperationsInput | $Enums.AttemptStatus
    totalMarks?: IntFieldUpdateOperationsInput | number
    obtainedMarks?: IntFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isCheating?: BoolFieldUpdateOperationsInput | boolean
    cheatingReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExamAttemptsNestedInput
    exam?: ExamUpdateOneRequiredWithoutAttemptsNestedInput
    booking?: ExamBookingUpdateOneWithoutAttemptsNestedInput
    responses?: QuestionResponseUpdateManyWithoutAttemptNestedInput
    questionScores?: QuestionScoreUpdateManyWithoutAttemptNestedInput
    examScore?: ExamScoreUpdateOneWithoutAttemptNestedInput
  }

  export type ExamAttemptUncheckedUpdateWithoutCertificateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttemptStatusFieldUpdateOperationsInput | $Enums.AttemptStatus
    totalMarks?: IntFieldUpdateOperationsInput | number
    obtainedMarks?: IntFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isCheating?: BoolFieldUpdateOperationsInput | boolean
    cheatingReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: QuestionResponseUncheckedUpdateManyWithoutAttemptNestedInput
    questionScores?: QuestionScoreUncheckedUpdateManyWithoutAttemptNestedInput
    examScore?: ExamScoreUncheckedUpdateOneWithoutAttemptNestedInput
  }

  export type UserUpsertWithoutRevokedCertificatesInput = {
    update: XOR<UserUpdateWithoutRevokedCertificatesInput, UserUncheckedUpdateWithoutRevokedCertificatesInput>
    create: XOR<UserCreateWithoutRevokedCertificatesInput, UserUncheckedCreateWithoutRevokedCertificatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRevokedCertificatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRevokedCertificatesInput, UserUncheckedUpdateWithoutRevokedCertificatesInput>
  }

  export type UserUpdateWithoutRevokedCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examBookings?: ExamBookingUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    examAttempts?: ExamAttemptUpdateManyWithoutUserNestedInput
    questionResponses?: QuestionResponseUpdateManyWithoutUserNestedInput
    questionScores?: QuestionScoreUpdateManyWithoutUserNestedInput
    examScores?: ExamScoreUpdateManyWithoutUserNestedInput
    userPerformances?: UserPerformanceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    examCategories?: ExamCategoryUserUpdateManyWithoutUserNestedInput
    studyGroups?: StudyGroupMemberUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    grantedExamCategories?: ExamCategoryUserUpdateManyWithoutGranterNestedInput
    createdStudyGroups?: StudyGroupUpdateManyWithoutCreatorNestedInput
    createdQuestions?: QuestionUpdateManyWithoutCreatorNestedInput
    approvedQuestions?: QuestionUpdateManyWithoutApproverNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    approvedExams?: ExamUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateWithoutRevokedCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examBookings?: ExamBookingUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    examAttempts?: ExamAttemptUncheckedUpdateManyWithoutUserNestedInput
    questionResponses?: QuestionResponseUncheckedUpdateManyWithoutUserNestedInput
    questionScores?: QuestionScoreUncheckedUpdateManyWithoutUserNestedInput
    examScores?: ExamScoreUncheckedUpdateManyWithoutUserNestedInput
    userPerformances?: UserPerformanceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    examCategories?: ExamCategoryUserUncheckedUpdateManyWithoutUserNestedInput
    studyGroups?: StudyGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    grantedExamCategories?: ExamCategoryUserUncheckedUpdateManyWithoutGranterNestedInput
    createdStudyGroups?: StudyGroupUncheckedUpdateManyWithoutCreatorNestedInput
    createdQuestions?: QuestionUncheckedUpdateManyWithoutCreatorNestedInput
    approvedQuestions?: QuestionUncheckedUpdateManyWithoutApproverNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    approvedExams?: ExamUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examBookings?: ExamBookingCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    examAttempts?: ExamAttemptCreateNestedManyWithoutUserInput
    questionResponses?: QuestionResponseCreateNestedManyWithoutUserInput
    questionScores?: QuestionScoreCreateNestedManyWithoutUserInput
    examScores?: ExamScoreCreateNestedManyWithoutUserInput
    userPerformances?: UserPerformanceCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    examCategories?: ExamCategoryUserCreateNestedManyWithoutUserInput
    studyGroups?: StudyGroupMemberCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    grantedExamCategories?: ExamCategoryUserCreateNestedManyWithoutGranterInput
    createdStudyGroups?: StudyGroupCreateNestedManyWithoutCreatorInput
    createdQuestions?: QuestionCreateNestedManyWithoutCreatorInput
    approvedQuestions?: QuestionCreateNestedManyWithoutApproverInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    approvedExams?: ExamCreateNestedManyWithoutApproverInput
    revokedCertificates?: CertificateCreateNestedManyWithoutRevokerInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examBookings?: ExamBookingUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    examAttempts?: ExamAttemptUncheckedCreateNestedManyWithoutUserInput
    questionResponses?: QuestionResponseUncheckedCreateNestedManyWithoutUserInput
    questionScores?: QuestionScoreUncheckedCreateNestedManyWithoutUserInput
    examScores?: ExamScoreUncheckedCreateNestedManyWithoutUserInput
    userPerformances?: UserPerformanceUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    examCategories?: ExamCategoryUserUncheckedCreateNestedManyWithoutUserInput
    studyGroups?: StudyGroupMemberUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    grantedExamCategories?: ExamCategoryUserUncheckedCreateNestedManyWithoutGranterInput
    createdStudyGroups?: StudyGroupUncheckedCreateNestedManyWithoutCreatorInput
    createdQuestions?: QuestionUncheckedCreateNestedManyWithoutCreatorInput
    approvedQuestions?: QuestionUncheckedCreateNestedManyWithoutApproverInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    approvedExams?: ExamUncheckedCreateNestedManyWithoutApproverInput
    revokedCertificates?: CertificateUncheckedCreateNestedManyWithoutRevokerInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examBookings?: ExamBookingUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    examAttempts?: ExamAttemptUpdateManyWithoutUserNestedInput
    questionResponses?: QuestionResponseUpdateManyWithoutUserNestedInput
    questionScores?: QuestionScoreUpdateManyWithoutUserNestedInput
    examScores?: ExamScoreUpdateManyWithoutUserNestedInput
    userPerformances?: UserPerformanceUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    examCategories?: ExamCategoryUserUpdateManyWithoutUserNestedInput
    studyGroups?: StudyGroupMemberUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    grantedExamCategories?: ExamCategoryUserUpdateManyWithoutGranterNestedInput
    createdStudyGroups?: StudyGroupUpdateManyWithoutCreatorNestedInput
    createdQuestions?: QuestionUpdateManyWithoutCreatorNestedInput
    approvedQuestions?: QuestionUpdateManyWithoutApproverNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    approvedExams?: ExamUpdateManyWithoutApproverNestedInput
    revokedCertificates?: CertificateUpdateManyWithoutRevokerNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examBookings?: ExamBookingUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    examAttempts?: ExamAttemptUncheckedUpdateManyWithoutUserNestedInput
    questionResponses?: QuestionResponseUncheckedUpdateManyWithoutUserNestedInput
    questionScores?: QuestionScoreUncheckedUpdateManyWithoutUserNestedInput
    examScores?: ExamScoreUncheckedUpdateManyWithoutUserNestedInput
    userPerformances?: UserPerformanceUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    examCategories?: ExamCategoryUserUncheckedUpdateManyWithoutUserNestedInput
    studyGroups?: StudyGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    grantedExamCategories?: ExamCategoryUserUncheckedUpdateManyWithoutGranterNestedInput
    createdStudyGroups?: StudyGroupUncheckedUpdateManyWithoutCreatorNestedInput
    createdQuestions?: QuestionUncheckedUpdateManyWithoutCreatorNestedInput
    approvedQuestions?: QuestionUncheckedUpdateManyWithoutApproverNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    approvedExams?: ExamUncheckedUpdateManyWithoutApproverNestedInput
    revokedCertificates?: CertificateUncheckedUpdateManyWithoutRevokerNestedInput
  }

  export type UserCreateWithoutCreatedStudyGroupsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examBookings?: ExamBookingCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    examAttempts?: ExamAttemptCreateNestedManyWithoutUserInput
    questionResponses?: QuestionResponseCreateNestedManyWithoutUserInput
    questionScores?: QuestionScoreCreateNestedManyWithoutUserInput
    examScores?: ExamScoreCreateNestedManyWithoutUserInput
    userPerformances?: UserPerformanceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    examCategories?: ExamCategoryUserCreateNestedManyWithoutUserInput
    studyGroups?: StudyGroupMemberCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    grantedExamCategories?: ExamCategoryUserCreateNestedManyWithoutGranterInput
    createdQuestions?: QuestionCreateNestedManyWithoutCreatorInput
    approvedQuestions?: QuestionCreateNestedManyWithoutApproverInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    approvedExams?: ExamCreateNestedManyWithoutApproverInput
    revokedCertificates?: CertificateCreateNestedManyWithoutRevokerInput
  }

  export type UserUncheckedCreateWithoutCreatedStudyGroupsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examBookings?: ExamBookingUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    examAttempts?: ExamAttemptUncheckedCreateNestedManyWithoutUserInput
    questionResponses?: QuestionResponseUncheckedCreateNestedManyWithoutUserInput
    questionScores?: QuestionScoreUncheckedCreateNestedManyWithoutUserInput
    examScores?: ExamScoreUncheckedCreateNestedManyWithoutUserInput
    userPerformances?: UserPerformanceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    examCategories?: ExamCategoryUserUncheckedCreateNestedManyWithoutUserInput
    studyGroups?: StudyGroupMemberUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    grantedExamCategories?: ExamCategoryUserUncheckedCreateNestedManyWithoutGranterInput
    createdQuestions?: QuestionUncheckedCreateNestedManyWithoutCreatorInput
    approvedQuestions?: QuestionUncheckedCreateNestedManyWithoutApproverInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    approvedExams?: ExamUncheckedCreateNestedManyWithoutApproverInput
    revokedCertificates?: CertificateUncheckedCreateNestedManyWithoutRevokerInput
  }

  export type UserCreateOrConnectWithoutCreatedStudyGroupsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedStudyGroupsInput, UserUncheckedCreateWithoutCreatedStudyGroupsInput>
  }

  export type StudyGroupMemberCreateWithoutGroupInput = {
    id?: string
    role?: $Enums.GroupRole
    joinedAt?: Date | string
    isActive?: boolean
    user: UserCreateNestedOneWithoutStudyGroupsInput
  }

  export type StudyGroupMemberUncheckedCreateWithoutGroupInput = {
    id?: string
    userId: string
    role?: $Enums.GroupRole
    joinedAt?: Date | string
    isActive?: boolean
  }

  export type StudyGroupMemberCreateOrConnectWithoutGroupInput = {
    where: StudyGroupMemberWhereUniqueInput
    create: XOR<StudyGroupMemberCreateWithoutGroupInput, StudyGroupMemberUncheckedCreateWithoutGroupInput>
  }

  export type StudyGroupMemberCreateManyGroupInputEnvelope = {
    data: StudyGroupMemberCreateManyGroupInput | StudyGroupMemberCreateManyGroupInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatedStudyGroupsInput = {
    update: XOR<UserUpdateWithoutCreatedStudyGroupsInput, UserUncheckedUpdateWithoutCreatedStudyGroupsInput>
    create: XOR<UserCreateWithoutCreatedStudyGroupsInput, UserUncheckedCreateWithoutCreatedStudyGroupsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedStudyGroupsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedStudyGroupsInput, UserUncheckedUpdateWithoutCreatedStudyGroupsInput>
  }

  export type UserUpdateWithoutCreatedStudyGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examBookings?: ExamBookingUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    examAttempts?: ExamAttemptUpdateManyWithoutUserNestedInput
    questionResponses?: QuestionResponseUpdateManyWithoutUserNestedInput
    questionScores?: QuestionScoreUpdateManyWithoutUserNestedInput
    examScores?: ExamScoreUpdateManyWithoutUserNestedInput
    userPerformances?: UserPerformanceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    examCategories?: ExamCategoryUserUpdateManyWithoutUserNestedInput
    studyGroups?: StudyGroupMemberUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    grantedExamCategories?: ExamCategoryUserUpdateManyWithoutGranterNestedInput
    createdQuestions?: QuestionUpdateManyWithoutCreatorNestedInput
    approvedQuestions?: QuestionUpdateManyWithoutApproverNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    approvedExams?: ExamUpdateManyWithoutApproverNestedInput
    revokedCertificates?: CertificateUpdateManyWithoutRevokerNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedStudyGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examBookings?: ExamBookingUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    examAttempts?: ExamAttemptUncheckedUpdateManyWithoutUserNestedInput
    questionResponses?: QuestionResponseUncheckedUpdateManyWithoutUserNestedInput
    questionScores?: QuestionScoreUncheckedUpdateManyWithoutUserNestedInput
    examScores?: ExamScoreUncheckedUpdateManyWithoutUserNestedInput
    userPerformances?: UserPerformanceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    examCategories?: ExamCategoryUserUncheckedUpdateManyWithoutUserNestedInput
    studyGroups?: StudyGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    grantedExamCategories?: ExamCategoryUserUncheckedUpdateManyWithoutGranterNestedInput
    createdQuestions?: QuestionUncheckedUpdateManyWithoutCreatorNestedInput
    approvedQuestions?: QuestionUncheckedUpdateManyWithoutApproverNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    approvedExams?: ExamUncheckedUpdateManyWithoutApproverNestedInput
    revokedCertificates?: CertificateUncheckedUpdateManyWithoutRevokerNestedInput
  }

  export type StudyGroupMemberUpsertWithWhereUniqueWithoutGroupInput = {
    where: StudyGroupMemberWhereUniqueInput
    update: XOR<StudyGroupMemberUpdateWithoutGroupInput, StudyGroupMemberUncheckedUpdateWithoutGroupInput>
    create: XOR<StudyGroupMemberCreateWithoutGroupInput, StudyGroupMemberUncheckedCreateWithoutGroupInput>
  }

  export type StudyGroupMemberUpdateWithWhereUniqueWithoutGroupInput = {
    where: StudyGroupMemberWhereUniqueInput
    data: XOR<StudyGroupMemberUpdateWithoutGroupInput, StudyGroupMemberUncheckedUpdateWithoutGroupInput>
  }

  export type StudyGroupMemberUpdateManyWithWhereWithoutGroupInput = {
    where: StudyGroupMemberScalarWhereInput
    data: XOR<StudyGroupMemberUpdateManyMutationInput, StudyGroupMemberUncheckedUpdateManyWithoutGroupInput>
  }

  export type StudyGroupCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    isPrivate?: boolean
    maxMembers?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutCreatedStudyGroupsInput
  }

  export type StudyGroupUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    description?: string | null
    isPrivate?: boolean
    maxMembers?: number
    createdBy: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudyGroupCreateOrConnectWithoutMembersInput = {
    where: StudyGroupWhereUniqueInput
    create: XOR<StudyGroupCreateWithoutMembersInput, StudyGroupUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutStudyGroupsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examBookings?: ExamBookingCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    examAttempts?: ExamAttemptCreateNestedManyWithoutUserInput
    questionResponses?: QuestionResponseCreateNestedManyWithoutUserInput
    questionScores?: QuestionScoreCreateNestedManyWithoutUserInput
    examScores?: ExamScoreCreateNestedManyWithoutUserInput
    userPerformances?: UserPerformanceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    examCategories?: ExamCategoryUserCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    grantedExamCategories?: ExamCategoryUserCreateNestedManyWithoutGranterInput
    createdStudyGroups?: StudyGroupCreateNestedManyWithoutCreatorInput
    createdQuestions?: QuestionCreateNestedManyWithoutCreatorInput
    approvedQuestions?: QuestionCreateNestedManyWithoutApproverInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    approvedExams?: ExamCreateNestedManyWithoutApproverInput
    revokedCertificates?: CertificateCreateNestedManyWithoutRevokerInput
  }

  export type UserUncheckedCreateWithoutStudyGroupsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examBookings?: ExamBookingUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    examAttempts?: ExamAttemptUncheckedCreateNestedManyWithoutUserInput
    questionResponses?: QuestionResponseUncheckedCreateNestedManyWithoutUserInput
    questionScores?: QuestionScoreUncheckedCreateNestedManyWithoutUserInput
    examScores?: ExamScoreUncheckedCreateNestedManyWithoutUserInput
    userPerformances?: UserPerformanceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    examCategories?: ExamCategoryUserUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    grantedExamCategories?: ExamCategoryUserUncheckedCreateNestedManyWithoutGranterInput
    createdStudyGroups?: StudyGroupUncheckedCreateNestedManyWithoutCreatorInput
    createdQuestions?: QuestionUncheckedCreateNestedManyWithoutCreatorInput
    approvedQuestions?: QuestionUncheckedCreateNestedManyWithoutApproverInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    approvedExams?: ExamUncheckedCreateNestedManyWithoutApproverInput
    revokedCertificates?: CertificateUncheckedCreateNestedManyWithoutRevokerInput
  }

  export type UserCreateOrConnectWithoutStudyGroupsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStudyGroupsInput, UserUncheckedCreateWithoutStudyGroupsInput>
  }

  export type StudyGroupUpsertWithoutMembersInput = {
    update: XOR<StudyGroupUpdateWithoutMembersInput, StudyGroupUncheckedUpdateWithoutMembersInput>
    create: XOR<StudyGroupCreateWithoutMembersInput, StudyGroupUncheckedCreateWithoutMembersInput>
    where?: StudyGroupWhereInput
  }

  export type StudyGroupUpdateToOneWithWhereWithoutMembersInput = {
    where?: StudyGroupWhereInput
    data: XOR<StudyGroupUpdateWithoutMembersInput, StudyGroupUncheckedUpdateWithoutMembersInput>
  }

  export type StudyGroupUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    maxMembers?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedStudyGroupsNestedInput
  }

  export type StudyGroupUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    maxMembers?: IntFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutStudyGroupsInput = {
    update: XOR<UserUpdateWithoutStudyGroupsInput, UserUncheckedUpdateWithoutStudyGroupsInput>
    create: XOR<UserCreateWithoutStudyGroupsInput, UserUncheckedCreateWithoutStudyGroupsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStudyGroupsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStudyGroupsInput, UserUncheckedUpdateWithoutStudyGroupsInput>
  }

  export type UserUpdateWithoutStudyGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examBookings?: ExamBookingUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    examAttempts?: ExamAttemptUpdateManyWithoutUserNestedInput
    questionResponses?: QuestionResponseUpdateManyWithoutUserNestedInput
    questionScores?: QuestionScoreUpdateManyWithoutUserNestedInput
    examScores?: ExamScoreUpdateManyWithoutUserNestedInput
    userPerformances?: UserPerformanceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    examCategories?: ExamCategoryUserUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    grantedExamCategories?: ExamCategoryUserUpdateManyWithoutGranterNestedInput
    createdStudyGroups?: StudyGroupUpdateManyWithoutCreatorNestedInput
    createdQuestions?: QuestionUpdateManyWithoutCreatorNestedInput
    approvedQuestions?: QuestionUpdateManyWithoutApproverNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    approvedExams?: ExamUpdateManyWithoutApproverNestedInput
    revokedCertificates?: CertificateUpdateManyWithoutRevokerNestedInput
  }

  export type UserUncheckedUpdateWithoutStudyGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examBookings?: ExamBookingUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    examAttempts?: ExamAttemptUncheckedUpdateManyWithoutUserNestedInput
    questionResponses?: QuestionResponseUncheckedUpdateManyWithoutUserNestedInput
    questionScores?: QuestionScoreUncheckedUpdateManyWithoutUserNestedInput
    examScores?: ExamScoreUncheckedUpdateManyWithoutUserNestedInput
    userPerformances?: UserPerformanceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    examCategories?: ExamCategoryUserUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    grantedExamCategories?: ExamCategoryUserUncheckedUpdateManyWithoutGranterNestedInput
    createdStudyGroups?: StudyGroupUncheckedUpdateManyWithoutCreatorNestedInput
    createdQuestions?: QuestionUncheckedUpdateManyWithoutCreatorNestedInput
    approvedQuestions?: QuestionUncheckedUpdateManyWithoutApproverNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    approvedExams?: ExamUncheckedUpdateManyWithoutApproverNestedInput
    revokedCertificates?: CertificateUncheckedUpdateManyWithoutRevokerNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examBookings?: ExamBookingCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    examAttempts?: ExamAttemptCreateNestedManyWithoutUserInput
    questionResponses?: QuestionResponseCreateNestedManyWithoutUserInput
    questionScores?: QuestionScoreCreateNestedManyWithoutUserInput
    examScores?: ExamScoreCreateNestedManyWithoutUserInput
    userPerformances?: UserPerformanceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    examCategories?: ExamCategoryUserCreateNestedManyWithoutUserInput
    studyGroups?: StudyGroupMemberCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    grantedExamCategories?: ExamCategoryUserCreateNestedManyWithoutGranterInput
    createdStudyGroups?: StudyGroupCreateNestedManyWithoutCreatorInput
    createdQuestions?: QuestionCreateNestedManyWithoutCreatorInput
    approvedQuestions?: QuestionCreateNestedManyWithoutApproverInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    approvedExams?: ExamCreateNestedManyWithoutApproverInput
    revokedCertificates?: CertificateCreateNestedManyWithoutRevokerInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examBookings?: ExamBookingUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    examAttempts?: ExamAttemptUncheckedCreateNestedManyWithoutUserInput
    questionResponses?: QuestionResponseUncheckedCreateNestedManyWithoutUserInput
    questionScores?: QuestionScoreUncheckedCreateNestedManyWithoutUserInput
    examScores?: ExamScoreUncheckedCreateNestedManyWithoutUserInput
    userPerformances?: UserPerformanceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    examCategories?: ExamCategoryUserUncheckedCreateNestedManyWithoutUserInput
    studyGroups?: StudyGroupMemberUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    grantedExamCategories?: ExamCategoryUserUncheckedCreateNestedManyWithoutGranterInput
    createdStudyGroups?: StudyGroupUncheckedCreateNestedManyWithoutCreatorInput
    createdQuestions?: QuestionUncheckedCreateNestedManyWithoutCreatorInput
    approvedQuestions?: QuestionUncheckedCreateNestedManyWithoutApproverInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    approvedExams?: ExamUncheckedCreateNestedManyWithoutApproverInput
    revokedCertificates?: CertificateUncheckedCreateNestedManyWithoutRevokerInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examBookings?: ExamBookingUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    examAttempts?: ExamAttemptUpdateManyWithoutUserNestedInput
    questionResponses?: QuestionResponseUpdateManyWithoutUserNestedInput
    questionScores?: QuestionScoreUpdateManyWithoutUserNestedInput
    examScores?: ExamScoreUpdateManyWithoutUserNestedInput
    userPerformances?: UserPerformanceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    examCategories?: ExamCategoryUserUpdateManyWithoutUserNestedInput
    studyGroups?: StudyGroupMemberUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    grantedExamCategories?: ExamCategoryUserUpdateManyWithoutGranterNestedInput
    createdStudyGroups?: StudyGroupUpdateManyWithoutCreatorNestedInput
    createdQuestions?: QuestionUpdateManyWithoutCreatorNestedInput
    approvedQuestions?: QuestionUpdateManyWithoutApproverNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    approvedExams?: ExamUpdateManyWithoutApproverNestedInput
    revokedCertificates?: CertificateUpdateManyWithoutRevokerNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examBookings?: ExamBookingUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    examAttempts?: ExamAttemptUncheckedUpdateManyWithoutUserNestedInput
    questionResponses?: QuestionResponseUncheckedUpdateManyWithoutUserNestedInput
    questionScores?: QuestionScoreUncheckedUpdateManyWithoutUserNestedInput
    examScores?: ExamScoreUncheckedUpdateManyWithoutUserNestedInput
    userPerformances?: UserPerformanceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    examCategories?: ExamCategoryUserUncheckedUpdateManyWithoutUserNestedInput
    studyGroups?: StudyGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    grantedExamCategories?: ExamCategoryUserUncheckedUpdateManyWithoutGranterNestedInput
    createdStudyGroups?: StudyGroupUncheckedUpdateManyWithoutCreatorNestedInput
    createdQuestions?: QuestionUncheckedUpdateManyWithoutCreatorNestedInput
    approvedQuestions?: QuestionUncheckedUpdateManyWithoutApproverNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    approvedExams?: ExamUncheckedUpdateManyWithoutApproverNestedInput
    revokedCertificates?: CertificateUncheckedUpdateManyWithoutRevokerNestedInput
  }

  export type ExamCategoryCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    exams?: ExamCreateNestedManyWithoutExamCategoryInput
    questions?: QuestionCreateNestedManyWithoutExamCategoryInput
    userPerformances?: UserPerformanceCreateNestedManyWithoutExamCategoryInput
  }

  export type ExamCategoryUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    icon?: string | null
    color?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    exams?: ExamUncheckedCreateNestedManyWithoutExamCategoryInput
    questions?: QuestionUncheckedCreateNestedManyWithoutExamCategoryInput
    userPerformances?: UserPerformanceUncheckedCreateNestedManyWithoutExamCategoryInput
  }

  export type ExamCategoryCreateOrConnectWithoutUsersInput = {
    where: ExamCategoryWhereUniqueInput
    create: XOR<ExamCategoryCreateWithoutUsersInput, ExamCategoryUncheckedCreateWithoutUsersInput>
  }

  export type UserCreateWithoutExamCategoriesInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examBookings?: ExamBookingCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    examAttempts?: ExamAttemptCreateNestedManyWithoutUserInput
    questionResponses?: QuestionResponseCreateNestedManyWithoutUserInput
    questionScores?: QuestionScoreCreateNestedManyWithoutUserInput
    examScores?: ExamScoreCreateNestedManyWithoutUserInput
    userPerformances?: UserPerformanceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    studyGroups?: StudyGroupMemberCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    grantedExamCategories?: ExamCategoryUserCreateNestedManyWithoutGranterInput
    createdStudyGroups?: StudyGroupCreateNestedManyWithoutCreatorInput
    createdQuestions?: QuestionCreateNestedManyWithoutCreatorInput
    approvedQuestions?: QuestionCreateNestedManyWithoutApproverInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    approvedExams?: ExamCreateNestedManyWithoutApproverInput
    revokedCertificates?: CertificateCreateNestedManyWithoutRevokerInput
  }

  export type UserUncheckedCreateWithoutExamCategoriesInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examBookings?: ExamBookingUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    examAttempts?: ExamAttemptUncheckedCreateNestedManyWithoutUserInput
    questionResponses?: QuestionResponseUncheckedCreateNestedManyWithoutUserInput
    questionScores?: QuestionScoreUncheckedCreateNestedManyWithoutUserInput
    examScores?: ExamScoreUncheckedCreateNestedManyWithoutUserInput
    userPerformances?: UserPerformanceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    studyGroups?: StudyGroupMemberUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    grantedExamCategories?: ExamCategoryUserUncheckedCreateNestedManyWithoutGranterInput
    createdStudyGroups?: StudyGroupUncheckedCreateNestedManyWithoutCreatorInput
    createdQuestions?: QuestionUncheckedCreateNestedManyWithoutCreatorInput
    approvedQuestions?: QuestionUncheckedCreateNestedManyWithoutApproverInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    approvedExams?: ExamUncheckedCreateNestedManyWithoutApproverInput
    revokedCertificates?: CertificateUncheckedCreateNestedManyWithoutRevokerInput
  }

  export type UserCreateOrConnectWithoutExamCategoriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExamCategoriesInput, UserUncheckedCreateWithoutExamCategoriesInput>
  }

  export type UserCreateWithoutGrantedExamCategoriesInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examBookings?: ExamBookingCreateNestedManyWithoutUserInput
    payments?: PaymentCreateNestedManyWithoutUserInput
    examAttempts?: ExamAttemptCreateNestedManyWithoutUserInput
    questionResponses?: QuestionResponseCreateNestedManyWithoutUserInput
    questionScores?: QuestionScoreCreateNestedManyWithoutUserInput
    examScores?: ExamScoreCreateNestedManyWithoutUserInput
    userPerformances?: UserPerformanceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    userSessions?: UserSessionCreateNestedManyWithoutUserInput
    examCategories?: ExamCategoryUserCreateNestedManyWithoutUserInput
    studyGroups?: StudyGroupMemberCreateNestedManyWithoutUserInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    createdStudyGroups?: StudyGroupCreateNestedManyWithoutCreatorInput
    createdQuestions?: QuestionCreateNestedManyWithoutCreatorInput
    approvedQuestions?: QuestionCreateNestedManyWithoutApproverInput
    createdExams?: ExamCreateNestedManyWithoutCreatorInput
    approvedExams?: ExamCreateNestedManyWithoutApproverInput
    revokedCertificates?: CertificateCreateNestedManyWithoutRevokerInput
  }

  export type UserUncheckedCreateWithoutGrantedExamCategoriesInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    phone?: string | null
    dateOfBirth?: Date | string | null
    gender?: $Enums.Gender | null
    profileImage?: string | null
    profilePicture?: string | null
    address?: string | null
    isActive?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    emailVerificationToken?: string | null
    passwordResetToken?: string | null
    passwordResetExpires?: Date | string | null
    lastLoginAt?: Date | string | null
    loginAttempts?: number
    lockedUntil?: Date | string | null
    role?: $Enums.UserRole
    status?: string | null
    departmentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    examBookings?: ExamBookingUncheckedCreateNestedManyWithoutUserInput
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput
    examAttempts?: ExamAttemptUncheckedCreateNestedManyWithoutUserInput
    questionResponses?: QuestionResponseUncheckedCreateNestedManyWithoutUserInput
    questionScores?: QuestionScoreUncheckedCreateNestedManyWithoutUserInput
    examScores?: ExamScoreUncheckedCreateNestedManyWithoutUserInput
    userPerformances?: UserPerformanceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    userSessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
    examCategories?: ExamCategoryUserUncheckedCreateNestedManyWithoutUserInput
    studyGroups?: StudyGroupMemberUncheckedCreateNestedManyWithoutUserInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    createdStudyGroups?: StudyGroupUncheckedCreateNestedManyWithoutCreatorInput
    createdQuestions?: QuestionUncheckedCreateNestedManyWithoutCreatorInput
    approvedQuestions?: QuestionUncheckedCreateNestedManyWithoutApproverInput
    createdExams?: ExamUncheckedCreateNestedManyWithoutCreatorInput
    approvedExams?: ExamUncheckedCreateNestedManyWithoutApproverInput
    revokedCertificates?: CertificateUncheckedCreateNestedManyWithoutRevokerInput
  }

  export type UserCreateOrConnectWithoutGrantedExamCategoriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGrantedExamCategoriesInput, UserUncheckedCreateWithoutGrantedExamCategoriesInput>
  }

  export type ExamCategoryUpsertWithoutUsersInput = {
    update: XOR<ExamCategoryUpdateWithoutUsersInput, ExamCategoryUncheckedUpdateWithoutUsersInput>
    create: XOR<ExamCategoryCreateWithoutUsersInput, ExamCategoryUncheckedCreateWithoutUsersInput>
    where?: ExamCategoryWhereInput
  }

  export type ExamCategoryUpdateToOneWithWhereWithoutUsersInput = {
    where?: ExamCategoryWhereInput
    data: XOR<ExamCategoryUpdateWithoutUsersInput, ExamCategoryUncheckedUpdateWithoutUsersInput>
  }

  export type ExamCategoryUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exams?: ExamUpdateManyWithoutExamCategoryNestedInput
    questions?: QuestionUpdateManyWithoutExamCategoryNestedInput
    userPerformances?: UserPerformanceUpdateManyWithoutExamCategoryNestedInput
  }

  export type ExamCategoryUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exams?: ExamUncheckedUpdateManyWithoutExamCategoryNestedInput
    questions?: QuestionUncheckedUpdateManyWithoutExamCategoryNestedInput
    userPerformances?: UserPerformanceUncheckedUpdateManyWithoutExamCategoryNestedInput
  }

  export type UserUpsertWithoutExamCategoriesInput = {
    update: XOR<UserUpdateWithoutExamCategoriesInput, UserUncheckedUpdateWithoutExamCategoriesInput>
    create: XOR<UserCreateWithoutExamCategoriesInput, UserUncheckedCreateWithoutExamCategoriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExamCategoriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExamCategoriesInput, UserUncheckedUpdateWithoutExamCategoriesInput>
  }

  export type UserUpdateWithoutExamCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examBookings?: ExamBookingUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    examAttempts?: ExamAttemptUpdateManyWithoutUserNestedInput
    questionResponses?: QuestionResponseUpdateManyWithoutUserNestedInput
    questionScores?: QuestionScoreUpdateManyWithoutUserNestedInput
    examScores?: ExamScoreUpdateManyWithoutUserNestedInput
    userPerformances?: UserPerformanceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    studyGroups?: StudyGroupMemberUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    grantedExamCategories?: ExamCategoryUserUpdateManyWithoutGranterNestedInput
    createdStudyGroups?: StudyGroupUpdateManyWithoutCreatorNestedInput
    createdQuestions?: QuestionUpdateManyWithoutCreatorNestedInput
    approvedQuestions?: QuestionUpdateManyWithoutApproverNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    approvedExams?: ExamUpdateManyWithoutApproverNestedInput
    revokedCertificates?: CertificateUpdateManyWithoutRevokerNestedInput
  }

  export type UserUncheckedUpdateWithoutExamCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examBookings?: ExamBookingUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    examAttempts?: ExamAttemptUncheckedUpdateManyWithoutUserNestedInput
    questionResponses?: QuestionResponseUncheckedUpdateManyWithoutUserNestedInput
    questionScores?: QuestionScoreUncheckedUpdateManyWithoutUserNestedInput
    examScores?: ExamScoreUncheckedUpdateManyWithoutUserNestedInput
    userPerformances?: UserPerformanceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    studyGroups?: StudyGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    grantedExamCategories?: ExamCategoryUserUncheckedUpdateManyWithoutGranterNestedInput
    createdStudyGroups?: StudyGroupUncheckedUpdateManyWithoutCreatorNestedInput
    createdQuestions?: QuestionUncheckedUpdateManyWithoutCreatorNestedInput
    approvedQuestions?: QuestionUncheckedUpdateManyWithoutApproverNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    approvedExams?: ExamUncheckedUpdateManyWithoutApproverNestedInput
    revokedCertificates?: CertificateUncheckedUpdateManyWithoutRevokerNestedInput
  }

  export type UserUpsertWithoutGrantedExamCategoriesInput = {
    update: XOR<UserUpdateWithoutGrantedExamCategoriesInput, UserUncheckedUpdateWithoutGrantedExamCategoriesInput>
    create: XOR<UserCreateWithoutGrantedExamCategoriesInput, UserUncheckedCreateWithoutGrantedExamCategoriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGrantedExamCategoriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGrantedExamCategoriesInput, UserUncheckedUpdateWithoutGrantedExamCategoriesInput>
  }

  export type UserUpdateWithoutGrantedExamCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examBookings?: ExamBookingUpdateManyWithoutUserNestedInput
    payments?: PaymentUpdateManyWithoutUserNestedInput
    examAttempts?: ExamAttemptUpdateManyWithoutUserNestedInput
    questionResponses?: QuestionResponseUpdateManyWithoutUserNestedInput
    questionScores?: QuestionScoreUpdateManyWithoutUserNestedInput
    examScores?: ExamScoreUpdateManyWithoutUserNestedInput
    userPerformances?: UserPerformanceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUpdateManyWithoutUserNestedInput
    examCategories?: ExamCategoryUserUpdateManyWithoutUserNestedInput
    studyGroups?: StudyGroupMemberUpdateManyWithoutUserNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    createdStudyGroups?: StudyGroupUpdateManyWithoutCreatorNestedInput
    createdQuestions?: QuestionUpdateManyWithoutCreatorNestedInput
    approvedQuestions?: QuestionUpdateManyWithoutApproverNestedInput
    createdExams?: ExamUpdateManyWithoutCreatorNestedInput
    approvedExams?: ExamUpdateManyWithoutApproverNestedInput
    revokedCertificates?: CertificateUpdateManyWithoutRevokerNestedInput
  }

  export type UserUncheckedUpdateWithoutGrantedExamCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    profileImage?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    emailVerificationToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetToken?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLoginAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    loginAttempts?: IntFieldUpdateOperationsInput | number
    lockedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examBookings?: ExamBookingUncheckedUpdateManyWithoutUserNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput
    examAttempts?: ExamAttemptUncheckedUpdateManyWithoutUserNestedInput
    questionResponses?: QuestionResponseUncheckedUpdateManyWithoutUserNestedInput
    questionScores?: QuestionScoreUncheckedUpdateManyWithoutUserNestedInput
    examScores?: ExamScoreUncheckedUpdateManyWithoutUserNestedInput
    userPerformances?: UserPerformanceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    userSessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
    examCategories?: ExamCategoryUserUncheckedUpdateManyWithoutUserNestedInput
    studyGroups?: StudyGroupMemberUncheckedUpdateManyWithoutUserNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    createdStudyGroups?: StudyGroupUncheckedUpdateManyWithoutCreatorNestedInput
    createdQuestions?: QuestionUncheckedUpdateManyWithoutCreatorNestedInput
    approvedQuestions?: QuestionUncheckedUpdateManyWithoutApproverNestedInput
    createdExams?: ExamUncheckedUpdateManyWithoutCreatorNestedInput
    approvedExams?: ExamUncheckedUpdateManyWithoutApproverNestedInput
    revokedCertificates?: CertificateUncheckedUpdateManyWithoutRevokerNestedInput
  }

  export type ExamBookingCreateManyUserInput = {
    id?: string
    examId: string
    bookingDate?: Date | string
    scheduledAt?: Date | string | null
    status?: $Enums.BookingStatus
    paymentId?: string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyUserInput = {
    id?: string
    bookingId?: string | null
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    status?: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    stripePaymentId?: string | null
    stripeRefundId?: string | null
    description?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    refundedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamAttemptCreateManyUserInput = {
    id?: string
    examId: string
    bookingId?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.AttemptStatus
    totalMarks?: number
    obtainedMarks?: number
    percentage?: number
    isPassed?: boolean
    timeSpent?: number | null
    ipAddress?: string | null
    userAgent?: string | null
    isCheating?: boolean
    cheatingReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionResponseCreateManyUserInput = {
    id?: string
    attemptId: string
    questionId: string
    selectedOptions?: QuestionResponseCreateselectedOptionsInput | string[]
    isCorrect?: boolean | null
    marksObtained?: number
    timeSpent?: number | null
    answeredAt?: Date | string
    submittedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionScoreCreateManyUserInput = {
    id?: string
    responseId: string
    questionId: string
    attemptId: string
    isCorrect?: boolean
    marksObtained?: number
    maxMarks?: number
    accuracy?: number
    timeEfficiency?: number
    difficultyBonus?: number
    penalty?: number
    responseTime?: number
    attemptsCount?: number
    confidenceLevel?: number
    questionDifficulty: string
    scoredAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamScoreCreateManyUserInput = {
    id?: string
    attemptId: string
    examId: string
    totalMarks?: number
    maxMarks?: number
    percentage?: number
    grade?: string | null
    correctAnswers?: number
    wrongAnswers?: number
    unanswered?: number
    totalQuestions?: number
    totalTimeSpent?: number
    averageTimePerQuestion?: number
    timeEfficiency?: number
    easyCorrect?: number
    easyTotal?: number
    mediumCorrect?: number
    mediumTotal?: number
    hardCorrect?: number
    hardTotal?: number
    accuracy?: number
    speedScore?: number
    consistencyScore?: number
    difficultyScore?: number
    percentile?: number | null
    rank?: number | null
    improvement?: number | null
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPerformanceCreateManyUserInput = {
    id?: string
    examCategoryId?: string | null
    totalAttempts?: number
    totalPassed?: number
    totalFailed?: number
    passRate?: number
    averageScore?: number
    highestScore?: number
    lowestScore?: number
    totalMarks?: number
    totalTimeSpent?: number
    averageTimePerExam?: number
    easyAccuracy?: number
    mediumAccuracy?: number
    hardAccuracy?: number
    improvementRate?: number
    consistencyScore?: number
    learningCurve?: number
    lastAttemptAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    readAt?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    resource: string
    resourceId?: string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type UserSessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expiresAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ExamCategoryUserCreateManyUserInput = {
    id?: string
    examCategoryId: string
    accessLevel?: $Enums.AccessLevel
    grantedAt?: Date | string
    grantedBy: string
  }

  export type StudyGroupMemberCreateManyUserInput = {
    id?: string
    groupId: string
    role?: $Enums.GroupRole
    joinedAt?: Date | string
    isActive?: boolean
  }

  export type CertificateCreateManyUserInput = {
    id?: string
    examId: string
    attemptId: string
    certificateNumber: string
    issuedAt?: Date | string
    expiresAt?: Date | string | null
    isRevoked?: boolean
    revokedAt?: Date | string | null
    revokedBy?: string | null
    revokedReason?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamCategoryUserCreateManyGranterInput = {
    id?: string
    examCategoryId: string
    userId: string
    accessLevel?: $Enums.AccessLevel
    grantedAt?: Date | string
  }

  export type StudyGroupCreateManyCreatorInput = {
    id?: string
    name: string
    description?: string | null
    isPrivate?: boolean
    maxMembers?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionCreateManyCreatorInput = {
    id?: string
    text: string
    type: $Enums.QuestionType
    difficulty: $Enums.QuestionDifficulty
    examCategoryId: string
    marks?: number
    timeLimit?: number | null
    isActive?: boolean
    isPublic?: boolean
    approvedBy?: string | null
    approvedAt?: Date | string | null
    usageCount?: number
    correctAnswerRate?: number | null
    averageTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionCreateManyApproverInput = {
    id?: string
    text: string
    type: $Enums.QuestionType
    difficulty: $Enums.QuestionDifficulty
    examCategoryId: string
    marks?: number
    timeLimit?: number | null
    isActive?: boolean
    isPublic?: boolean
    createdBy: string
    approvedAt?: Date | string | null
    usageCount?: number
    correctAnswerRate?: number | null
    averageTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamCreateManyCreatorInput = {
    id?: string
    title: string
    description?: string | null
    examCategoryId: string
    duration: number
    totalMarks: number
    passingMarks: number
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    isActive?: boolean
    isPublic?: boolean
    allowRetakes?: boolean
    maxRetakes?: number
    showResults?: boolean
    showAnswers?: boolean
    randomizeQuestions?: boolean
    randomizeOptions?: boolean
    questionOverlapPercentage?: number
    approvedBy?: string | null
    approvedAt?: Date | string | null
    scheduledStart?: Date | string | null
    scheduledEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamCreateManyApproverInput = {
    id?: string
    title: string
    description?: string | null
    examCategoryId: string
    duration: number
    totalMarks: number
    passingMarks: number
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    isActive?: boolean
    isPublic?: boolean
    allowRetakes?: boolean
    maxRetakes?: number
    showResults?: boolean
    showAnswers?: boolean
    randomizeQuestions?: boolean
    randomizeOptions?: boolean
    questionOverlapPercentage?: number
    createdBy: string
    approvedAt?: Date | string | null
    scheduledStart?: Date | string | null
    scheduledEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificateCreateManyRevokerInput = {
    id?: string
    userId: string
    examId: string
    attemptId: string
    certificateNumber: string
    issuedAt?: Date | string
    expiresAt?: Date | string | null
    isRevoked?: boolean
    revokedAt?: Date | string | null
    revokedReason?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamBookingUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exam?: ExamUpdateOneRequiredWithoutBookingsNestedInput
    payment?: PaymentUpdateOneWithoutBookingNestedInput
    attempts?: ExamAttemptUpdateManyWithoutBookingNestedInput
  }

  export type ExamBookingUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUncheckedUpdateOneWithoutBookingNestedInput
    attempts?: ExamAttemptUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type ExamBookingUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    stripePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: ExamBookingUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    stripePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    stripePaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeRefundId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamAttemptUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttemptStatusFieldUpdateOperationsInput | $Enums.AttemptStatus
    totalMarks?: IntFieldUpdateOperationsInput | number
    obtainedMarks?: IntFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isCheating?: BoolFieldUpdateOperationsInput | boolean
    cheatingReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exam?: ExamUpdateOneRequiredWithoutAttemptsNestedInput
    booking?: ExamBookingUpdateOneWithoutAttemptsNestedInput
    responses?: QuestionResponseUpdateManyWithoutAttemptNestedInput
    questionScores?: QuestionScoreUpdateManyWithoutAttemptNestedInput
    examScore?: ExamScoreUpdateOneWithoutAttemptNestedInput
    certificate?: CertificateUpdateOneWithoutAttemptNestedInput
  }

  export type ExamAttemptUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttemptStatusFieldUpdateOperationsInput | $Enums.AttemptStatus
    totalMarks?: IntFieldUpdateOperationsInput | number
    obtainedMarks?: IntFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isCheating?: BoolFieldUpdateOperationsInput | boolean
    cheatingReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: QuestionResponseUncheckedUpdateManyWithoutAttemptNestedInput
    questionScores?: QuestionScoreUncheckedUpdateManyWithoutAttemptNestedInput
    examScore?: ExamScoreUncheckedUpdateOneWithoutAttemptNestedInput
    certificate?: CertificateUncheckedUpdateOneWithoutAttemptNestedInput
  }

  export type ExamAttemptUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttemptStatusFieldUpdateOperationsInput | $Enums.AttemptStatus
    totalMarks?: IntFieldUpdateOperationsInput | number
    obtainedMarks?: IntFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isCheating?: BoolFieldUpdateOperationsInput | boolean
    cheatingReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionResponseUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    selectedOptions?: QuestionResponseUpdateselectedOptionsInput | string[]
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marksObtained?: IntFieldUpdateOperationsInput | number
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    answeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempt?: ExamAttemptUpdateOneRequiredWithoutResponsesNestedInput
    question?: QuestionUpdateOneRequiredWithoutResponsesNestedInput
    score?: QuestionScoreUpdateOneWithoutResponseNestedInput
  }

  export type QuestionResponseUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    attemptId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    selectedOptions?: QuestionResponseUpdateselectedOptionsInput | string[]
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marksObtained?: IntFieldUpdateOperationsInput | number
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    answeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: QuestionScoreUncheckedUpdateOneWithoutResponseNestedInput
  }

  export type QuestionResponseUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    attemptId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    selectedOptions?: QuestionResponseUpdateselectedOptionsInput | string[]
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marksObtained?: IntFieldUpdateOperationsInput | number
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    answeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionScoreUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    marksObtained?: FloatFieldUpdateOperationsInput | number
    maxMarks?: FloatFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    timeEfficiency?: FloatFieldUpdateOperationsInput | number
    difficultyBonus?: FloatFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    attemptsCount?: IntFieldUpdateOperationsInput | number
    confidenceLevel?: FloatFieldUpdateOperationsInput | number
    questionDifficulty?: StringFieldUpdateOperationsInput | string
    scoredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    response?: QuestionResponseUpdateOneRequiredWithoutScoreNestedInput
    question?: QuestionUpdateOneRequiredWithoutScoresNestedInput
    attempt?: ExamAttemptUpdateOneRequiredWithoutQuestionScoresNestedInput
  }

  export type QuestionScoreUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    responseId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    attemptId?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    marksObtained?: FloatFieldUpdateOperationsInput | number
    maxMarks?: FloatFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    timeEfficiency?: FloatFieldUpdateOperationsInput | number
    difficultyBonus?: FloatFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    attemptsCount?: IntFieldUpdateOperationsInput | number
    confidenceLevel?: FloatFieldUpdateOperationsInput | number
    questionDifficulty?: StringFieldUpdateOperationsInput | string
    scoredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionScoreUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    responseId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    attemptId?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    marksObtained?: FloatFieldUpdateOperationsInput | number
    maxMarks?: FloatFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    timeEfficiency?: FloatFieldUpdateOperationsInput | number
    difficultyBonus?: FloatFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    attemptsCount?: IntFieldUpdateOperationsInput | number
    confidenceLevel?: FloatFieldUpdateOperationsInput | number
    questionDifficulty?: StringFieldUpdateOperationsInput | string
    scoredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamScoreUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalMarks?: FloatFieldUpdateOperationsInput | number
    maxMarks?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswers?: IntFieldUpdateOperationsInput | number
    wrongAnswers?: IntFieldUpdateOperationsInput | number
    unanswered?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    totalTimeSpent?: IntFieldUpdateOperationsInput | number
    averageTimePerQuestion?: FloatFieldUpdateOperationsInput | number
    timeEfficiency?: FloatFieldUpdateOperationsInput | number
    easyCorrect?: IntFieldUpdateOperationsInput | number
    easyTotal?: IntFieldUpdateOperationsInput | number
    mediumCorrect?: IntFieldUpdateOperationsInput | number
    mediumTotal?: IntFieldUpdateOperationsInput | number
    hardCorrect?: IntFieldUpdateOperationsInput | number
    hardTotal?: IntFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    speedScore?: FloatFieldUpdateOperationsInput | number
    consistencyScore?: FloatFieldUpdateOperationsInput | number
    difficultyScore?: FloatFieldUpdateOperationsInput | number
    percentile?: NullableFloatFieldUpdateOperationsInput | number | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    improvement?: NullableFloatFieldUpdateOperationsInput | number | null
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempt?: ExamAttemptUpdateOneRequiredWithoutExamScoreNestedInput
    exam?: ExamUpdateOneRequiredWithoutExamScoresNestedInput
  }

  export type ExamScoreUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    attemptId?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    totalMarks?: FloatFieldUpdateOperationsInput | number
    maxMarks?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswers?: IntFieldUpdateOperationsInput | number
    wrongAnswers?: IntFieldUpdateOperationsInput | number
    unanswered?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    totalTimeSpent?: IntFieldUpdateOperationsInput | number
    averageTimePerQuestion?: FloatFieldUpdateOperationsInput | number
    timeEfficiency?: FloatFieldUpdateOperationsInput | number
    easyCorrect?: IntFieldUpdateOperationsInput | number
    easyTotal?: IntFieldUpdateOperationsInput | number
    mediumCorrect?: IntFieldUpdateOperationsInput | number
    mediumTotal?: IntFieldUpdateOperationsInput | number
    hardCorrect?: IntFieldUpdateOperationsInput | number
    hardTotal?: IntFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    speedScore?: FloatFieldUpdateOperationsInput | number
    consistencyScore?: FloatFieldUpdateOperationsInput | number
    difficultyScore?: FloatFieldUpdateOperationsInput | number
    percentile?: NullableFloatFieldUpdateOperationsInput | number | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    improvement?: NullableFloatFieldUpdateOperationsInput | number | null
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamScoreUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    attemptId?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    totalMarks?: FloatFieldUpdateOperationsInput | number
    maxMarks?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswers?: IntFieldUpdateOperationsInput | number
    wrongAnswers?: IntFieldUpdateOperationsInput | number
    unanswered?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    totalTimeSpent?: IntFieldUpdateOperationsInput | number
    averageTimePerQuestion?: FloatFieldUpdateOperationsInput | number
    timeEfficiency?: FloatFieldUpdateOperationsInput | number
    easyCorrect?: IntFieldUpdateOperationsInput | number
    easyTotal?: IntFieldUpdateOperationsInput | number
    mediumCorrect?: IntFieldUpdateOperationsInput | number
    mediumTotal?: IntFieldUpdateOperationsInput | number
    hardCorrect?: IntFieldUpdateOperationsInput | number
    hardTotal?: IntFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    speedScore?: FloatFieldUpdateOperationsInput | number
    consistencyScore?: FloatFieldUpdateOperationsInput | number
    difficultyScore?: FloatFieldUpdateOperationsInput | number
    percentile?: NullableFloatFieldUpdateOperationsInput | number | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    improvement?: NullableFloatFieldUpdateOperationsInput | number | null
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPerformanceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAttempts?: IntFieldUpdateOperationsInput | number
    totalPassed?: IntFieldUpdateOperationsInput | number
    totalFailed?: IntFieldUpdateOperationsInput | number
    passRate?: FloatFieldUpdateOperationsInput | number
    averageScore?: FloatFieldUpdateOperationsInput | number
    highestScore?: FloatFieldUpdateOperationsInput | number
    lowestScore?: FloatFieldUpdateOperationsInput | number
    totalMarks?: FloatFieldUpdateOperationsInput | number
    totalTimeSpent?: IntFieldUpdateOperationsInput | number
    averageTimePerExam?: FloatFieldUpdateOperationsInput | number
    easyAccuracy?: FloatFieldUpdateOperationsInput | number
    mediumAccuracy?: FloatFieldUpdateOperationsInput | number
    hardAccuracy?: FloatFieldUpdateOperationsInput | number
    improvementRate?: FloatFieldUpdateOperationsInput | number
    consistencyScore?: FloatFieldUpdateOperationsInput | number
    learningCurve?: FloatFieldUpdateOperationsInput | number
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examCategory?: ExamCategoryUpdateOneWithoutUserPerformancesNestedInput
  }

  export type UserPerformanceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    examCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    totalAttempts?: IntFieldUpdateOperationsInput | number
    totalPassed?: IntFieldUpdateOperationsInput | number
    totalFailed?: IntFieldUpdateOperationsInput | number
    passRate?: FloatFieldUpdateOperationsInput | number
    averageScore?: FloatFieldUpdateOperationsInput | number
    highestScore?: FloatFieldUpdateOperationsInput | number
    lowestScore?: FloatFieldUpdateOperationsInput | number
    totalMarks?: FloatFieldUpdateOperationsInput | number
    totalTimeSpent?: IntFieldUpdateOperationsInput | number
    averageTimePerExam?: FloatFieldUpdateOperationsInput | number
    easyAccuracy?: FloatFieldUpdateOperationsInput | number
    mediumAccuracy?: FloatFieldUpdateOperationsInput | number
    hardAccuracy?: FloatFieldUpdateOperationsInput | number
    improvementRate?: FloatFieldUpdateOperationsInput | number
    consistencyScore?: FloatFieldUpdateOperationsInput | number
    learningCurve?: FloatFieldUpdateOperationsInput | number
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPerformanceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    examCategoryId?: NullableStringFieldUpdateOperationsInput | string | null
    totalAttempts?: IntFieldUpdateOperationsInput | number
    totalPassed?: IntFieldUpdateOperationsInput | number
    totalFailed?: IntFieldUpdateOperationsInput | number
    passRate?: FloatFieldUpdateOperationsInput | number
    averageScore?: FloatFieldUpdateOperationsInput | number
    highestScore?: FloatFieldUpdateOperationsInput | number
    lowestScore?: FloatFieldUpdateOperationsInput | number
    totalMarks?: FloatFieldUpdateOperationsInput | number
    totalTimeSpent?: IntFieldUpdateOperationsInput | number
    averageTimePerExam?: FloatFieldUpdateOperationsInput | number
    easyAccuracy?: FloatFieldUpdateOperationsInput | number
    mediumAccuracy?: FloatFieldUpdateOperationsInput | number
    hardAccuracy?: FloatFieldUpdateOperationsInput | number
    improvementRate?: FloatFieldUpdateOperationsInput | number
    consistencyScore?: FloatFieldUpdateOperationsInput | number
    learningCurve?: FloatFieldUpdateOperationsInput | number
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamCategoryUserUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examCategory?: ExamCategoryUpdateOneRequiredWithoutUsersNestedInput
    granter?: UserUpdateOneRequiredWithoutGrantedExamCategoriesNestedInput
  }

  export type ExamCategoryUserUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    examCategoryId?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grantedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ExamCategoryUserUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    examCategoryId?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grantedBy?: StringFieldUpdateOperationsInput | string
  }

  export type StudyGroupMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumGroupRoleFieldUpdateOperationsInput | $Enums.GroupRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    group?: StudyGroupUpdateOneRequiredWithoutMembersNestedInput
  }

  export type StudyGroupMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    role?: EnumGroupRoleFieldUpdateOperationsInput | $Enums.GroupRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudyGroupMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    groupId?: StringFieldUpdateOperationsInput | string
    role?: EnumGroupRoleFieldUpdateOperationsInput | $Enums.GroupRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type CertificateUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    certificateNumber?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exam?: ExamUpdateOneRequiredWithoutCertificatesNestedInput
    attempt?: ExamAttemptUpdateOneRequiredWithoutCertificateNestedInput
    revoker?: UserUpdateOneWithoutRevokedCertificatesNestedInput
  }

  export type CertificateUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    attemptId?: StringFieldUpdateOperationsInput | string
    certificateNumber?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedBy?: NullableStringFieldUpdateOperationsInput | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    attemptId?: StringFieldUpdateOperationsInput | string
    certificateNumber?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedBy?: NullableStringFieldUpdateOperationsInput | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamCategoryUserUpdateWithoutGranterInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examCategory?: ExamCategoryUpdateOneRequiredWithoutUsersNestedInput
    user?: UserUpdateOneRequiredWithoutExamCategoriesNestedInput
  }

  export type ExamCategoryUserUncheckedUpdateWithoutGranterInput = {
    id?: StringFieldUpdateOperationsInput | string
    examCategoryId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamCategoryUserUncheckedUpdateManyWithoutGranterInput = {
    id?: StringFieldUpdateOperationsInput | string
    examCategoryId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudyGroupUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    maxMembers?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: StudyGroupMemberUpdateManyWithoutGroupNestedInput
  }

  export type StudyGroupUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    maxMembers?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: StudyGroupMemberUncheckedUpdateManyWithoutGroupNestedInput
  }

  export type StudyGroupUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    maxMembers?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    difficulty?: EnumQuestionDifficultyFieldUpdateOperationsInput | $Enums.QuestionDifficulty
    marks?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    correctAnswerRate?: NullableFloatFieldUpdateOperationsInput | number | null
    averageTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examCategory?: ExamCategoryUpdateOneRequiredWithoutQuestionsNestedInput
    approver?: UserUpdateOneWithoutApprovedQuestionsNestedInput
    options?: QuestionOptionUpdateManyWithoutQuestionNestedInput
    images?: QuestionImageUpdateManyWithoutQuestionNestedInput
    tags?: QuestionTagUpdateManyWithoutQuestionNestedInput
    examQuestions?: ExamQuestionUpdateManyWithoutQuestionNestedInput
    responses?: QuestionResponseUpdateManyWithoutQuestionNestedInput
    scores?: QuestionScoreUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    difficulty?: EnumQuestionDifficultyFieldUpdateOperationsInput | $Enums.QuestionDifficulty
    examCategoryId?: StringFieldUpdateOperationsInput | string
    marks?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    correctAnswerRate?: NullableFloatFieldUpdateOperationsInput | number | null
    averageTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: QuestionOptionUncheckedUpdateManyWithoutQuestionNestedInput
    images?: QuestionImageUncheckedUpdateManyWithoutQuestionNestedInput
    tags?: QuestionTagUncheckedUpdateManyWithoutQuestionNestedInput
    examQuestions?: ExamQuestionUncheckedUpdateManyWithoutQuestionNestedInput
    responses?: QuestionResponseUncheckedUpdateManyWithoutQuestionNestedInput
    scores?: QuestionScoreUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    difficulty?: EnumQuestionDifficultyFieldUpdateOperationsInput | $Enums.QuestionDifficulty
    examCategoryId?: StringFieldUpdateOperationsInput | string
    marks?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    correctAnswerRate?: NullableFloatFieldUpdateOperationsInput | number | null
    averageTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    difficulty?: EnumQuestionDifficultyFieldUpdateOperationsInput | $Enums.QuestionDifficulty
    marks?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    correctAnswerRate?: NullableFloatFieldUpdateOperationsInput | number | null
    averageTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examCategory?: ExamCategoryUpdateOneRequiredWithoutQuestionsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedQuestionsNestedInput
    options?: QuestionOptionUpdateManyWithoutQuestionNestedInput
    images?: QuestionImageUpdateManyWithoutQuestionNestedInput
    tags?: QuestionTagUpdateManyWithoutQuestionNestedInput
    examQuestions?: ExamQuestionUpdateManyWithoutQuestionNestedInput
    responses?: QuestionResponseUpdateManyWithoutQuestionNestedInput
    scores?: QuestionScoreUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    difficulty?: EnumQuestionDifficultyFieldUpdateOperationsInput | $Enums.QuestionDifficulty
    examCategoryId?: StringFieldUpdateOperationsInput | string
    marks?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    correctAnswerRate?: NullableFloatFieldUpdateOperationsInput | number | null
    averageTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: QuestionOptionUncheckedUpdateManyWithoutQuestionNestedInput
    images?: QuestionImageUncheckedUpdateManyWithoutQuestionNestedInput
    tags?: QuestionTagUncheckedUpdateManyWithoutQuestionNestedInput
    examQuestions?: ExamQuestionUncheckedUpdateManyWithoutQuestionNestedInput
    responses?: QuestionResponseUncheckedUpdateManyWithoutQuestionNestedInput
    scores?: QuestionScoreUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateManyWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    difficulty?: EnumQuestionDifficultyFieldUpdateOperationsInput | $Enums.QuestionDifficulty
    examCategoryId?: StringFieldUpdateOperationsInput | string
    marks?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    correctAnswerRate?: NullableFloatFieldUpdateOperationsInput | number | null
    averageTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    totalMarks?: IntFieldUpdateOperationsInput | number
    passingMarks?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowRetakes?: BoolFieldUpdateOperationsInput | boolean
    maxRetakes?: IntFieldUpdateOperationsInput | number
    showResults?: BoolFieldUpdateOperationsInput | boolean
    showAnswers?: BoolFieldUpdateOperationsInput | boolean
    randomizeQuestions?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: BoolFieldUpdateOperationsInput | boolean
    questionOverlapPercentage?: FloatFieldUpdateOperationsInput | number
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examCategory?: ExamCategoryUpdateOneRequiredWithoutExamsNestedInput
    approver?: UserUpdateOneWithoutApprovedExamsNestedInput
    questions?: ExamQuestionUpdateManyWithoutExamNestedInput
    bookings?: ExamBookingUpdateManyWithoutExamNestedInput
    attempts?: ExamAttemptUpdateManyWithoutExamNestedInput
    examScores?: ExamScoreUpdateManyWithoutExamNestedInput
    certificates?: CertificateUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    examCategoryId?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    totalMarks?: IntFieldUpdateOperationsInput | number
    passingMarks?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowRetakes?: BoolFieldUpdateOperationsInput | boolean
    maxRetakes?: IntFieldUpdateOperationsInput | number
    showResults?: BoolFieldUpdateOperationsInput | boolean
    showAnswers?: BoolFieldUpdateOperationsInput | boolean
    randomizeQuestions?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: BoolFieldUpdateOperationsInput | boolean
    questionOverlapPercentage?: FloatFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: ExamQuestionUncheckedUpdateManyWithoutExamNestedInput
    bookings?: ExamBookingUncheckedUpdateManyWithoutExamNestedInput
    attempts?: ExamAttemptUncheckedUpdateManyWithoutExamNestedInput
    examScores?: ExamScoreUncheckedUpdateManyWithoutExamNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    examCategoryId?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    totalMarks?: IntFieldUpdateOperationsInput | number
    passingMarks?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowRetakes?: BoolFieldUpdateOperationsInput | boolean
    maxRetakes?: IntFieldUpdateOperationsInput | number
    showResults?: BoolFieldUpdateOperationsInput | boolean
    showAnswers?: BoolFieldUpdateOperationsInput | boolean
    randomizeQuestions?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: BoolFieldUpdateOperationsInput | boolean
    questionOverlapPercentage?: FloatFieldUpdateOperationsInput | number
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    totalMarks?: IntFieldUpdateOperationsInput | number
    passingMarks?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowRetakes?: BoolFieldUpdateOperationsInput | boolean
    maxRetakes?: IntFieldUpdateOperationsInput | number
    showResults?: BoolFieldUpdateOperationsInput | boolean
    showAnswers?: BoolFieldUpdateOperationsInput | boolean
    randomizeQuestions?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: BoolFieldUpdateOperationsInput | boolean
    questionOverlapPercentage?: FloatFieldUpdateOperationsInput | number
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    examCategory?: ExamCategoryUpdateOneRequiredWithoutExamsNestedInput
    creator?: UserUpdateOneRequiredWithoutCreatedExamsNestedInput
    questions?: ExamQuestionUpdateManyWithoutExamNestedInput
    bookings?: ExamBookingUpdateManyWithoutExamNestedInput
    attempts?: ExamAttemptUpdateManyWithoutExamNestedInput
    examScores?: ExamScoreUpdateManyWithoutExamNestedInput
    certificates?: CertificateUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    examCategoryId?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    totalMarks?: IntFieldUpdateOperationsInput | number
    passingMarks?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowRetakes?: BoolFieldUpdateOperationsInput | boolean
    maxRetakes?: IntFieldUpdateOperationsInput | number
    showResults?: BoolFieldUpdateOperationsInput | boolean
    showAnswers?: BoolFieldUpdateOperationsInput | boolean
    randomizeQuestions?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: BoolFieldUpdateOperationsInput | boolean
    questionOverlapPercentage?: FloatFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: ExamQuestionUncheckedUpdateManyWithoutExamNestedInput
    bookings?: ExamBookingUncheckedUpdateManyWithoutExamNestedInput
    attempts?: ExamAttemptUncheckedUpdateManyWithoutExamNestedInput
    examScores?: ExamScoreUncheckedUpdateManyWithoutExamNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateManyWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    examCategoryId?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    totalMarks?: IntFieldUpdateOperationsInput | number
    passingMarks?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowRetakes?: BoolFieldUpdateOperationsInput | boolean
    maxRetakes?: IntFieldUpdateOperationsInput | number
    showResults?: BoolFieldUpdateOperationsInput | boolean
    showAnswers?: BoolFieldUpdateOperationsInput | boolean
    randomizeQuestions?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: BoolFieldUpdateOperationsInput | boolean
    questionOverlapPercentage?: FloatFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUpdateWithoutRevokerInput = {
    id?: StringFieldUpdateOperationsInput | string
    certificateNumber?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCertificatesNestedInput
    exam?: ExamUpdateOneRequiredWithoutCertificatesNestedInput
    attempt?: ExamAttemptUpdateOneRequiredWithoutCertificateNestedInput
  }

  export type CertificateUncheckedUpdateWithoutRevokerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    attemptId?: StringFieldUpdateOperationsInput | string
    certificateNumber?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUncheckedUpdateManyWithoutRevokerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    attemptId?: StringFieldUpdateOperationsInput | string
    certificateNumber?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamCreateManyExamCategoryInput = {
    id?: string
    title: string
    description?: string | null
    duration: number
    totalMarks: number
    passingMarks: number
    price: Decimal | DecimalJsLike | number | string
    currency?: string
    isActive?: boolean
    isPublic?: boolean
    allowRetakes?: boolean
    maxRetakes?: number
    showResults?: boolean
    showAnswers?: boolean
    randomizeQuestions?: boolean
    randomizeOptions?: boolean
    questionOverlapPercentage?: number
    createdBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    scheduledStart?: Date | string | null
    scheduledEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionCreateManyExamCategoryInput = {
    id?: string
    text: string
    type: $Enums.QuestionType
    difficulty: $Enums.QuestionDifficulty
    marks?: number
    timeLimit?: number | null
    isActive?: boolean
    isPublic?: boolean
    createdBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    usageCount?: number
    correctAnswerRate?: number | null
    averageTime?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamCategoryUserCreateManyExamCategoryInput = {
    id?: string
    userId: string
    accessLevel?: $Enums.AccessLevel
    grantedAt?: Date | string
    grantedBy: string
  }

  export type UserPerformanceCreateManyExamCategoryInput = {
    id?: string
    userId: string
    totalAttempts?: number
    totalPassed?: number
    totalFailed?: number
    passRate?: number
    averageScore?: number
    highestScore?: number
    lowestScore?: number
    totalMarks?: number
    totalTimeSpent?: number
    averageTimePerExam?: number
    easyAccuracy?: number
    mediumAccuracy?: number
    hardAccuracy?: number
    improvementRate?: number
    consistencyScore?: number
    learningCurve?: number
    lastAttemptAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamUpdateWithoutExamCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    totalMarks?: IntFieldUpdateOperationsInput | number
    passingMarks?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowRetakes?: BoolFieldUpdateOperationsInput | boolean
    maxRetakes?: IntFieldUpdateOperationsInput | number
    showResults?: BoolFieldUpdateOperationsInput | boolean
    showAnswers?: BoolFieldUpdateOperationsInput | boolean
    randomizeQuestions?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: BoolFieldUpdateOperationsInput | boolean
    questionOverlapPercentage?: FloatFieldUpdateOperationsInput | number
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedExamsNestedInput
    approver?: UserUpdateOneWithoutApprovedExamsNestedInput
    questions?: ExamQuestionUpdateManyWithoutExamNestedInput
    bookings?: ExamBookingUpdateManyWithoutExamNestedInput
    attempts?: ExamAttemptUpdateManyWithoutExamNestedInput
    examScores?: ExamScoreUpdateManyWithoutExamNestedInput
    certificates?: CertificateUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateWithoutExamCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    totalMarks?: IntFieldUpdateOperationsInput | number
    passingMarks?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowRetakes?: BoolFieldUpdateOperationsInput | boolean
    maxRetakes?: IntFieldUpdateOperationsInput | number
    showResults?: BoolFieldUpdateOperationsInput | boolean
    showAnswers?: BoolFieldUpdateOperationsInput | boolean
    randomizeQuestions?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: BoolFieldUpdateOperationsInput | boolean
    questionOverlapPercentage?: FloatFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: ExamQuestionUncheckedUpdateManyWithoutExamNestedInput
    bookings?: ExamBookingUncheckedUpdateManyWithoutExamNestedInput
    attempts?: ExamAttemptUncheckedUpdateManyWithoutExamNestedInput
    examScores?: ExamScoreUncheckedUpdateManyWithoutExamNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutExamNestedInput
  }

  export type ExamUncheckedUpdateManyWithoutExamCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: IntFieldUpdateOperationsInput | number
    totalMarks?: IntFieldUpdateOperationsInput | number
    passingMarks?: IntFieldUpdateOperationsInput | number
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    allowRetakes?: BoolFieldUpdateOperationsInput | boolean
    maxRetakes?: IntFieldUpdateOperationsInput | number
    showResults?: BoolFieldUpdateOperationsInput | boolean
    showAnswers?: BoolFieldUpdateOperationsInput | boolean
    randomizeQuestions?: BoolFieldUpdateOperationsInput | boolean
    randomizeOptions?: BoolFieldUpdateOperationsInput | boolean
    questionOverlapPercentage?: FloatFieldUpdateOperationsInput | number
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scheduledEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionUpdateWithoutExamCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    difficulty?: EnumQuestionDifficultyFieldUpdateOperationsInput | $Enums.QuestionDifficulty
    marks?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    correctAnswerRate?: NullableFloatFieldUpdateOperationsInput | number | null
    averageTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutCreatedQuestionsNestedInput
    approver?: UserUpdateOneWithoutApprovedQuestionsNestedInput
    options?: QuestionOptionUpdateManyWithoutQuestionNestedInput
    images?: QuestionImageUpdateManyWithoutQuestionNestedInput
    tags?: QuestionTagUpdateManyWithoutQuestionNestedInput
    examQuestions?: ExamQuestionUpdateManyWithoutQuestionNestedInput
    responses?: QuestionResponseUpdateManyWithoutQuestionNestedInput
    scores?: QuestionScoreUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateWithoutExamCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    difficulty?: EnumQuestionDifficultyFieldUpdateOperationsInput | $Enums.QuestionDifficulty
    marks?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    correctAnswerRate?: NullableFloatFieldUpdateOperationsInput | number | null
    averageTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: QuestionOptionUncheckedUpdateManyWithoutQuestionNestedInput
    images?: QuestionImageUncheckedUpdateManyWithoutQuestionNestedInput
    tags?: QuestionTagUncheckedUpdateManyWithoutQuestionNestedInput
    examQuestions?: ExamQuestionUncheckedUpdateManyWithoutQuestionNestedInput
    responses?: QuestionResponseUncheckedUpdateManyWithoutQuestionNestedInput
    scores?: QuestionScoreUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionUncheckedUpdateManyWithoutExamCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    type?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    difficulty?: EnumQuestionDifficultyFieldUpdateOperationsInput | $Enums.QuestionDifficulty
    marks?: IntFieldUpdateOperationsInput | number
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    correctAnswerRate?: NullableFloatFieldUpdateOperationsInput | number | null
    averageTime?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamCategoryUserUpdateWithoutExamCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExamCategoriesNestedInput
    granter?: UserUpdateOneRequiredWithoutGrantedExamCategoriesNestedInput
  }

  export type ExamCategoryUserUncheckedUpdateWithoutExamCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grantedBy?: StringFieldUpdateOperationsInput | string
  }

  export type ExamCategoryUserUncheckedUpdateManyWithoutExamCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    grantedBy?: StringFieldUpdateOperationsInput | string
  }

  export type UserPerformanceUpdateWithoutExamCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalAttempts?: IntFieldUpdateOperationsInput | number
    totalPassed?: IntFieldUpdateOperationsInput | number
    totalFailed?: IntFieldUpdateOperationsInput | number
    passRate?: FloatFieldUpdateOperationsInput | number
    averageScore?: FloatFieldUpdateOperationsInput | number
    highestScore?: FloatFieldUpdateOperationsInput | number
    lowestScore?: FloatFieldUpdateOperationsInput | number
    totalMarks?: FloatFieldUpdateOperationsInput | number
    totalTimeSpent?: IntFieldUpdateOperationsInput | number
    averageTimePerExam?: FloatFieldUpdateOperationsInput | number
    easyAccuracy?: FloatFieldUpdateOperationsInput | number
    mediumAccuracy?: FloatFieldUpdateOperationsInput | number
    hardAccuracy?: FloatFieldUpdateOperationsInput | number
    improvementRate?: FloatFieldUpdateOperationsInput | number
    consistencyScore?: FloatFieldUpdateOperationsInput | number
    learningCurve?: FloatFieldUpdateOperationsInput | number
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUserPerformancesNestedInput
  }

  export type UserPerformanceUncheckedUpdateWithoutExamCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalAttempts?: IntFieldUpdateOperationsInput | number
    totalPassed?: IntFieldUpdateOperationsInput | number
    totalFailed?: IntFieldUpdateOperationsInput | number
    passRate?: FloatFieldUpdateOperationsInput | number
    averageScore?: FloatFieldUpdateOperationsInput | number
    highestScore?: FloatFieldUpdateOperationsInput | number
    lowestScore?: FloatFieldUpdateOperationsInput | number
    totalMarks?: FloatFieldUpdateOperationsInput | number
    totalTimeSpent?: IntFieldUpdateOperationsInput | number
    averageTimePerExam?: FloatFieldUpdateOperationsInput | number
    easyAccuracy?: FloatFieldUpdateOperationsInput | number
    mediumAccuracy?: FloatFieldUpdateOperationsInput | number
    hardAccuracy?: FloatFieldUpdateOperationsInput | number
    improvementRate?: FloatFieldUpdateOperationsInput | number
    consistencyScore?: FloatFieldUpdateOperationsInput | number
    learningCurve?: FloatFieldUpdateOperationsInput | number
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPerformanceUncheckedUpdateManyWithoutExamCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalAttempts?: IntFieldUpdateOperationsInput | number
    totalPassed?: IntFieldUpdateOperationsInput | number
    totalFailed?: IntFieldUpdateOperationsInput | number
    passRate?: FloatFieldUpdateOperationsInput | number
    averageScore?: FloatFieldUpdateOperationsInput | number
    highestScore?: FloatFieldUpdateOperationsInput | number
    lowestScore?: FloatFieldUpdateOperationsInput | number
    totalMarks?: FloatFieldUpdateOperationsInput | number
    totalTimeSpent?: IntFieldUpdateOperationsInput | number
    averageTimePerExam?: FloatFieldUpdateOperationsInput | number
    easyAccuracy?: FloatFieldUpdateOperationsInput | number
    mediumAccuracy?: FloatFieldUpdateOperationsInput | number
    hardAccuracy?: FloatFieldUpdateOperationsInput | number
    improvementRate?: FloatFieldUpdateOperationsInput | number
    consistencyScore?: FloatFieldUpdateOperationsInput | number
    learningCurve?: FloatFieldUpdateOperationsInput | number
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionOptionCreateManyQuestionInput = {
    id?: string
    text: string
    isCorrect?: boolean
    sortOrder?: number
    createdAt?: Date | string
  }

  export type QuestionImageCreateManyQuestionInput = {
    id?: string
    imageUrl: string
    altText?: string | null
    sortOrder?: number
    createdAt?: Date | string
  }

  export type QuestionTagCreateManyQuestionInput = {
    id?: string
    tag: string
    createdAt?: Date | string
  }

  export type ExamQuestionCreateManyQuestionInput = {
    id?: string
    examId: string
    order: number
    marks?: number
    createdAt?: Date | string
  }

  export type QuestionResponseCreateManyQuestionInput = {
    id?: string
    attemptId: string
    userId: string
    selectedOptions?: QuestionResponseCreateselectedOptionsInput | string[]
    isCorrect?: boolean | null
    marksObtained?: number
    timeSpent?: number | null
    answeredAt?: Date | string
    submittedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionScoreCreateManyQuestionInput = {
    id?: string
    responseId: string
    attemptId: string
    userId: string
    isCorrect?: boolean
    marksObtained?: number
    maxMarks?: number
    accuracy?: number
    timeEfficiency?: number
    difficultyBonus?: number
    penalty?: number
    responseTime?: number
    attemptsCount?: number
    confidenceLevel?: number
    questionDifficulty: string
    scoredAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionOptionUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionOptionUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionOptionUncheckedUpdateManyWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionImageUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionImageUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionImageUncheckedUpdateManyWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionTagUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionTagUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionTagUncheckedUpdateManyWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamQuestionUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    marks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exam?: ExamUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type ExamQuestionUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    marks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamQuestionUncheckedUpdateManyWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    marks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionResponseUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    selectedOptions?: QuestionResponseUpdateselectedOptionsInput | string[]
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marksObtained?: IntFieldUpdateOperationsInput | number
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    answeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempt?: ExamAttemptUpdateOneRequiredWithoutResponsesNestedInput
    user?: UserUpdateOneRequiredWithoutQuestionResponsesNestedInput
    score?: QuestionScoreUpdateOneWithoutResponseNestedInput
  }

  export type QuestionResponseUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    attemptId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    selectedOptions?: QuestionResponseUpdateselectedOptionsInput | string[]
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marksObtained?: IntFieldUpdateOperationsInput | number
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    answeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: QuestionScoreUncheckedUpdateOneWithoutResponseNestedInput
  }

  export type QuestionResponseUncheckedUpdateManyWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    attemptId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    selectedOptions?: QuestionResponseUpdateselectedOptionsInput | string[]
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marksObtained?: IntFieldUpdateOperationsInput | number
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    answeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionScoreUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    marksObtained?: FloatFieldUpdateOperationsInput | number
    maxMarks?: FloatFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    timeEfficiency?: FloatFieldUpdateOperationsInput | number
    difficultyBonus?: FloatFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    attemptsCount?: IntFieldUpdateOperationsInput | number
    confidenceLevel?: FloatFieldUpdateOperationsInput | number
    questionDifficulty?: StringFieldUpdateOperationsInput | string
    scoredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    response?: QuestionResponseUpdateOneRequiredWithoutScoreNestedInput
    attempt?: ExamAttemptUpdateOneRequiredWithoutQuestionScoresNestedInput
    user?: UserUpdateOneRequiredWithoutQuestionScoresNestedInput
  }

  export type QuestionScoreUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    responseId?: StringFieldUpdateOperationsInput | string
    attemptId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    marksObtained?: FloatFieldUpdateOperationsInput | number
    maxMarks?: FloatFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    timeEfficiency?: FloatFieldUpdateOperationsInput | number
    difficultyBonus?: FloatFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    attemptsCount?: IntFieldUpdateOperationsInput | number
    confidenceLevel?: FloatFieldUpdateOperationsInput | number
    questionDifficulty?: StringFieldUpdateOperationsInput | string
    scoredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionScoreUncheckedUpdateManyWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    responseId?: StringFieldUpdateOperationsInput | string
    attemptId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    marksObtained?: FloatFieldUpdateOperationsInput | number
    maxMarks?: FloatFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    timeEfficiency?: FloatFieldUpdateOperationsInput | number
    difficultyBonus?: FloatFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    attemptsCount?: IntFieldUpdateOperationsInput | number
    confidenceLevel?: FloatFieldUpdateOperationsInput | number
    questionDifficulty?: StringFieldUpdateOperationsInput | string
    scoredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamQuestionCreateManyExamInput = {
    id?: string
    questionId: string
    order: number
    marks?: number
    createdAt?: Date | string
  }

  export type ExamBookingCreateManyExamInput = {
    id?: string
    userId: string
    bookingDate?: Date | string
    scheduledAt?: Date | string | null
    status?: $Enums.BookingStatus
    paymentId?: string | null
    totalAmount: Decimal | DecimalJsLike | number | string
    currency?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamAttemptCreateManyExamInput = {
    id?: string
    userId: string
    bookingId?: string | null
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.AttemptStatus
    totalMarks?: number
    obtainedMarks?: number
    percentage?: number
    isPassed?: boolean
    timeSpent?: number | null
    ipAddress?: string | null
    userAgent?: string | null
    isCheating?: boolean
    cheatingReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamScoreCreateManyExamInput = {
    id?: string
    attemptId: string
    userId: string
    totalMarks?: number
    maxMarks?: number
    percentage?: number
    grade?: string | null
    correctAnswers?: number
    wrongAnswers?: number
    unanswered?: number
    totalQuestions?: number
    totalTimeSpent?: number
    averageTimePerQuestion?: number
    timeEfficiency?: number
    easyCorrect?: number
    easyTotal?: number
    mediumCorrect?: number
    mediumTotal?: number
    hardCorrect?: number
    hardTotal?: number
    accuracy?: number
    speedScore?: number
    consistencyScore?: number
    difficultyScore?: number
    percentile?: number | null
    rank?: number | null
    improvement?: number | null
    calculatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificateCreateManyExamInput = {
    id?: string
    userId: string
    attemptId: string
    certificateNumber: string
    issuedAt?: Date | string
    expiresAt?: Date | string | null
    isRevoked?: boolean
    revokedAt?: Date | string | null
    revokedBy?: string | null
    revokedReason?: string | null
    pdfUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamQuestionUpdateWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    marks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: QuestionUpdateOneRequiredWithoutExamQuestionsNestedInput
  }

  export type ExamQuestionUncheckedUpdateWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    marks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamQuestionUncheckedUpdateManyWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    marks?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamBookingUpdateWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExamBookingsNestedInput
    payment?: PaymentUpdateOneWithoutBookingNestedInput
    attempts?: ExamAttemptUpdateManyWithoutBookingNestedInput
  }

  export type ExamBookingUncheckedUpdateWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUncheckedUpdateOneWithoutBookingNestedInput
    attempts?: ExamAttemptUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type ExamBookingUncheckedUpdateManyWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    totalAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamAttemptUpdateWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttemptStatusFieldUpdateOperationsInput | $Enums.AttemptStatus
    totalMarks?: IntFieldUpdateOperationsInput | number
    obtainedMarks?: IntFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isCheating?: BoolFieldUpdateOperationsInput | boolean
    cheatingReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExamAttemptsNestedInput
    booking?: ExamBookingUpdateOneWithoutAttemptsNestedInput
    responses?: QuestionResponseUpdateManyWithoutAttemptNestedInput
    questionScores?: QuestionScoreUpdateManyWithoutAttemptNestedInput
    examScore?: ExamScoreUpdateOneWithoutAttemptNestedInput
    certificate?: CertificateUpdateOneWithoutAttemptNestedInput
  }

  export type ExamAttemptUncheckedUpdateWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttemptStatusFieldUpdateOperationsInput | $Enums.AttemptStatus
    totalMarks?: IntFieldUpdateOperationsInput | number
    obtainedMarks?: IntFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isCheating?: BoolFieldUpdateOperationsInput | boolean
    cheatingReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: QuestionResponseUncheckedUpdateManyWithoutAttemptNestedInput
    questionScores?: QuestionScoreUncheckedUpdateManyWithoutAttemptNestedInput
    examScore?: ExamScoreUncheckedUpdateOneWithoutAttemptNestedInput
    certificate?: CertificateUncheckedUpdateOneWithoutAttemptNestedInput
  }

  export type ExamAttemptUncheckedUpdateManyWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttemptStatusFieldUpdateOperationsInput | $Enums.AttemptStatus
    totalMarks?: IntFieldUpdateOperationsInput | number
    obtainedMarks?: IntFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isCheating?: BoolFieldUpdateOperationsInput | boolean
    cheatingReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamScoreUpdateWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    totalMarks?: FloatFieldUpdateOperationsInput | number
    maxMarks?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswers?: IntFieldUpdateOperationsInput | number
    wrongAnswers?: IntFieldUpdateOperationsInput | number
    unanswered?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    totalTimeSpent?: IntFieldUpdateOperationsInput | number
    averageTimePerQuestion?: FloatFieldUpdateOperationsInput | number
    timeEfficiency?: FloatFieldUpdateOperationsInput | number
    easyCorrect?: IntFieldUpdateOperationsInput | number
    easyTotal?: IntFieldUpdateOperationsInput | number
    mediumCorrect?: IntFieldUpdateOperationsInput | number
    mediumTotal?: IntFieldUpdateOperationsInput | number
    hardCorrect?: IntFieldUpdateOperationsInput | number
    hardTotal?: IntFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    speedScore?: FloatFieldUpdateOperationsInput | number
    consistencyScore?: FloatFieldUpdateOperationsInput | number
    difficultyScore?: FloatFieldUpdateOperationsInput | number
    percentile?: NullableFloatFieldUpdateOperationsInput | number | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    improvement?: NullableFloatFieldUpdateOperationsInput | number | null
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempt?: ExamAttemptUpdateOneRequiredWithoutExamScoreNestedInput
    user?: UserUpdateOneRequiredWithoutExamScoresNestedInput
  }

  export type ExamScoreUncheckedUpdateWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    attemptId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalMarks?: FloatFieldUpdateOperationsInput | number
    maxMarks?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswers?: IntFieldUpdateOperationsInput | number
    wrongAnswers?: IntFieldUpdateOperationsInput | number
    unanswered?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    totalTimeSpent?: IntFieldUpdateOperationsInput | number
    averageTimePerQuestion?: FloatFieldUpdateOperationsInput | number
    timeEfficiency?: FloatFieldUpdateOperationsInput | number
    easyCorrect?: IntFieldUpdateOperationsInput | number
    easyTotal?: IntFieldUpdateOperationsInput | number
    mediumCorrect?: IntFieldUpdateOperationsInput | number
    mediumTotal?: IntFieldUpdateOperationsInput | number
    hardCorrect?: IntFieldUpdateOperationsInput | number
    hardTotal?: IntFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    speedScore?: FloatFieldUpdateOperationsInput | number
    consistencyScore?: FloatFieldUpdateOperationsInput | number
    difficultyScore?: FloatFieldUpdateOperationsInput | number
    percentile?: NullableFloatFieldUpdateOperationsInput | number | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    improvement?: NullableFloatFieldUpdateOperationsInput | number | null
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamScoreUncheckedUpdateManyWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    attemptId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    totalMarks?: FloatFieldUpdateOperationsInput | number
    maxMarks?: FloatFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    correctAnswers?: IntFieldUpdateOperationsInput | number
    wrongAnswers?: IntFieldUpdateOperationsInput | number
    unanswered?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    totalTimeSpent?: IntFieldUpdateOperationsInput | number
    averageTimePerQuestion?: FloatFieldUpdateOperationsInput | number
    timeEfficiency?: FloatFieldUpdateOperationsInput | number
    easyCorrect?: IntFieldUpdateOperationsInput | number
    easyTotal?: IntFieldUpdateOperationsInput | number
    mediumCorrect?: IntFieldUpdateOperationsInput | number
    mediumTotal?: IntFieldUpdateOperationsInput | number
    hardCorrect?: IntFieldUpdateOperationsInput | number
    hardTotal?: IntFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    speedScore?: FloatFieldUpdateOperationsInput | number
    consistencyScore?: FloatFieldUpdateOperationsInput | number
    difficultyScore?: FloatFieldUpdateOperationsInput | number
    percentile?: NullableFloatFieldUpdateOperationsInput | number | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    improvement?: NullableFloatFieldUpdateOperationsInput | number | null
    calculatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUpdateWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    certificateNumber?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCertificatesNestedInput
    attempt?: ExamAttemptUpdateOneRequiredWithoutCertificateNestedInput
    revoker?: UserUpdateOneWithoutRevokedCertificatesNestedInput
  }

  export type CertificateUncheckedUpdateWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    attemptId?: StringFieldUpdateOperationsInput | string
    certificateNumber?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedBy?: NullableStringFieldUpdateOperationsInput | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUncheckedUpdateManyWithoutExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    attemptId?: StringFieldUpdateOperationsInput | string
    certificateNumber?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedBy?: NullableStringFieldUpdateOperationsInput | string | null
    revokedReason?: NullableStringFieldUpdateOperationsInput | string | null
    pdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamAttemptCreateManyBookingInput = {
    id?: string
    userId: string
    examId: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    status?: $Enums.AttemptStatus
    totalMarks?: number
    obtainedMarks?: number
    percentage?: number
    isPassed?: boolean
    timeSpent?: number | null
    ipAddress?: string | null
    userAgent?: string | null
    isCheating?: boolean
    cheatingReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamAttemptUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttemptStatusFieldUpdateOperationsInput | $Enums.AttemptStatus
    totalMarks?: IntFieldUpdateOperationsInput | number
    obtainedMarks?: IntFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isCheating?: BoolFieldUpdateOperationsInput | boolean
    cheatingReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExamAttemptsNestedInput
    exam?: ExamUpdateOneRequiredWithoutAttemptsNestedInput
    responses?: QuestionResponseUpdateManyWithoutAttemptNestedInput
    questionScores?: QuestionScoreUpdateManyWithoutAttemptNestedInput
    examScore?: ExamScoreUpdateOneWithoutAttemptNestedInput
    certificate?: CertificateUpdateOneWithoutAttemptNestedInput
  }

  export type ExamAttemptUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttemptStatusFieldUpdateOperationsInput | $Enums.AttemptStatus
    totalMarks?: IntFieldUpdateOperationsInput | number
    obtainedMarks?: IntFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isCheating?: BoolFieldUpdateOperationsInput | boolean
    cheatingReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    responses?: QuestionResponseUncheckedUpdateManyWithoutAttemptNestedInput
    questionScores?: QuestionScoreUncheckedUpdateManyWithoutAttemptNestedInput
    examScore?: ExamScoreUncheckedUpdateOneWithoutAttemptNestedInput
    certificate?: CertificateUncheckedUpdateOneWithoutAttemptNestedInput
  }

  export type ExamAttemptUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    examId?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumAttemptStatusFieldUpdateOperationsInput | $Enums.AttemptStatus
    totalMarks?: IntFieldUpdateOperationsInput | number
    obtainedMarks?: IntFieldUpdateOperationsInput | number
    percentage?: FloatFieldUpdateOperationsInput | number
    isPassed?: BoolFieldUpdateOperationsInput | boolean
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    isCheating?: BoolFieldUpdateOperationsInput | boolean
    cheatingReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionResponseCreateManyAttemptInput = {
    id?: string
    questionId: string
    userId: string
    selectedOptions?: QuestionResponseCreateselectedOptionsInput | string[]
    isCorrect?: boolean | null
    marksObtained?: number
    timeSpent?: number | null
    answeredAt?: Date | string
    submittedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionScoreCreateManyAttemptInput = {
    id?: string
    responseId: string
    questionId: string
    userId: string
    isCorrect?: boolean
    marksObtained?: number
    maxMarks?: number
    accuracy?: number
    timeEfficiency?: number
    difficultyBonus?: number
    penalty?: number
    responseTime?: number
    attemptsCount?: number
    confidenceLevel?: number
    questionDifficulty: string
    scoredAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionResponseUpdateWithoutAttemptInput = {
    id?: StringFieldUpdateOperationsInput | string
    selectedOptions?: QuestionResponseUpdateselectedOptionsInput | string[]
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marksObtained?: IntFieldUpdateOperationsInput | number
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    answeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: QuestionUpdateOneRequiredWithoutResponsesNestedInput
    user?: UserUpdateOneRequiredWithoutQuestionResponsesNestedInput
    score?: QuestionScoreUpdateOneWithoutResponseNestedInput
  }

  export type QuestionResponseUncheckedUpdateWithoutAttemptInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    selectedOptions?: QuestionResponseUpdateselectedOptionsInput | string[]
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marksObtained?: IntFieldUpdateOperationsInput | number
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    answeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: QuestionScoreUncheckedUpdateOneWithoutResponseNestedInput
  }

  export type QuestionResponseUncheckedUpdateManyWithoutAttemptInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    selectedOptions?: QuestionResponseUpdateselectedOptionsInput | string[]
    isCorrect?: NullableBoolFieldUpdateOperationsInput | boolean | null
    marksObtained?: IntFieldUpdateOperationsInput | number
    timeSpent?: NullableIntFieldUpdateOperationsInput | number | null
    answeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionScoreUpdateWithoutAttemptInput = {
    id?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    marksObtained?: FloatFieldUpdateOperationsInput | number
    maxMarks?: FloatFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    timeEfficiency?: FloatFieldUpdateOperationsInput | number
    difficultyBonus?: FloatFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    attemptsCount?: IntFieldUpdateOperationsInput | number
    confidenceLevel?: FloatFieldUpdateOperationsInput | number
    questionDifficulty?: StringFieldUpdateOperationsInput | string
    scoredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    response?: QuestionResponseUpdateOneRequiredWithoutScoreNestedInput
    question?: QuestionUpdateOneRequiredWithoutScoresNestedInput
    user?: UserUpdateOneRequiredWithoutQuestionScoresNestedInput
  }

  export type QuestionScoreUncheckedUpdateWithoutAttemptInput = {
    id?: StringFieldUpdateOperationsInput | string
    responseId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    marksObtained?: FloatFieldUpdateOperationsInput | number
    maxMarks?: FloatFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    timeEfficiency?: FloatFieldUpdateOperationsInput | number
    difficultyBonus?: FloatFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    attemptsCount?: IntFieldUpdateOperationsInput | number
    confidenceLevel?: FloatFieldUpdateOperationsInput | number
    questionDifficulty?: StringFieldUpdateOperationsInput | string
    scoredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionScoreUncheckedUpdateManyWithoutAttemptInput = {
    id?: StringFieldUpdateOperationsInput | string
    responseId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    marksObtained?: FloatFieldUpdateOperationsInput | number
    maxMarks?: FloatFieldUpdateOperationsInput | number
    accuracy?: FloatFieldUpdateOperationsInput | number
    timeEfficiency?: FloatFieldUpdateOperationsInput | number
    difficultyBonus?: FloatFieldUpdateOperationsInput | number
    penalty?: FloatFieldUpdateOperationsInput | number
    responseTime?: IntFieldUpdateOperationsInput | number
    attemptsCount?: IntFieldUpdateOperationsInput | number
    confidenceLevel?: FloatFieldUpdateOperationsInput | number
    questionDifficulty?: StringFieldUpdateOperationsInput | string
    scoredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudyGroupMemberCreateManyGroupInput = {
    id?: string
    userId: string
    role?: $Enums.GroupRole
    joinedAt?: Date | string
    isActive?: boolean
  }

  export type StudyGroupMemberUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumGroupRoleFieldUpdateOperationsInput | $Enums.GroupRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutStudyGroupsNestedInput
  }

  export type StudyGroupMemberUncheckedUpdateWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumGroupRoleFieldUpdateOperationsInput | $Enums.GroupRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudyGroupMemberUncheckedUpdateManyWithoutGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumGroupRoleFieldUpdateOperationsInput | $Enums.GroupRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}